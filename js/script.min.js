(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    (function (process){(function (){
    /**
     * @popperjs/core v2.11.7 - MIT License
     */
    
    'use strict';
    
    Object.defineProperty(exports, '__esModule', { value: true });
    
    function getWindow(node) {
      if (node == null) {
        return window;
      }
    
      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
    
      return node;
    }
    
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    
    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }
    
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    
    var max = Math.max;
    var min = Math.min;
    var round = Math.round;
    
    function getUAString() {
      var uaData = navigator.userAgentData;
    
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function (item) {
          return item.brand + "/" + item.version;
        }).join(' ');
      }
    
      return navigator.userAgent;
    }
    
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
    
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
    
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
    
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
    
      var _ref = isElement(element) ? getWindow(element) : window,
          visualViewport = _ref.visualViewport;
    
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
      };
    }
    
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }
    
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    
    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }
    
    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }
    
    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    
    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }
    
    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;
    
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.
    
    
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
    
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
    
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
    
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
    
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    
    // means it doesn't take into account transforms.
    
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223
    
      var width = element.offsetWidth;
      var height = element.offsetHeight;
    
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
    
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
    
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }
    
    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }
    
      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback
    
      );
    }
    
    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }
    
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
    
      return getScrollParent(getParentNode(node));
    }
    
    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */
    
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
    
      if (list === void 0) {
        list = [];
      }
    
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }
    
    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }
    
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle(element).position === 'fixed') {
        return null;
      }
    
      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block
    
    
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
    
      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle(element);
    
        if (elementCss.position === 'fixed') {
          return null;
        }
      }
    
      var currentNode = getParentNode(element);
    
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
    
      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    
        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
    
      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.
    
    
    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
    
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
    
      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
        return window;
      }
    
      return offsetParent || getContainingBlock(element) || window;
    }
    
    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM
    
    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers
    
    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)
    
    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    
    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively
    
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);
    
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
    
      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }
    
    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase
    
      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    
    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }
    
        return pending;
      };
    }
    
    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
    
      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }
    
    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
        .filter(function (value, index, self) {
          return self.indexOf(value) === index;
        }).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }
    
              break;
    
            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }
    
              break;
    
            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }
    
              break;
    
            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }
    
              break;
    
            case 'effect':
              if (modifier.effect != null && typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }
    
              break;
    
            case 'requires':
              if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }
    
              break;
    
            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }
    
              break;
    
            case 'options':
            case 'data':
              break;
    
            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }
    
          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }
    
    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);
    
        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }
    
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values
    
      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }
    
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;
    
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
    
        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
    
      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }
    
    // of the `<html>` and `<body>` rect bounds if horizontally scrollable
    
    function getDocumentRect(element) {
      var _element$ownerDocumen;
    
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;
    
      if (getComputedStyle(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
    
      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }
    
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    
      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;
    
          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...
    
    
            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false
    
    
      return false;
    }
    
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === 'fixed');
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`
    
    
    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    
      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    
    
      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents
    
    
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    
    function getVariation(placement) {
      return placement.split('-')[1];
    }
    
    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }
    
    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;
    
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;
    
        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;
    
        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;
    
        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;
    
        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }
    
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    
      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';
    
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;
    
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }
    
      return offsets;
    }
    
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    
    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
    
      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$strategy = _options.strategy,
          strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect
    
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    
      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }
    
      return overflowOffsets;
    }
    
    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };
    
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
    
      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }
    
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
    
      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
    
        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties
    
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers
    
            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason
    
            if (process.env.NODE_ENV !== "production") {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);
    
              if (getBasePlacement(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });
    
                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }
    
              var _getComputedStyle = getComputedStyle(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer
    
    
              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }
    
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
    
            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore
    
            if (!areValidElements(reference, popper)) {
              if (process.env.NODE_ENV !== "production") {
                console.error(INVALID_ELEMENT_ERROR);
              }
    
              return;
            } // Store the reference and popper rects to be read by modifiers
    
    
            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect
    
            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`
    
            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;
    
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (process.env.NODE_ENV !== "production") {
                __debug_loops__ += 1;
    
                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }
    
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
    
              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;
    
              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
    
        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }
    
          return instance;
        }
    
        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
    
        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;
    
            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });
    
              var noopFn = function noopFn() {};
    
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
    
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
    
        return instance;
      };
    }
    
    var passive = {
      passive: true
    };
    
    function effect$2(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }
    
      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }
    
      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }
    
        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect$2,
      data: {}
    };
    
    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };
    
    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.
    
    function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x,
          y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }
    
    function mapToStyles(_ref2) {
      var _Object$assign2;
    
      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;
    
      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };
    
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;
    
      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';
    
        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);
    
          if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
    
    
        offsetParent = offsetParent;
    
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
    
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
    
      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);
    
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }, getWindow(popper)) : {
        x: x,
        y: y
      };
    
      x = _ref4.x;
      y = _ref4.y;
    
      if (gpuAcceleration) {
        var _Object$assign;
    
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
    
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }
    
    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    
      if (process.env.NODE_ENV !== "production") {
        var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';
    
        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }
    
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };
    
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }
    
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }
    
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };
    
    // and applies them to the HTMLElements such as popper and arrow
    
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements
    
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
    
    
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];
    
          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }
    
    function effect$1(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
    
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
    
      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
    
          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements
    
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
    
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$1,
      requires: ['computeStyles']
    };
    
    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    
      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];
    
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    
    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;
    
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }
    
      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };
    
    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }
    
    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }
    
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
    
      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });
    
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
    
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    
    
      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }
    
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
    
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    
    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
    
      if (state.modifiersData[name]._skip) {
        return;
      }
    
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];
    
      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];
    
        var _basePlacement = getBasePlacement(placement);
    
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
    
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
    
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
    
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
    
        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
    
        checksMap.set(placement, checks);
      }
    
      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;
    
        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);
    
            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });
    
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
    
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
    
          if (_ret === "break") break;
        }
      }
    
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };
    
    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }
    
    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }
    
    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
    
      if (!popperOffsets) {
        return;
      }
    
      if (checkMainAxis) {
        var _offsetModifierState$;
    
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = offset + overflow[mainSide];
        var max$1 = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
    
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
    
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }
    
      if (checkAltAxis) {
        var _offsetModifierState$2;
    
        var _mainSide = mainAxis === 'x' ? top : left;
    
        var _altSide = mainAxis === 'x' ? bottom : right;
    
        var _offset = popperOffsets[altAxis];
    
        var _len = altAxis === 'y' ? 'height' : 'width';
    
        var _min = _offset + overflow[_mainSide];
    
        var _max = _offset - overflow[_altSide];
    
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
    
      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };
    
    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };
    
    function arrow(_ref) {
      var _state$modifiersData$;
    
      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';
    
      if (!arrowElement || !popperOffsets) {
        return;
      }
    
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds
    
      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...
    
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }
    
    function effect(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;
    
      if (arrowElement == null) {
        return;
      } // CSS selector
    
    
      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);
    
        if (!arrowElement) {
          return;
        }
      }
    
      if (process.env.NODE_ENV !== "production") {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }
    
      if (!contains(state.elements.popper, arrowElement)) {
        if (process.env.NODE_ENV !== "production") {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }
    
        return;
      }
    
      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };
    
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
    
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }
    
    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules
    
    
    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };
    
    var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
    var createPopper$1 = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers$1
    }); // eslint-disable-next-line import/no-unused-modules
    
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules
    
    exports.applyStyles = applyStyles$1;
    exports.arrow = arrow$1;
    exports.computeStyles = computeStyles$1;
    exports.createPopper = createPopper;
    exports.createPopperLite = createPopper$1;
    exports.defaultModifiers = defaultModifiers;
    exports.detectOverflow = detectOverflow;
    exports.eventListeners = eventListeners;
    exports.flip = flip$1;
    exports.hide = hide$1;
    exports.offset = offset$1;
    exports.popperGenerator = popperGenerator;
    exports.popperOffsets = popperOffsets$1;
    exports.preventOverflow = preventOverflow$1;
    
    
    }).call(this)}).call(this,require('_process'))
    },{"_process":36}],2:[function(require,module,exports){
    'use strict';
    
    Object.defineProperty(exports, '__esModule', { value: true });
    
    class RuleError extends Error {
      constructor(cause, ...args) {
        super(cause);
        this.args = args;
      }
    }
    
    const ACCEPTED = "accepted";
    const ALPHA = "alpha";
    const ALPHA_NUM = "alpha-num";
    const ALPHA_NUM_DASH = "alpha-num-dash";
    const BETWEEN_LENGTH = "between-length";
    const BETWEEN_NUMBER = "between-number";
    const DIGITS = "digits";
    const EMAIL = "email";
    const ENDS_WITH = "ends-with";
    const EQUAL_LENGTH = "equal-length";
    const EQUAL_NUMBER = "equal-number";
    const GREATER_EQUAL = "greater-equal";
    const INTEGER = "integer";
    const LESS_EQUAL = "less-equal";
    const MAX_LENGTH = "max-length";
    const MIN_LENGTH = "min-length";
    const NUM_DASH = "num-dash";
    const NUMBER = "number";
    const REGEX = "regex";
    const REQUIRED = "required";
    const STARTS_WITH = "starts-with";
    const WITHIN = "within";
    
    function accepted(value) {
      if (value === "checked") {
        return true;
      }
      return new RuleError(ACCEPTED);
    }
    
    const email$1 = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const integer = /^[+-]?\d+$/;
    const number$1 = /^[+-]?(\d+|\d*\.\d*)$/;
    const alpha$1 = /^[\p{L}\p{M}]+$/u;
    const alphaNum$1 = /^[\p{L}\p{M}\p{N}]+$/u;
    const alphaNumDash$1 = /^[\p{L}\p{M}\p{N}_-]+$/u;
    const numDash$1 = /^[\p{N}_-]+$/u;
    
    function alpha(value) {
      return alpha$1.test(value) || new RuleError(ALPHA);
    }
    
    function alphaNum(value) {
      return alphaNum$1.test(value) || new RuleError(ALPHA_NUM);
    }
    
    function alphaNumDash(value) {
      return alphaNumDash$1.test(value) || new RuleError(ALPHA_NUM_DASH);
    }
    
    class Language {
      set(lang) {
        this.lang = lang;
      }
      get() {
        return typeof this.lang === "object" ? this.lang : {};
      }
    }
    const Language$1 = new Language();
    
    const TYPE_CHECKBOX = "checkbox";
    const TYPE_RADIO = "radio";
    
    function toCamelCase(value) {
      return value.replace(/-./g, (match) => match[1].toUpperCase());
    }
    function getValue(element) {
      if (element instanceof HTMLInputElement) {
        if (element.type === TYPE_CHECKBOX || element.type === TYPE_RADIO) {
          return element.checked ? "checked" : "";
        }
        return element.value;
      }
      if (element instanceof HTMLTextAreaElement) {
        return element.value;
      }
      if (element instanceof HTMLSelectElement) {
        return Array.from(element.selectedOptions).map((option) => option.value).join(",");
      }
      return "";
    }
    function format(message, ...toReplace) {
      return message.replace(/\$(\d)/g, (_, index) => toReplace?.[index - 1] || "");
    }
    function processRule(rule, xRules) {
      let [name, argsText = ""] = rule.split(":");
      if (isXRule(rule)) {
        if (!hasArgument(rule)) {
          throw new Error(`${rule}: x-rules require an argument that is defined in the config.xRules object`);
        }
        name = name.substring(2);
        argsText = String(xRules?.[argsText]) || "";
      }
      return {
        name,
        argsText,
        args: processArgs(argsText)
      };
    }
    function processArgs(args) {
      return args ? args.split(",") : [];
    }
    function lang(key, ...args) {
      const languages = Language$1.get();
      let item = key;
      if (Object.prototype.hasOwnProperty.call(languages, key)) {
        item = languages[key];
      }
      return format(item, ...args);
    }
    function when(condition) {
      return {
        throwError(message) {
          if (condition) {
            throw new Error(message);
          }
        }
      };
    }
    function defaultErrorListeners(events) {
      events.on("field:error", (_parentEl, element, errors) => {
        errors.reverse().forEach((error) => {
          const messageElement = document.createElement("p");
          messageElement.classList.add("validator-err");
          messageElement.innerHTML = error.message;
          if (element.parentNode) {
            element.parentNode.insertBefore(messageElement, element.nextSibling);
          }
        });
      });
      events.on("validation:start", (container) => {
        container.querySelectorAll(".validator-err").forEach((el) => {
          el.remove();
        });
      });
    }
    function hasArgument(rule) {
      return rule.includes(":") && rule.split(":").length === 2;
    }
    function isXRule(rule) {
      return rule.startsWith("x-");
    }
    
    const ARGUMENT_MUST_BE_PROVIDED = "An argument must be provided";
    const ARGUMENT_MUST_BE_A_NUMBER = "The argument must be a number";
    const ARGUMENT_MUST_BE_POSITIVE = "The argument must be a positive number";
    const ARGUMENT_MUST_BE_AN_INTEGER = "The argument must be an integer";
    const INVALID_PATTERN = "Invalid pattern provided";
    
    function between(value, args = "") {
      const [type, minArg, maxArg] = processArgs(args);
      when(!type).throwError(ARGUMENT_MUST_BE_PROVIDED);
      when(!minArg || !maxArg).throwError(ARGUMENT_MUST_BE_PROVIDED);
      const min = Number(minArg);
      const max = Number(maxArg);
      when(Number.isNaN(min) || Number.isNaN(max)).throwError(ARGUMENT_MUST_BE_A_NUMBER);
      when(min > max).throwError("min must be less than max");
      when(min === max).throwError("min and max must not be equal");
      if (type === "number") {
        return betweenForNumber(value, min, max);
      } else {
        return betweenForString(value, min, max);
      }
    }
    function betweenForNumber(value, min, max) {
      const valueInNumber = Number(value);
      if (value !== "" && !Number.isNaN(valueInNumber) && valueInNumber >= min && valueInNumber <= max) {
        return true;
      }
      return new RuleError(BETWEEN_NUMBER, String(min), String(max));
    }
    function betweenForString(value, min, max) {
      when(min < 0 || max < 0).throwError(ARGUMENT_MUST_BE_POSITIVE);
      if (value.length >= min && value.length <= max) {
        return true;
      }
      return new RuleError(BETWEEN_LENGTH, String(min), String(max));
    }
    
    function digits(value, digitLength = "") {
      when(digitLength === "").throwError(ARGUMENT_MUST_BE_PROVIDED);
      when(int(digitLength) !== true || +digitLength < 1).throwError(ARGUMENT_MUST_BE_AN_INTEGER);
      const regex = new RegExp(`^-?[0-9]{${digitLength}}$`);
      return regex.test(value) ? true : new RuleError(DIGITS, digitLength);
    }
    
    function endsWith(value, end = "") {
      when(end === "").throwError(ARGUMENT_MUST_BE_PROVIDED);
      return value.endsWith(end) || new RuleError(ENDS_WITH, end);
    }
    
    function email(value) {
      return email$1.test(value) || new RuleError(EMAIL);
    }
    
    function min(value, args = "") {
      const [type, min2] = processArgs(args);
      when(!type).throwError(ARGUMENT_MUST_BE_PROVIDED);
      when(!min2).throwError(ARGUMENT_MUST_BE_PROVIDED);
      const minInNumber = Number(min2);
      when(Number.isNaN(minInNumber)).throwError(ARGUMENT_MUST_BE_A_NUMBER);
      if (type === "number") {
        return minForNumber(value, minInNumber);
      } else {
        return minForString(value, minInNumber);
      }
    }
    function minForNumber(value, min2) {
      const valueInNumber = Number(value);
      if (value !== "" && !Number.isNaN(valueInNumber) && valueInNumber >= min2) {
        return true;
      }
      return new RuleError(GREATER_EQUAL, String(min2));
    }
    function minForString(value, min2) {
      when(min2 < 0).throwError(ARGUMENT_MUST_BE_POSITIVE);
      if (value.length >= min2) {
        return true;
      }
      return new RuleError(MIN_LENGTH, String(min2));
    }
    
    function int(value) {
      return integer.test(value) || new RuleError(INTEGER);
    }
    
    function max(value, args = "") {
      const [type, max2] = processArgs(args);
      when(!type).throwError(ARGUMENT_MUST_BE_PROVIDED);
      when(!max2).throwError(ARGUMENT_MUST_BE_PROVIDED);
      const maxInNumber = Number(max2);
      when(Number.isNaN(maxInNumber)).throwError(ARGUMENT_MUST_BE_A_NUMBER);
      if (type === "number") {
        return maxForNumber(value, maxInNumber);
      } else {
        return maxForString(value, maxInNumber);
      }
    }
    function maxForNumber(value, max2) {
      const valueInNumber = Number(value);
      if (value !== "" && !Number.isNaN(valueInNumber) && valueInNumber <= max2) {
        return true;
      }
      return new RuleError(LESS_EQUAL, String(max2));
    }
    function maxForString(value, max2) {
      when(max2 < 0).throwError(ARGUMENT_MUST_BE_POSITIVE);
      if (value.length <= max2) {
        return true;
      }
      return new RuleError(MAX_LENGTH, String(max2));
    }
    
    function number(value) {
      return number$1.test(value) || new RuleError(NUMBER);
    }
    
    function numDash(value) {
      return numDash$1.test(value) || new RuleError(NUM_DASH);
    }
    
    const isValidPattern = (pattern) => {
      try {
        new RegExp(pattern);
        return true;
      } catch {
        return false;
      }
    };
    const stringToRegex = (str) => {
      const main = str.match(/\/(.+)\/.*/)?.[1] ?? "";
      const options = str.match(/\/.+\/(.*)/)?.[1] ?? "";
      return new RegExp(main, options);
    };
    function regex(value, pattern) {
      when(!pattern).throwError(ARGUMENT_MUST_BE_PROVIDED);
      when(isValidPattern(pattern) === false).throwError(INVALID_PATTERN);
      const regExp = stringToRegex(pattern);
      return regExp.test(value) || new RuleError(REGEX);
    }
    
    function required(value) {
      return value.trim().length > 0 || new RuleError(REQUIRED);
    }
    
    function requiredIf(value, targetValue = "") {
      const isTargetValueProvided = required(targetValue);
      if (isTargetValueProvided === true) {
        return required(value);
      }
      return true;
    }
    
    function size(value, args = "") {
      const [type, size2] = processArgs(args);
      when(!type).throwError(ARGUMENT_MUST_BE_PROVIDED);
      when(!size2).throwError(ARGUMENT_MUST_BE_PROVIDED);
      const sizeInNumber = Number(size2);
      when(Number.isNaN(sizeInNumber)).throwError(ARGUMENT_MUST_BE_A_NUMBER);
      return type === "number" ? sizeForNumber(value, sizeInNumber) : sizeForString(value, sizeInNumber);
    }
    function sizeForNumber(value, size2) {
      const valueInNumber = Number(value);
      if (value !== "" && !Number.isNaN(valueInNumber) && valueInNumber === size2) {
        return true;
      }
      return new RuleError(EQUAL_NUMBER, String(size2));
    }
    function sizeForString(value, size2) {
      when(size2 < 0).throwError(ARGUMENT_MUST_BE_POSITIVE);
      if (value.length === size2) {
        return true;
      }
      return new RuleError(EQUAL_LENGTH, String(size2));
    }
    
    function startsWith(value, start = "") {
      when(start === "").throwError(ARGUMENT_MUST_BE_PROVIDED);
      return value.startsWith(start) || new RuleError(STARTS_WITH, start);
    }
    
    function within(value, values) {
      const [type, ...list] = processArgs(values);
      when(!type).throwError(ARGUMENT_MUST_BE_PROVIDED);
      if (type === "array") {
        const splittedValue = processArgs(value);
        for (const value2 of splittedValue) {
          if (!list.includes(value2)) {
            return new RuleError(WITHIN);
          }
        }
        return true;
      }
      return list.includes(value) || new RuleError(WITHIN);
    }
    
    const rules = {
      __proto__: null,
      accepted: accepted,
      alpha: alpha,
      alphaNum: alphaNum,
      alphaNumDash: alphaNumDash,
      between: between,
      digits: digits,
      endsWith: endsWith,
      email: email,
      min: min,
      integer: int,
      int: int,
      max: max,
      number: number,
      numDash: numDash,
      regex: regex,
      required: required,
      requiredIf: requiredIf,
      size: size,
      startsWith: startsWith,
      within: within,
      'in': within
    };
    
    class ValidatorError {
      constructor() {
        this.lang = Language$1.get();
        this.errorsList = [];
      }
      setError(element, rule, ruleError) {
        let errors = this.errorsList.find((error) => error[0].element === element);
        if (!errors) {
          errors = [];
          this.errorsList.push(errors);
        }
        const errorMessage = lang(ruleError.message, ...ruleError.args);
        const errorDetail = {
          message: errorMessage,
          element,
          rule,
          cause: ruleError.message,
          args: ruleError.args
        };
        errors.push(errorDetail);
      }
      get hasError() {
        return Object.keys(this.errorsList).length > 0;
      }
      get errors() {
        return this.errorsList;
      }
      clearErrors() {
        this.errorsList = [];
      }
    }
    
    class EventBus {
      constructor(events = {}) {
        this.events = {};
        const keys = Object.keys(events);
        keys.forEach((key) => {
          if (typeof events[key] === "function") {
            this.events[key] = [];
            this.events[key].push(events[key]);
          }
        });
      }
      on(event, callback) {
        if (!this.events[event]) {
          this.events[event] = [];
        }
        const events = this.events[event];
        events.push(callback);
      }
      off(event, callback) {
        if (typeof this.events[event] === "undefined") {
          return;
        }
        const events = this.events[event];
        const index = events.indexOf(callback);
        if (index !== -1) {
          events.splice(index, 1);
        }
      }
      call(event, ...args) {
        if (typeof this.events[event] !== "undefined") {
          const events = this.events[event];
          events.forEach((callback) => {
            callback(...args);
          });
        }
      }
      clear() {
        this.events = {};
      }
    }
    
    const mapMethods = {
      requiredIf: prependTargetValue,
      between: prependType,
      size: prependType,
      min: prependType,
      max: prependType,
      in: prependType
    };
    function adaptRule(rule, rules, field, container, xRules) {
      const ruleName = toCamelCase(processRule(rule, xRules).name);
      return mapMethods[ruleName]?.(rule, rules, field, container, xRules) || rule;
    }
    function prependType(rule, rules, _field, _parentEl, xRules) {
      const { name, argsText } = processRule(rule, xRules);
      const indexOfRule = rules.indexOf(rule);
      const rulesBeforeRule = rules.slice(0, indexOfRule);
      let type = "string";
      if (rulesBeforeRule.includes("number") || rulesBeforeRule.includes("int") || rulesBeforeRule.includes("integer")) {
        type = "number";
      } else if (rulesBeforeRule.includes("array")) {
        type = "array";
      }
      return `${name}:${type},${argsText}`;
    }
    function prependTargetValue(rule, _rules, _field, _parentEl, xRules) {
      const { name, args } = processRule(rule, xRules);
      if (args.length === 0)
        return name;
      let targetValue = "";
      if (args.length > 0) {
        const targetField = document.getElementById(args[0]);
        if (targetField !== null) {
          targetValue = getValue(targetField);
        }
      }
      args.splice(0, 1, targetValue);
      return `${name}:${args.join(",")}`;
    }
    
    const defaultOptions = {
      renderErrors: true,
      onFieldChangeValidationDelay: 500
    };
    class Validator {
      constructor(container, options = {}) {
        if (container === null || !(container instanceof HTMLElement)) {
          throw new Error("Invalid container element");
        }
        this.options = Object.assign(defaultOptions, options);
        this.validatorError = new ValidatorError();
        this.events = new EventBus(this.options.on);
        this.container = container;
        Language$1.set(this.options.lang);
        if (this.options.renderErrors) {
          defaultErrorListeners(this.events);
        }
        this.events.on("validation:start", () => this.validatorError.clearErrors());
        this.events.on("validation:failed", () => this.triggerFieldErrorEvent());
        if (options.onFieldChangeValidation) {
          this.validateOnFieldChange();
        }
      }
      validate(fields, shouldFireResultsEvent = true) {
        this.events.call("validation:start", this.container);
        let isSuccessful = true;
        let status = "success";
        if (fields === void 0) {
          fields = this.container.querySelectorAll("[data-rules]");
        }
        if (fields.length > 0) {
          isSuccessful = this.validateFields(Array.from(fields));
          status = isSuccessful ? "success" : "failed";
        }
        this.events.call("validation:end", this.container, isSuccessful);
        if (shouldFireResultsEvent) {
          this.events.call(`validation:${status}`, this.container);
        }
        return isSuccessful;
      }
      on(event, callback) {
        this.events.on(event, callback);
      }
      off(event, callback) {
        this.events.off(event, callback);
      }
      validateFields(fields) {
        for (const field of fields) {
          const fieldRules = field.getAttribute("data-rules")?.split("|");
          if (fieldRules && fieldRules.length > 0) {
            const value = getValue(field);
            const shouldStopOnFirstFailure = this.shouldStopOnFirstFailure(fieldRules);
            const computedFieldRules = this.getComputedFieldRules(fieldRules, field);
            for (const fieldRule of computedFieldRules) {
              const { name: ruleName, argsText: ruleArgs } = processRule(fieldRule, this.options.xRules);
              const ruleKey = toCamelCase(ruleName);
              if (this.isNullable(ruleKey) && value === "") {
                break;
              }
              if (ruleKey in rules) {
                try {
                  const result = rules[ruleKey](value, ruleArgs);
                  if (result instanceof RuleError) {
                    this.validatorError.setError(field, ruleName, result);
                    if (shouldStopOnFirstFailure) {
                      break;
                    }
                  }
                } catch (error) {
                  console.error(new Error(`${ruleName}: ${error.message}`));
                  return false;
                }
              }
            }
          }
        }
        return !this.validatorError.hasError;
      }
      shouldStopOnFirstFailure(givenRules) {
        return givenRules.includes("bail");
      }
      isNullable(givenRules) {
        return givenRules === "nullable";
      }
      getComputedFieldRules(givenRules, field) {
        return givenRules.map((rule) => adaptRule(rule, givenRules, field, this.container, this.options.xRules));
      }
      triggerFieldErrorEvent() {
        const totalErrors = this.validatorError.errors;
        totalErrors.forEach((fieldErrors) => {
          if (fieldErrors.length === 0)
            return;
          this.events.call("field:error", this.container, fieldErrors[0].element, fieldErrors);
        });
      }
      validateOnFieldChange() {
        let timeout;
        this.container.addEventListener("input", (event) => {
          window.clearTimeout(timeout);
          const delay = this.options.onFieldChangeValidationDelay;
          timeout = window.setTimeout(() => {
            const target = event.target;
            if (target.matches("[data-rules]")) {
              const result = this.validate([target], false);
              if (result === false) {
                this.triggerFieldErrorEvent();
              }
            }
          }, delay);
        });
      }
      setLanguage(lang) {
        Language$1.set(lang);
      }
    }
    const Validator$1 = Validator;
    
    const enLang = {
      [ACCEPTED]: "Please accept this field",
      [ALPHA]: "Please enter only alphabetic characters",
      [ALPHA_NUM]: "Please enter only alpha-numeric characters",
      [ALPHA_NUM_DASH]: "Please enter only alpha-numeric characters, dashes, and underscores",
      [BETWEEN_LENGTH]: "The value must have between $1 and $2 characters",
      [BETWEEN_NUMBER]: "Please enter a number between $1 and $2",
      [DIGITS]: "The value must be a $1-digits number",
      [EMAIL]: "Please enter a valid email address",
      [ENDS_WITH]: 'The value must ends with "$1"',
      [EQUAL_LENGTH]: "The value must have $1 characters",
      [EQUAL_NUMBER]: "The value must be equal to $1",
      [GREATER_EQUAL]: "Please enter a number greater than or equal to $1",
      [INTEGER]: "The value must be a valid integer",
      [LESS_EQUAL]: "Please enter a number less than or equal to $1",
      [MAX_LENGTH]: "Max length is $1",
      [MIN_LENGTH]: "Min length is $1",
      [NUM_DASH]: "Please enter numbers with dashes and underscores",
      [NUMBER]: "Please enter a valid number",
      [REGEX]: "The value doesn't match the pattern",
      [REQUIRED]: "This field is required",
      [STARTS_WITH]: 'The value must start with "$1"',
      [WITHIN]: "The value is incorrect"
    };
    const enLang$1 = enLang;
    
    const faLang = {
      [ACCEPTED]: "\u0644\u0637\u0641\u0627 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0631\u0627 \u062A\u06CC\u06A9 \u0628\u0632\u0646\u06CC\u062F",
      [ALPHA]: "\u0644\u0637\u0641\u0627\u064B \u0641\u0642\u0637 \u062D\u0631\u0648\u0641 \u0627\u0644\u0641\u0628\u0627 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [ALPHA_NUM]: "\u0644\u0637\u0641\u0627\u064B \u0641\u0642\u0637 \u0627\u0639\u062F\u0627\u062F\u060C \u0632\u06CC\u0631 \u062E\u0637 \u0648 \u062E\u0637 \u0641\u0627\u0635\u0644\u0647 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [ALPHA_NUM_DASH]: "\u0644\u0637\u0641\u0627\u064B \u0641\u0642\u0637 \u062D\u0631\u0648\u0641 \u0627\u0644\u0641\u0628\u0627\u060C \u0627\u0639\u062F\u0627\u062F\u060C \u0632\u06CC\u0631 \u062E\u0637 \u0648 \u062E\u0637 \u0641\u0627\u0635\u0644\u0647 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [BETWEEN_LENGTH]: "\u0645\u0642\u062F\u0627\u0631 \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 $1 \u0648 $2 \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F",
      [BETWEEN_NUMBER]: "\u0644\u0637\u0641\u0627 \u06CC\u06A9 \u0639\u062F\u062F \u0628\u06CC\u0646 $1 \u0648 $2 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [DIGITS]: "\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0627\u06CC\u062F $1 \u0631\u0642\u0645 \u0628\u0627\u0634\u062F",
      [EMAIL]: "\u0644\u0637\u0641\u0627 \u06CC\u06A9 \u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [ENDS_WITH]: '\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0627\u06CC\u062F \u0628\u0627 "$1" \u067E\u0627\u06CC\u0627\u0646 \u062F\u0627\u062F\u0647 \u0634\u0648\u062F',
      [EQUAL_LENGTH]: "\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0627\u06CC\u062F $1 \u062D\u0631\u0641 \u0628\u0627\u0634\u062F",
      [EQUAL_NUMBER]: "\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0627\u06CC\u062F $1 \u0628\u0627\u0634\u062F",
      [GREATER_EQUAL]: "\u0644\u0637\u0641\u0627 \u06CC\u06A9 \u0639\u062F\u062F \u0628\u0632\u0631\u06AF\u062A\u0631 \u06CC\u0627 \u0645\u0633\u0627\u0648\u06CC $1 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [INTEGER]: "\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0627\u06CC\u062F \u06CC\u06A9 \u0639\u062F\u062F \u0635\u062D\u06CC\u062D \u0628\u0627\u0634\u062F",
      [LESS_EQUAL]: "\u0644\u0637\u0641\u0627 \u06CC\u06A9 \u0639\u062F\u062F \u06A9\u0648\u0686\u06A9\u062A\u0631 \u06CC\u0627 \u0645\u0633\u0627\u0648\u06CC $1 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [MAX_LENGTH]: "\u062D\u062F\u0627\u06A9\u062B\u0631 \u0637\u0648\u0644 \u0645\u062C\u0627\u0632 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F $1 \u0627\u0633\u062A",
      [MIN_LENGTH]: "\u062D\u062F\u0627\u0642\u0644 \u0637\u0648\u0644 \u0645\u062C\u0627\u0632 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F $1 \u0627\u0633\u062A",
      [REGEX]: "\u0645\u0642\u062F\u0627\u0631 \u0648\u0627\u0631\u062F \u0634\u062F\u0647 \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC \u0645\u0634\u062E\u0635 \u0634\u062F\u0647 \u0647\u0645\u062E\u0648\u0627\u0646\u06CC \u0646\u062F\u0627\u0631\u062F",
      [REQUIRED]: "\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0627\u0644\u0632\u0627\u0645\u06CC \u0627\u0633\u062A",
      [NUM_DASH]: "\u0644\u0637\u0641\u0627\u064B \u0641\u0642\u0637 \u0627\u0639\u062F\u0627\u062F \u0628\u0627 \u0632\u06CC\u0631\u062E\u0637 \u0648 \u062E\u0637 \u0641\u0627\u0635\u0644\u0647 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [NUMBER]: "\u0644\u0637\u0641\u0627 \u06CC\u06A9 \u0639\u062F\u062F \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F",
      [STARTS_WITH]: '\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0627\u06CC\u062F \u0628\u0627 "$1" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F',
      [WITHIN]: "\u0645\u0642\u062F\u0627\u0631 \u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0646\u0627\u062F\u0631\u0633\u062A \u0627\u0633\u062A"
    };
    const faLang$1 = faLang;
    
    const frLang = {
      [ACCEPTED]: "Veuillez accepter ce champ",
      [ALPHA]: "Veuillez saisir uniquement des caract\xE8res alphab\xE9tiques",
      [ALPHA_NUM]: "Veuillez saisir uniquement des caract\xE8res alphanum\xE9riques",
      [ALPHA_NUM_DASH]: "Veuillez saisir uniquement des caract\xE8res alphanum\xE9riques, des tirets et des caract\xE8res de soulignement",
      [BETWEEN_LENGTH]: "La valeur doit comporter entre $1 et $2 caract\xE8res",
      [BETWEEN_NUMBER]: "Veuillez saisir un nombre entre $1 et $2 caract\xE8res",
      [DIGITS]: "La valeur doit \xEAtre un nombre \xE0 $1 chiffre",
      [EMAIL]: "Veuillez saisir une adresse \xE9lectronique valide",
      [ENDS_WITH]: 'La valeur doit se terminer par "$1"',
      [EQUAL_LENGTH]: "La valeur doit avoir des caract\xE8res de $1",
      [EQUAL_NUMBER]: "La valeur doit \xEAtre \xE9gale \xE0 $1",
      [GREATER_EQUAL]: "Veuillez saisir un nombre sup\xE9rieur ou \xE9gal \xE0 $1",
      [INTEGER]: "La valeur doit \xEAtre un nombre entier valide",
      [LESS_EQUAL]: "Veuillez entrer un nombre inf\xE9rieur ou \xE9gal \xE0 $1",
      [MAX_LENGTH]: "La longueur maximale est de $1",
      [MIN_LENGTH]: "La longueur minimale est de $1",
      [NUM_DASH]: "Veuillez saisir les chiffres avec des tirets et des caract\xE8res de soulignement",
      [NUMBER]: "Veuillez entrer un nombre valide",
      [REGEX]: "La valeur ne correspond pas au mod\xE8le",
      [REQUIRED]: "Ce champ est obligatoire",
      [STARTS_WITH]: 'La valeur doit commencer par "$1"',
      [WITHIN]: "La valeur est incorrecte"
    };
    const frLang$1 = frLang;
    
    const deLang = {
      [ACCEPTED]: "Bitte akzeptieren Sie dieses Feld",
      [ALPHA]: "Bitte geben Sie nur alphabetische Zeichen ein",
      [ALPHA_NUM]: "Bitte geben Sie nur alphanumerische Zeichen ein",
      [ALPHA_NUM_DASH]: "Bitte geben Sie nur alphanumerische Zeichen, Bindestriche und Unterstriche ein",
      [BETWEEN_LENGTH]: "Der Wert muss zwischen $1 und $2 Zeichen haben",
      [BETWEEN_NUMBER]: "Bitte geben Sie eine Zahl zwischen $1 und $2 ein",
      [DIGITS]: "Der Wert muss eine $1-stellige Zahl sein",
      [EMAIL]: "Bitte geben Sie eine g\xFCltige E-Mail-Adresse ein",
      [ENDS_WITH]: 'Der Wert muss mit "$1" enden',
      [EQUAL_LENGTH]: "Der Wert muss $1 Zeichen haben",
      [EQUAL_NUMBER]: "Der Wert muss gleich $1 sein",
      [GREATER_EQUAL]: "Bitte geben Sie eine Zahl ein, die gr\xF6\xDFer oder gleich $1 ist",
      [INTEGER]: "Der Wert muss eine g\xFCltige Ganzzahl sein",
      [LESS_EQUAL]: "Bitte geben Sie eine Zahl ein, die kleiner oder gleich $1 ist",
      [MAX_LENGTH]: "Maximale L\xE4nge ist $1",
      [MIN_LENGTH]: "Die Mindestl\xE4nge ist $1",
      [NUM_DASH]: "Bitte geben Sie Zahlen mit Bindestrichen und Unterstrichen ein",
      [NUMBER]: "Bitte geben Sie eine g\xFCltige Zahl ein",
      [REGEX]: "Der Wert stimmt nicht mit dem Muster \xFCberein",
      [REQUIRED]: "Dieses Feld ist erforderlich",
      [STARTS_WITH]: 'Der Wert muss mit "$1" beginnen',
      [WITHIN]: "Der Wert ist falsch"
    };
    const deLang$1 = deLang;
    
    const itLang = {
      [ACCEPTED]: "Si prega di accettare questo campo",
      [ALPHA]: "Inserire solo caratteri alfabetici",
      [ALPHA_NUM]: "Inserire solo caratteri alfanumerici",
      [ALPHA_NUM_DASH]: "Inserire solo caratteri alfanumerici, trattini e trattini bassi",
      [BETWEEN_LENGTH]: "Il valore deve essere compreso tra $1 e $2 caratteri",
      [BETWEEN_NUMBER]: "Inserire un numero compreso tra $1 e $2",
      [DIGITS]: "Il valore deve essere un numero di $1 cifra",
      [EMAIL]: "Inserire un indirizzo e-mail valido",
      [ENDS_WITH]: 'Il valore deve terminare con "$1"',
      [EQUAL_LENGTH]: "Il valore deve avere caratteri da $1",
      [EQUAL_NUMBER]: "Il valore deve essere uguale a $1",
      [GREATER_EQUAL]: "Inserisci un numero maggiore o uguale a $1",
      [INTEGER]: "Il valore deve essere un numero intero valido",
      [LESS_EQUAL]: "Inserire un numero minore o uguale a $1",
      [MAX_LENGTH]: "La lunghezza massima \xE8 $1",
      [MIN_LENGTH]: "La lunghezza minima \xE8 $1",
      [NUM_DASH]: "Inserisci numeri con trattini e trattini bassi",
      [NUMBER]: "Inserire un numero valido",
      [REGEX]: "Il valore non corrisponde al modello",
      [REQUIRED]: "Questo campo \xE8 obbligatorio",
      [STARTS_WITH]: 'Il valore deve iniziare con "$1"',
      [WITHIN]: "Il valore non \xE8 corretto"
    };
    const itLang$1 = itLang;
    
    const zhLang = {
      [ACCEPTED]: "\u8BF7\u63A5\u53D7\u6B64\u5B57\u6BB5",
      [ALPHA]: "\u8BF7\u4EC5\u8F93\u5165\u5B57\u6BCD\u5B57\u7B26",
      [ALPHA_NUM]: "\u8BF7\u4EC5\u8F93\u5165\u5B57\u6BCD\u6570\u5B57\u5B57\u7B26",
      [ALPHA_NUM_DASH]: "\u8BF7\u4EC5\u8F93\u5165\u5B57\u6BCD\u6570\u5B57\u5B57\u7B26\u3001\u7834\u6298\u53F7\u548C\u4E0B\u5212\u7EBF",
      [BETWEEN_LENGTH]: "\u503C\u5FC5\u987B\u4ECB\u4E8E $1 \u548C $2 \u4E4B\u95F4",
      [BETWEEN_NUMBER]: "\u8BF7\u8F93\u5165\u4E00\u4E2A\u4ECB\u4E8E $1 \u548C $2 \u4E4B\u95F4\u7684\u6570\u5B57",
      [DIGITS]: "\u8BE5\u503C\u5FC5\u987B\u662F $1 \u4F4D\u6570",
      [EMAIL]: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u7535\u5B50\u90AE\u4EF6\u5730\u5740",
      [ENDS_WITH]: "\u503C\u5FC5\u987B\u4EE5\u201C$1\u201D\u7ED3\u5C3E",
      [EQUAL_LENGTH]: "\u503C\u5FC5\u987B\u6709 $1 \u4E2A\u5B57\u7B26",
      [EQUAL_NUMBER]: "\u503C\u5FC5\u987B\u7B49\u4E8E $1",
      [GREATER_EQUAL]: "\u8BF7\u8F93\u5165\u4E00\u4E2A\u5927\u4E8E\u6216\u7B49\u4E8E $1 \u7684\u6570\u5B57",
      [INTEGER]: "\u8BE5\u503C\u5FC5\u987B\u662F\u4E00\u4E2A\u6709\u6548\u7684\u6574\u6570",
      [LESS_EQUAL]: "\u8BF7\u8F93\u5165\u4E00\u4E2A\u5C0F\u4E8E\u6216\u7B49\u4E8E $1 \u7684\u6570\u5B57",
      [MAX_LENGTH]: "\u6700\u5927\u957F\u5EA6\u4E3A $1",
      [MIN_LENGTH]: "\u6700\u5C0F\u957F\u5EA6\u4E3A $1",
      [NUM_DASH]: "\u8BF7\u8F93\u5165\u5E26\u7834\u6298\u53F7\u548C\u4E0B\u5212\u7EBF\u7684\u6570\u5B57",
      [NUMBER]: "\u8BF7\u8F93\u5165\u4E00\u4E2A\u6709\u6548\u7684\u6570\u5B57",
      [REGEX]: "\u8BE5\u503C\u4E0E\u6A21\u5F0F\u4E0D\u5339\u914D",
      [REQUIRED]: "\u6B64\u5B57\u6BB5\u662F\u5FC5\u9700\u7684",
      [STARTS_WITH]: "\u503C\u5FC5\u987B\u4EE5\u201C$1\u201D\u5F00\u5934",
      [WITHIN]: "\u503C\u4E0D\u6B63\u786E"
    };
    const zhLang$1 = zhLang;
    
    const csLang = {
      [ACCEPTED]: "P\u0159ijm\u011Bte toto pole",
      [ALPHA]: "Zadejte pouze abecedn\xED znaky",
      [ALPHA_NUM]: "Zadejte pouze alfanumerick\xE9 znaky",
      [ALPHA_NUM_DASH]: "Zadejte pouze alfanumerick\xE9 znaky, poml\u010Dky a podtr\u017E\xEDtka",
      [BETWEEN_LENGTH]: "Hodnota mus\xED m\xEDt $1 a\u017E $2 znak\u016F",
      [BETWEEN_NUMBER]: "Zadejte \u010D\xEDslo od $1 do $2",
      [DIGITS]: "Hodnota mus\xED b\xFDt \u010D\xEDslo s $1 \u010D\xEDslicemi",
      [EMAIL]: "Zadejte platnou emailovou adresu",
      [ENDS_WITH]: "Hodnota mus\xED kon\u010Dit znaky \u201E$1\u201C",
      [EQUAL_LENGTH]: "Hodnota mus\xED m\xEDt $1 znak\u016F",
      [EQUAL_NUMBER]: "Hodnota mus\xED b\xFDt rovna $1",
      [GREATER_EQUAL]: "Zadejte \u010D\xEDslo v\u011Bt\u0161\xED nebo rovn\xE9 $1",
      [INTEGER]: "Hodnota mus\xED b\xFDt platn\xE9 cel\xE9 \u010D\xEDslo",
      [LESS_EQUAL]: "Zadejte \u010D\xEDslo men\u0161\xED nebo rovn\xE9 $1",
      [MAX_LENGTH]: "Maxim\xE1ln\xED d\xE9lka je $1",
      [MIN_LENGTH]: "Minim\xE1ln\xED d\xE9lka je $1",
      [NUM_DASH]: "Zadejte \u010D\xEDsla s poml\u010Dkami a podtr\u017E\xEDtky",
      [NUMBER]: "Zadejte platn\xE9 \u010D\xEDslo",
      [REGEX]: "Hodnota neodpov\xEDd\xE1 vzoru",
      [REQUIRED]: "Toto pole je povinn\xE9",
      [STARTS_WITH]: "Hodnota mus\xED za\u010D\xEDnat znaky \u201E$1\u201C",
      [WITHIN]: "Hodnota je nespr\xE1vn\xE1"
    };
    const csLang$1 = csLang;
    
    const nlLang = {
      [ACCEPTED]: "Accepteer dit veld a.u.b.",
      [ALPHA]: "Voer alleen alfabetische tekens in",
      [ALPHA_NUM]: "Alleen alfanumerieke tekens a.u.b",
      [ALPHA_NUM_DASH]: "Voer alleen alfanumerieke tekens, streepjes en underscores in",
      [BETWEEN_LENGTH]: "De waarde moet tussen $1 en $2 tekens liggen",
      [BETWEEN_NUMBER]: "Voer een getal tussen $1 en $2 in",
      [DIGITS]: "De waarde moet een getal van 1 cijfer zijn.",
      [EMAIL]: "Voer een geldig e-mailadres in",
      [ENDS_WITH]: 'De waarde moet eindigen op "$1"',
      [EQUAL_LENGTH]: "De waarde moet uit $1 tekens bestaan",
      [EQUAL_NUMBER]: "De waarde moet gelijk zijn aan $1",
      [GREATER_EQUAL]: "Voer a.u.b. een getal in groter dan of gelijk aan $1",
      [INTEGER]: "De waarde moet een geldig geheel getal zijn",
      [LESS_EQUAL]: "Voer a.u.b. een getal in kleiner dan of gelijk aan $1",
      [MAX_LENGTH]: "Max. lengte is $1",
      [MIN_LENGTH]: "Min. lengte is $1",
      [NUM_DASH]: "Voer getallen met streepjes en underscores in.",
      [NUMBER]: "Voer een geldig getal in",
      [REGEX]: "De waarde komt niet overeen met het patroon",
      [REQUIRED]: "Dit veld is verplicht",
      [STARTS_WITH]: 'De waarde moet beginnen met "$1"',
      [WITHIN]: "De waarde is onjuist"
    };
    const nlLang$1 = nlLang;
    
    const createLang = (lang) => lang;
    
    exports.Validator = Validator$1;
    exports.createLang = createLang;
    exports.csLang = csLang$1;
    exports.deLang = deLang$1;
    exports.enLang = enLang$1;
    exports.faLang = faLang$1;
    exports.frLang = frLang$1;
    exports.itLang = itLang$1;
    exports.nlLang = nlLang$1;
    exports.zhLang = zhLang$1;
    
    },{}],3:[function(require,module,exports){
    /*!
      * Bootstrap v5.2.3 (https://getbootstrap.com/)
      * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
      * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
      */
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core')) :
      typeof define === 'function' && define.amd ? define(['@popperjs/core'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bootstrap = factory(global.Popper));
    })(this, (function (Popper) { 'use strict';
    
      function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
        if (e) {
          for (const k in e) {
            if (k !== 'default') {
              const d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: () => e[k]
              });
            }
          }
        }
        n.default = e;
        return Object.freeze(n);
      }
    
      const Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/index.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      const MAX_UID = 1000000;
      const MILLISECONDS_MULTIPLIER = 1000;
      const TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)
    
      const toType = object => {
        if (object === null || object === undefined) {
          return `${object}`;
        }
    
        return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
      };
      /**
       * Public Util API
       */
    
    
      const getUID = prefix => {
        do {
          prefix += Math.floor(Math.random() * MAX_UID);
        } while (document.getElementById(prefix));
    
        return prefix;
      };
    
      const getSelector = element => {
        let selector = element.getAttribute('data-bs-target');
    
        if (!selector || selector === '#') {
          let hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
          // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
          // `document.querySelector` will rightfully complain it is invalid.
          // See https://github.com/twbs/bootstrap/issues/32273
    
          if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
            return null;
          } // Just in case some CMS puts out a full URL with the anchor appended
    
    
          if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
            hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
          }
    
          selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
        }
    
        return selector;
      };
    
      const getSelectorFromElement = element => {
        const selector = getSelector(element);
    
        if (selector) {
          return document.querySelector(selector) ? selector : null;
        }
    
        return null;
      };
    
      const getElementFromSelector = element => {
        const selector = getSelector(element);
        return selector ? document.querySelector(selector) : null;
      };
    
      const getTransitionDurationFromElement = element => {
        if (!element) {
          return 0;
        } // Get transition-duration of the element
    
    
        let {
          transitionDuration,
          transitionDelay
        } = window.getComputedStyle(element);
        const floatTransitionDuration = Number.parseFloat(transitionDuration);
        const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found
    
        if (!floatTransitionDuration && !floatTransitionDelay) {
          return 0;
        } // If multiple durations are defined, take the first
    
    
        transitionDuration = transitionDuration.split(',')[0];
        transitionDelay = transitionDelay.split(',')[0];
        return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
      };
    
      const triggerTransitionEnd = element => {
        element.dispatchEvent(new Event(TRANSITION_END));
      };
    
      const isElement = object => {
        if (!object || typeof object !== 'object') {
          return false;
        }
    
        if (typeof object.jquery !== 'undefined') {
          object = object[0];
        }
    
        return typeof object.nodeType !== 'undefined';
      };
    
      const getElement = object => {
        // it's a jQuery object or a node element
        if (isElement(object)) {
          return object.jquery ? object[0] : object;
        }
    
        if (typeof object === 'string' && object.length > 0) {
          return document.querySelector(object);
        }
    
        return null;
      };
    
      const isVisible = element => {
        if (!isElement(element) || element.getClientRects().length === 0) {
          return false;
        }
    
        const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed
    
        const closedDetails = element.closest('details:not([open])');
    
        if (!closedDetails) {
          return elementIsVisible;
        }
    
        if (closedDetails !== element) {
          const summary = element.closest('summary');
    
          if (summary && summary.parentNode !== closedDetails) {
            return false;
          }
    
          if (summary === null) {
            return false;
          }
        }
    
        return elementIsVisible;
      };
    
      const isDisabled = element => {
        if (!element || element.nodeType !== Node.ELEMENT_NODE) {
          return true;
        }
    
        if (element.classList.contains('disabled')) {
          return true;
        }
    
        if (typeof element.disabled !== 'undefined') {
          return element.disabled;
        }
    
        return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
      };
    
      const findShadowRoot = element => {
        if (!document.documentElement.attachShadow) {
          return null;
        } // Can find the shadow root otherwise it'll return the document
    
    
        if (typeof element.getRootNode === 'function') {
          const root = element.getRootNode();
          return root instanceof ShadowRoot ? root : null;
        }
    
        if (element instanceof ShadowRoot) {
          return element;
        } // when we don't find a shadow root
    
    
        if (!element.parentNode) {
          return null;
        }
    
        return findShadowRoot(element.parentNode);
      };
    
      const noop = () => {};
      /**
       * Trick to restart an element's animation
       *
       * @param {HTMLElement} element
       * @return void
       *
       * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
       */
    
    
      const reflow = element => {
        element.offsetHeight; // eslint-disable-line no-unused-expressions
      };
    
      const getjQuery = () => {
        if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
          return window.jQuery;
        }
    
        return null;
      };
    
      const DOMContentLoadedCallbacks = [];
    
      const onDOMContentLoaded = callback => {
        if (document.readyState === 'loading') {
          // add listener on the first call when the document is in loading state
          if (!DOMContentLoadedCallbacks.length) {
            document.addEventListener('DOMContentLoaded', () => {
              for (const callback of DOMContentLoadedCallbacks) {
                callback();
              }
            });
          }
    
          DOMContentLoadedCallbacks.push(callback);
        } else {
          callback();
        }
      };
    
      const isRTL = () => document.documentElement.dir === 'rtl';
    
      const defineJQueryPlugin = plugin => {
        onDOMContentLoaded(() => {
          const $ = getjQuery();
          /* istanbul ignore if */
    
          if ($) {
            const name = plugin.NAME;
            const JQUERY_NO_CONFLICT = $.fn[name];
            $.fn[name] = plugin.jQueryInterface;
            $.fn[name].Constructor = plugin;
    
            $.fn[name].noConflict = () => {
              $.fn[name] = JQUERY_NO_CONFLICT;
              return plugin.jQueryInterface;
            };
          }
        });
      };
    
      const execute = callback => {
        if (typeof callback === 'function') {
          callback();
        }
      };
    
      const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
        if (!waitForTransition) {
          execute(callback);
          return;
        }
    
        const durationPadding = 5;
        const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
        let called = false;
    
        const handler = ({
          target
        }) => {
          if (target !== transitionElement) {
            return;
          }
    
          called = true;
          transitionElement.removeEventListener(TRANSITION_END, handler);
          execute(callback);
        };
    
        transitionElement.addEventListener(TRANSITION_END, handler);
        setTimeout(() => {
          if (!called) {
            triggerTransitionEnd(transitionElement);
          }
        }, emulatedDuration);
      };
      /**
       * Return the previous/next element of a list.
       *
       * @param {array} list    The list of elements
       * @param activeElement   The active element
       * @param shouldGetNext   Choose to get next or previous element
       * @param isCycleAllowed
       * @return {Element|elem} The proper element
       */
    
    
      const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
        const listLength = list.length;
        let index = list.indexOf(activeElement); // if the element does not exist in the list return an element
        // depending on the direction and if cycle is allowed
    
        if (index === -1) {
          return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
        }
    
        index += shouldGetNext ? 1 : -1;
    
        if (isCycleAllowed) {
          index = (index + listLength) % listLength;
        }
    
        return list[Math.max(0, Math.min(index, listLength - 1))];
      };
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): dom/event-handler.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
      const stripNameRegex = /\..*/;
      const stripUidRegex = /::\d+$/;
      const eventRegistry = {}; // Events storage
    
      let uidEvent = 1;
      const customEvents = {
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
      };
      const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
      /**
       * Private methods
       */
    
      function makeEventUid(element, uid) {
        return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
      }
    
      function getElementEvents(element) {
        const uid = makeEventUid(element);
        element.uidEvent = uid;
        eventRegistry[uid] = eventRegistry[uid] || {};
        return eventRegistry[uid];
      }
    
      function bootstrapHandler(element, fn) {
        return function handler(event) {
          hydrateObj(event, {
            delegateTarget: element
          });
    
          if (handler.oneOff) {
            EventHandler.off(element, event.type, fn);
          }
    
          return fn.apply(element, [event]);
        };
      }
    
      function bootstrapDelegationHandler(element, selector, fn) {
        return function handler(event) {
          const domElements = element.querySelectorAll(selector);
    
          for (let {
            target
          } = event; target && target !== this; target = target.parentNode) {
            for (const domElement of domElements) {
              if (domElement !== target) {
                continue;
              }
    
              hydrateObj(event, {
                delegateTarget: target
              });
    
              if (handler.oneOff) {
                EventHandler.off(element, event.type, selector, fn);
              }
    
              return fn.apply(target, [event]);
            }
          }
        };
      }
    
      function findHandler(events, callable, delegationSelector = null) {
        return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
      }
    
      function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
        const isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check
    
        const callable = isDelegated ? delegationFunction : handler || delegationFunction;
        let typeEvent = getTypeEvent(originalTypeEvent);
    
        if (!nativeEvents.has(typeEvent)) {
          typeEvent = originalTypeEvent;
        }
    
        return [isDelegated, callable, typeEvent];
      }
    
      function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
        if (typeof originalTypeEvent !== 'string' || !element) {
          return;
        }
    
        let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction); // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
        // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    
        if (originalTypeEvent in customEvents) {
          const wrapFunction = fn => {
            return function (event) {
              if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
                return fn.call(this, event);
              }
            };
          };
    
          callable = wrapFunction(callable);
        }
    
        const events = getElementEvents(element);
        const handlers = events[typeEvent] || (events[typeEvent] = {});
        const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    
        if (previousFunction) {
          previousFunction.oneOff = previousFunction.oneOff && oneOff;
          return;
        }
    
        const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
        const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
        fn.delegationSelector = isDelegated ? handler : null;
        fn.callable = callable;
        fn.oneOff = oneOff;
        fn.uidEvent = uid;
        handlers[uid] = fn;
        element.addEventListener(typeEvent, fn, isDelegated);
      }
    
      function removeHandler(element, events, typeEvent, handler, delegationSelector) {
        const fn = findHandler(events[typeEvent], handler, delegationSelector);
    
        if (!fn) {
          return;
        }
    
        element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
        delete events[typeEvent][fn.uidEvent];
      }
    
      function removeNamespacedHandlers(element, events, typeEvent, namespace) {
        const storeElementEvent = events[typeEvent] || {};
    
        for (const handlerKey of Object.keys(storeElementEvent)) {
          if (handlerKey.includes(namespace)) {
            const event = storeElementEvent[handlerKey];
            removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
          }
        }
      }
    
      function getTypeEvent(event) {
        // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
        event = event.replace(stripNameRegex, '');
        return customEvents[event] || event;
      }
    
      const EventHandler = {
        on(element, event, handler, delegationFunction) {
          addHandler(element, event, handler, delegationFunction, false);
        },
    
        one(element, event, handler, delegationFunction) {
          addHandler(element, event, handler, delegationFunction, true);
        },
    
        off(element, originalTypeEvent, handler, delegationFunction) {
          if (typeof originalTypeEvent !== 'string' || !element) {
            return;
          }
    
          const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
          const inNamespace = typeEvent !== originalTypeEvent;
          const events = getElementEvents(element);
          const storeElementEvent = events[typeEvent] || {};
          const isNamespace = originalTypeEvent.startsWith('.');
    
          if (typeof callable !== 'undefined') {
            // Simplest case: handler is passed, remove that listener ONLY.
            if (!Object.keys(storeElementEvent).length) {
              return;
            }
    
            removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
            return;
          }
    
          if (isNamespace) {
            for (const elementEvent of Object.keys(events)) {
              removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
            }
          }
    
          for (const keyHandlers of Object.keys(storeElementEvent)) {
            const handlerKey = keyHandlers.replace(stripUidRegex, '');
    
            if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
              const event = storeElementEvent[keyHandlers];
              removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
            }
          }
        },
    
        trigger(element, event, args) {
          if (typeof event !== 'string' || !element) {
            return null;
          }
    
          const $ = getjQuery();
          const typeEvent = getTypeEvent(event);
          const inNamespace = event !== typeEvent;
          let jQueryEvent = null;
          let bubbles = true;
          let nativeDispatch = true;
          let defaultPrevented = false;
    
          if (inNamespace && $) {
            jQueryEvent = $.Event(event, args);
            $(element).trigger(jQueryEvent);
            bubbles = !jQueryEvent.isPropagationStopped();
            nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
            defaultPrevented = jQueryEvent.isDefaultPrevented();
          }
    
          let evt = new Event(event, {
            bubbles,
            cancelable: true
          });
          evt = hydrateObj(evt, args);
    
          if (defaultPrevented) {
            evt.preventDefault();
          }
    
          if (nativeDispatch) {
            element.dispatchEvent(evt);
          }
    
          if (evt.defaultPrevented && jQueryEvent) {
            jQueryEvent.preventDefault();
          }
    
          return evt;
        }
    
      };
    
      function hydrateObj(obj, meta) {
        for (const [key, value] of Object.entries(meta || {})) {
          try {
            obj[key] = value;
          } catch (_unused) {
            Object.defineProperty(obj, key, {
              configurable: true,
    
              get() {
                return value;
              }
    
            });
          }
        }
    
        return obj;
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): dom/data.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
    
      /**
       * Constants
       */
      const elementMap = new Map();
      const Data = {
        set(element, key, instance) {
          if (!elementMap.has(element)) {
            elementMap.set(element, new Map());
          }
    
          const instanceMap = elementMap.get(element); // make it clear we only want one instance per element
          // can be removed later when multiple key/instances are fine to be used
    
          if (!instanceMap.has(key) && instanceMap.size !== 0) {
            // eslint-disable-next-line no-console
            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
            return;
          }
    
          instanceMap.set(key, instance);
        },
    
        get(element, key) {
          if (elementMap.has(element)) {
            return elementMap.get(element).get(key) || null;
          }
    
          return null;
        },
    
        remove(element, key) {
          if (!elementMap.has(element)) {
            return;
          }
    
          const instanceMap = elementMap.get(element);
          instanceMap.delete(key); // free up element references if there are no instances left for an element
    
          if (instanceMap.size === 0) {
            elementMap.delete(element);
          }
        }
    
      };
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): dom/manipulator.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      function normalizeData(value) {
        if (value === 'true') {
          return true;
        }
    
        if (value === 'false') {
          return false;
        }
    
        if (value === Number(value).toString()) {
          return Number(value);
        }
    
        if (value === '' || value === 'null') {
          return null;
        }
    
        if (typeof value !== 'string') {
          return value;
        }
    
        try {
          return JSON.parse(decodeURIComponent(value));
        } catch (_unused) {
          return value;
        }
      }
    
      function normalizeDataKey(key) {
        return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
      }
    
      const Manipulator = {
        setDataAttribute(element, key, value) {
          element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
        },
    
        removeDataAttribute(element, key) {
          element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
        },
    
        getDataAttributes(element) {
          if (!element) {
            return {};
          }
    
          const attributes = {};
          const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
    
          for (const key of bsKeys) {
            let pureKey = key.replace(/^bs/, '');
            pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
            attributes[pureKey] = normalizeData(element.dataset[key]);
          }
    
          return attributes;
        },
    
        getDataAttribute(element, key) {
          return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
        }
    
      };
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/config.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Class definition
       */
    
      class Config {
        // Getters
        static get Default() {
          return {};
        }
    
        static get DefaultType() {
          return {};
        }
    
        static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!');
        }
    
        _getConfig(config) {
          config = this._mergeConfigObj(config);
          config = this._configAfterMerge(config);
    
          this._typeCheckConfig(config);
    
          return config;
        }
    
        _configAfterMerge(config) {
          return config;
        }
    
        _mergeConfigObj(config, element) {
          const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse
    
          return { ...this.constructor.Default,
            ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
            ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),
            ...(typeof config === 'object' ? config : {})
          };
        }
    
        _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
          for (const property of Object.keys(configTypes)) {
            const expectedTypes = configTypes[property];
            const value = config[property];
            const valueType = isElement(value) ? 'element' : toType(value);
    
            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
            }
          }
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): base-component.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const VERSION = '5.2.3';
      /**
       * Class definition
       */
    
      class BaseComponent extends Config {
        constructor(element, config) {
          super();
          element = getElement(element);
    
          if (!element) {
            return;
          }
    
          this._element = element;
          this._config = this._getConfig(config);
          Data.set(this._element, this.constructor.DATA_KEY, this);
        } // Public
    
    
        dispose() {
          Data.remove(this._element, this.constructor.DATA_KEY);
          EventHandler.off(this._element, this.constructor.EVENT_KEY);
    
          for (const propertyName of Object.getOwnPropertyNames(this)) {
            this[propertyName] = null;
          }
        }
    
        _queueCallback(callback, element, isAnimated = true) {
          executeAfterTransition(callback, element, isAnimated);
        }
    
        _getConfig(config) {
          config = this._mergeConfigObj(config, this._element);
          config = this._configAfterMerge(config);
    
          this._typeCheckConfig(config);
    
          return config;
        } // Static
    
    
        static getInstance(element) {
          return Data.get(getElement(element), this.DATA_KEY);
        }
    
        static getOrCreateInstance(element, config = {}) {
          return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
        }
    
        static get VERSION() {
          return VERSION;
        }
    
        static get DATA_KEY() {
          return `bs.${this.NAME}`;
        }
    
        static get EVENT_KEY() {
          return `.${this.DATA_KEY}`;
        }
    
        static eventName(name) {
          return `${name}${this.EVENT_KEY}`;
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/component-functions.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
    
      const enableDismissTrigger = (component, method = 'hide') => {
        const clickEvent = `click.dismiss${component.EVENT_KEY}`;
        const name = component.NAME;
        EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
          if (['A', 'AREA'].includes(this.tagName)) {
            event.preventDefault();
          }
    
          if (isDisabled(this)) {
            return;
          }
    
          const target = getElementFromSelector(this) || this.closest(`.${name}`);
          const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
    
          instance[method]();
        });
      };
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): alert.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$f = 'alert';
      const DATA_KEY$a = 'bs.alert';
      const EVENT_KEY$b = `.${DATA_KEY$a}`;
      const EVENT_CLOSE = `close${EVENT_KEY$b}`;
      const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
      const CLASS_NAME_FADE$5 = 'fade';
      const CLASS_NAME_SHOW$8 = 'show';
      /**
       * Class definition
       */
    
      class Alert extends BaseComponent {
        // Getters
        static get NAME() {
          return NAME$f;
        } // Public
    
    
        close() {
          const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    
          if (closeEvent.defaultPrevented) {
            return;
          }
    
          this._element.classList.remove(CLASS_NAME_SHOW$8);
    
          const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    
          this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
        } // Private
    
    
        _destroyElement() {
          this._element.remove();
    
          EventHandler.trigger(this._element, EVENT_CLOSED);
          this.dispose();
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Alert.getOrCreateInstance(this);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config](this);
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      enableDismissTrigger(Alert, 'close');
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Alert);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): button.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$e = 'button';
      const DATA_KEY$9 = 'bs.button';
      const EVENT_KEY$a = `.${DATA_KEY$9}`;
      const DATA_API_KEY$6 = '.data-api';
      const CLASS_NAME_ACTIVE$3 = 'active';
      const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
      const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
      /**
       * Class definition
       */
    
      class Button extends BaseComponent {
        // Getters
        static get NAME() {
          return NAME$e;
        } // Public
    
    
        toggle() {
          // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
          this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Button.getOrCreateInstance(this);
    
            if (config === 'toggle') {
              data[config]();
            }
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
        event.preventDefault();
        const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
        const data = Button.getOrCreateInstance(button);
        data.toggle();
      });
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Button);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): dom/selector-engine.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const SelectorEngine = {
        find(selector, element = document.documentElement) {
          return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
        },
    
        findOne(selector, element = document.documentElement) {
          return Element.prototype.querySelector.call(element, selector);
        },
    
        children(element, selector) {
          return [].concat(...element.children).filter(child => child.matches(selector));
        },
    
        parents(element, selector) {
          const parents = [];
          let ancestor = element.parentNode.closest(selector);
    
          while (ancestor) {
            parents.push(ancestor);
            ancestor = ancestor.parentNode.closest(selector);
          }
    
          return parents;
        },
    
        prev(element, selector) {
          let previous = element.previousElementSibling;
    
          while (previous) {
            if (previous.matches(selector)) {
              return [previous];
            }
    
            previous = previous.previousElementSibling;
          }
    
          return [];
        },
    
        // TODO: this is now unused; remove later along with prev()
        next(element, selector) {
          let next = element.nextElementSibling;
    
          while (next) {
            if (next.matches(selector)) {
              return [next];
            }
    
            next = next.nextElementSibling;
          }
    
          return [];
        },
    
        focusableChildren(element) {
          const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
          return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
        }
    
      };
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/swipe.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$d = 'swipe';
      const EVENT_KEY$9 = '.bs.swipe';
      const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
      const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
      const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
      const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
      const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
      const POINTER_TYPE_TOUCH = 'touch';
      const POINTER_TYPE_PEN = 'pen';
      const CLASS_NAME_POINTER_EVENT = 'pointer-event';
      const SWIPE_THRESHOLD = 40;
      const Default$c = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
      };
      const DefaultType$c = {
        endCallback: '(function|null)',
        leftCallback: '(function|null)',
        rightCallback: '(function|null)'
      };
      /**
       * Class definition
       */
    
      class Swipe extends Config {
        constructor(element, config) {
          super();
          this._element = element;
    
          if (!element || !Swipe.isSupported()) {
            return;
          }
    
          this._config = this._getConfig(config);
          this._deltaX = 0;
          this._supportPointerEvents = Boolean(window.PointerEvent);
    
          this._initEvents();
        } // Getters
    
    
        static get Default() {
          return Default$c;
        }
    
        static get DefaultType() {
          return DefaultType$c;
        }
    
        static get NAME() {
          return NAME$d;
        } // Public
    
    
        dispose() {
          EventHandler.off(this._element, EVENT_KEY$9);
        } // Private
    
    
        _start(event) {
          if (!this._supportPointerEvents) {
            this._deltaX = event.touches[0].clientX;
            return;
          }
    
          if (this._eventIsPointerPenTouch(event)) {
            this._deltaX = event.clientX;
          }
        }
    
        _end(event) {
          if (this._eventIsPointerPenTouch(event)) {
            this._deltaX = event.clientX - this._deltaX;
          }
    
          this._handleSwipe();
    
          execute(this._config.endCallback);
        }
    
        _move(event) {
          this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
        }
    
        _handleSwipe() {
          const absDeltaX = Math.abs(this._deltaX);
    
          if (absDeltaX <= SWIPE_THRESHOLD) {
            return;
          }
    
          const direction = absDeltaX / this._deltaX;
          this._deltaX = 0;
    
          if (!direction) {
            return;
          }
    
          execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
        }
    
        _initEvents() {
          if (this._supportPointerEvents) {
            EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
            EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));
    
            this._element.classList.add(CLASS_NAME_POINTER_EVENT);
          } else {
            EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
            EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
            EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));
          }
        }
    
        _eventIsPointerPenTouch(event) {
          return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
        } // Static
    
    
        static isSupported() {
          return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): carousel.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$c = 'carousel';
      const DATA_KEY$8 = 'bs.carousel';
      const EVENT_KEY$8 = `.${DATA_KEY$8}`;
      const DATA_API_KEY$5 = '.data-api';
      const ARROW_LEFT_KEY$1 = 'ArrowLeft';
      const ARROW_RIGHT_KEY$1 = 'ArrowRight';
      const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
    
      const ORDER_NEXT = 'next';
      const ORDER_PREV = 'prev';
      const DIRECTION_LEFT = 'left';
      const DIRECTION_RIGHT = 'right';
      const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
      const EVENT_SLID = `slid${EVENT_KEY$8}`;
      const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
      const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
      const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
      const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
      const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
      const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
      const CLASS_NAME_CAROUSEL = 'carousel';
      const CLASS_NAME_ACTIVE$2 = 'active';
      const CLASS_NAME_SLIDE = 'slide';
      const CLASS_NAME_END = 'carousel-item-end';
      const CLASS_NAME_START = 'carousel-item-start';
      const CLASS_NAME_NEXT = 'carousel-item-next';
      const CLASS_NAME_PREV = 'carousel-item-prev';
      const SELECTOR_ACTIVE = '.active';
      const SELECTOR_ITEM = '.carousel-item';
      const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
      const SELECTOR_ITEM_IMG = '.carousel-item img';
      const SELECTOR_INDICATORS = '.carousel-indicators';
      const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
      const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
      const KEY_TO_DIRECTION = {
        [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
        [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
      };
      const Default$b = {
        interval: 5000,
        keyboard: true,
        pause: 'hover',
        ride: false,
        touch: true,
        wrap: true
      };
      const DefaultType$b = {
        interval: '(number|boolean)',
        // TODO:v6 remove boolean support
        keyboard: 'boolean',
        pause: '(string|boolean)',
        ride: '(boolean|string)',
        touch: 'boolean',
        wrap: 'boolean'
      };
      /**
       * Class definition
       */
    
      class Carousel extends BaseComponent {
        constructor(element, config) {
          super(element, config);
          this._interval = null;
          this._activeElement = null;
          this._isSliding = false;
          this.touchTimeout = null;
          this._swipeHelper = null;
          this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    
          this._addEventListeners();
    
          if (this._config.ride === CLASS_NAME_CAROUSEL) {
            this.cycle();
          }
        } // Getters
    
    
        static get Default() {
          return Default$b;
        }
    
        static get DefaultType() {
          return DefaultType$b;
        }
    
        static get NAME() {
          return NAME$c;
        } // Public
    
    
        next() {
          this._slide(ORDER_NEXT);
        }
    
        nextWhenVisible() {
          // FIXME TODO use `document.visibilityState`
          // Don't call next when the page isn't visible
          // or the carousel or its parent isn't visible
          if (!document.hidden && isVisible(this._element)) {
            this.next();
          }
        }
    
        prev() {
          this._slide(ORDER_PREV);
        }
    
        pause() {
          if (this._isSliding) {
            triggerTransitionEnd(this._element);
          }
    
          this._clearInterval();
        }
    
        cycle() {
          this._clearInterval();
    
          this._updateInterval();
    
          this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
        }
    
        _maybeEnableCycle() {
          if (!this._config.ride) {
            return;
          }
    
          if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
            return;
          }
    
          this.cycle();
        }
    
        to(index) {
          const items = this._getItems();
    
          if (index > items.length - 1 || index < 0) {
            return;
          }
    
          if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
            return;
          }
    
          const activeIndex = this._getItemIndex(this._getActive());
    
          if (activeIndex === index) {
            return;
          }
    
          const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    
          this._slide(order, items[index]);
        }
    
        dispose() {
          if (this._swipeHelper) {
            this._swipeHelper.dispose();
          }
    
          super.dispose();
        } // Private
    
    
        _configAfterMerge(config) {
          config.defaultInterval = config.interval;
          return config;
        }
    
        _addEventListeners() {
          if (this._config.keyboard) {
            EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));
          }
    
          if (this._config.pause === 'hover') {
            EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
            EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
          }
    
          if (this._config.touch && Swipe.isSupported()) {
            this._addTouchEventListeners();
          }
        }
    
        _addTouchEventListeners() {
          for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
            EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());
          }
    
          const endCallBack = () => {
            if (this._config.pause !== 'hover') {
              return;
            } // If it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
    
    
            this.pause();
    
            if (this.touchTimeout) {
              clearTimeout(this.touchTimeout);
            }
    
            this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
          };
    
          const swipeConfig = {
            leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
            rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
            endCallback: endCallBack
          };
          this._swipeHelper = new Swipe(this._element, swipeConfig);
        }
    
        _keydown(event) {
          if (/input|textarea/i.test(event.target.tagName)) {
            return;
          }
    
          const direction = KEY_TO_DIRECTION[event.key];
    
          if (direction) {
            event.preventDefault();
    
            this._slide(this._directionToOrder(direction));
          }
        }
    
        _getItemIndex(element) {
          return this._getItems().indexOf(element);
        }
    
        _setActiveIndicatorElement(index) {
          if (!this._indicatorsElement) {
            return;
          }
    
          const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
          activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
          activeIndicator.removeAttribute('aria-current');
          const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    
          if (newActiveIndicator) {
            newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
            newActiveIndicator.setAttribute('aria-current', 'true');
          }
        }
    
        _updateInterval() {
          const element = this._activeElement || this._getActive();
    
          if (!element) {
            return;
          }
    
          const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
          this._config.interval = elementInterval || this._config.defaultInterval;
        }
    
        _slide(order, element = null) {
          if (this._isSliding) {
            return;
          }
    
          const activeElement = this._getActive();
    
          const isNext = order === ORDER_NEXT;
          const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    
          if (nextElement === activeElement) {
            return;
          }
    
          const nextElementIndex = this._getItemIndex(nextElement);
    
          const triggerEvent = eventName => {
            return EventHandler.trigger(this._element, eventName, {
              relatedTarget: nextElement,
              direction: this._orderToDirection(order),
              from: this._getItemIndex(activeElement),
              to: nextElementIndex
            });
          };
    
          const slideEvent = triggerEvent(EVENT_SLIDE);
    
          if (slideEvent.defaultPrevented) {
            return;
          }
    
          if (!activeElement || !nextElement) {
            // Some weirdness is happening, so we bail
            // todo: change tests that use empty divs to avoid this check
            return;
          }
    
          const isCycling = Boolean(this._interval);
          this.pause();
          this._isSliding = true;
    
          this._setActiveIndicatorElement(nextElementIndex);
    
          this._activeElement = nextElement;
          const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
          const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
          nextElement.classList.add(orderClassName);
          reflow(nextElement);
          activeElement.classList.add(directionalClassName);
          nextElement.classList.add(directionalClassName);
    
          const completeCallBack = () => {
            nextElement.classList.remove(directionalClassName, orderClassName);
            nextElement.classList.add(CLASS_NAME_ACTIVE$2);
            activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
            this._isSliding = false;
            triggerEvent(EVENT_SLID);
          };
    
          this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    
          if (isCycling) {
            this.cycle();
          }
        }
    
        _isAnimated() {
          return this._element.classList.contains(CLASS_NAME_SLIDE);
        }
    
        _getActive() {
          return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
        }
    
        _getItems() {
          return SelectorEngine.find(SELECTOR_ITEM, this._element);
        }
    
        _clearInterval() {
          if (this._interval) {
            clearInterval(this._interval);
            this._interval = null;
          }
        }
    
        _directionToOrder(direction) {
          if (isRTL()) {
            return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
          }
    
          return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
        }
    
        _orderToDirection(order) {
          if (isRTL()) {
            return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
    
          return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Carousel.getOrCreateInstance(this, config);
    
            if (typeof config === 'number') {
              data.to(config);
              return;
            }
    
            if (typeof config === 'string') {
              if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
                throw new TypeError(`No method named "${config}"`);
              }
    
              data[config]();
            }
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
        const target = getElementFromSelector(this);
    
        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
          return;
        }
    
        event.preventDefault();
        const carousel = Carousel.getOrCreateInstance(target);
        const slideIndex = this.getAttribute('data-bs-slide-to');
    
        if (slideIndex) {
          carousel.to(slideIndex);
    
          carousel._maybeEnableCycle();
    
          return;
        }
    
        if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
          carousel.next();
    
          carousel._maybeEnableCycle();
    
          return;
        }
    
        carousel.prev();
    
        carousel._maybeEnableCycle();
      });
      EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
        const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    
        for (const carousel of carousels) {
          Carousel.getOrCreateInstance(carousel);
        }
      });
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Carousel);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): collapse.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$b = 'collapse';
      const DATA_KEY$7 = 'bs.collapse';
      const EVENT_KEY$7 = `.${DATA_KEY$7}`;
      const DATA_API_KEY$4 = '.data-api';
      const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
      const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
      const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
      const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
      const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
      const CLASS_NAME_SHOW$7 = 'show';
      const CLASS_NAME_COLLAPSE = 'collapse';
      const CLASS_NAME_COLLAPSING = 'collapsing';
      const CLASS_NAME_COLLAPSED = 'collapsed';
      const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
      const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
      const WIDTH = 'width';
      const HEIGHT = 'height';
      const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
      const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
      const Default$a = {
        parent: null,
        toggle: true
      };
      const DefaultType$a = {
        parent: '(null|element)',
        toggle: 'boolean'
      };
      /**
       * Class definition
       */
    
      class Collapse extends BaseComponent {
        constructor(element, config) {
          super(element, config);
          this._isTransitioning = false;
          this._triggerArray = [];
          const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    
          for (const elem of toggleList) {
            const selector = getSelectorFromElement(elem);
            const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
    
            if (selector !== null && filterElement.length) {
              this._triggerArray.push(elem);
            }
          }
    
          this._initializeChildren();
    
          if (!this._config.parent) {
            this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
          }
    
          if (this._config.toggle) {
            this.toggle();
          }
        } // Getters
    
    
        static get Default() {
          return Default$a;
        }
    
        static get DefaultType() {
          return DefaultType$a;
        }
    
        static get NAME() {
          return NAME$b;
        } // Public
    
    
        toggle() {
          if (this._isShown()) {
            this.hide();
          } else {
            this.show();
          }
        }
    
        show() {
          if (this._isTransitioning || this._isShown()) {
            return;
          }
    
          let activeChildren = []; // find active children
    
          if (this._config.parent) {
            activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
              toggle: false
            }));
          }
    
          if (activeChildren.length && activeChildren[0]._isTransitioning) {
            return;
          }
    
          const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    
          if (startEvent.defaultPrevented) {
            return;
          }
    
          for (const activeInstance of activeChildren) {
            activeInstance.hide();
          }
    
          const dimension = this._getDimension();
    
          this._element.classList.remove(CLASS_NAME_COLLAPSE);
    
          this._element.classList.add(CLASS_NAME_COLLAPSING);
    
          this._element.style[dimension] = 0;
    
          this._addAriaAndCollapsedClass(this._triggerArray, true);
    
          this._isTransitioning = true;
    
          const complete = () => {
            this._isTransitioning = false;
    
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
    
            this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    
            this._element.style[dimension] = '';
            EventHandler.trigger(this._element, EVENT_SHOWN$6);
          };
    
          const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
          const scrollSize = `scroll${capitalizedDimension}`;
    
          this._queueCallback(complete, this._element, true);
    
          this._element.style[dimension] = `${this._element[scrollSize]}px`;
        }
    
        hide() {
          if (this._isTransitioning || !this._isShown()) {
            return;
          }
    
          const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    
          if (startEvent.defaultPrevented) {
            return;
          }
    
          const dimension = this._getDimension();
    
          this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
          reflow(this._element);
    
          this._element.classList.add(CLASS_NAME_COLLAPSING);
    
          this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    
          for (const trigger of this._triggerArray) {
            const element = getElementFromSelector(trigger);
    
            if (element && !this._isShown(element)) {
              this._addAriaAndCollapsedClass([trigger], false);
            }
          }
    
          this._isTransitioning = true;
    
          const complete = () => {
            this._isTransitioning = false;
    
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
    
            this._element.classList.add(CLASS_NAME_COLLAPSE);
    
            EventHandler.trigger(this._element, EVENT_HIDDEN$6);
          };
    
          this._element.style[dimension] = '';
    
          this._queueCallback(complete, this._element, true);
        }
    
        _isShown(element = this._element) {
          return element.classList.contains(CLASS_NAME_SHOW$7);
        } // Private
    
    
        _configAfterMerge(config) {
          config.toggle = Boolean(config.toggle); // Coerce string values
    
          config.parent = getElement(config.parent);
          return config;
        }
    
        _getDimension() {
          return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
        }
    
        _initializeChildren() {
          if (!this._config.parent) {
            return;
          }
    
          const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    
          for (const element of children) {
            const selected = getElementFromSelector(element);
    
            if (selected) {
              this._addAriaAndCollapsedClass([element], this._isShown(selected));
            }
          }
        }
    
        _getFirstLevelChildren(selector) {
          const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth
    
          return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
        }
    
        _addAriaAndCollapsedClass(triggerArray, isOpen) {
          if (!triggerArray.length) {
            return;
          }
    
          for (const element of triggerArray) {
            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
            element.setAttribute('aria-expanded', isOpen);
          }
        } // Static
    
    
        static jQueryInterface(config) {
          const _config = {};
    
          if (typeof config === 'string' && /show|hide/.test(config)) {
            _config.toggle = false;
          }
    
          return this.each(function () {
            const data = Collapse.getOrCreateInstance(this, _config);
    
            if (typeof config === 'string') {
              if (typeof data[config] === 'undefined') {
                throw new TypeError(`No method named "${config}"`);
              }
    
              data[config]();
            }
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
        // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
        if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
          event.preventDefault();
        }
    
        const selector = getSelectorFromElement(this);
        const selectorElements = SelectorEngine.find(selector);
    
        for (const element of selectorElements) {
          Collapse.getOrCreateInstance(element, {
            toggle: false
          }).toggle();
        }
      });
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Collapse);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): dropdown.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$a = 'dropdown';
      const DATA_KEY$6 = 'bs.dropdown';
      const EVENT_KEY$6 = `.${DATA_KEY$6}`;
      const DATA_API_KEY$3 = '.data-api';
      const ESCAPE_KEY$2 = 'Escape';
      const TAB_KEY$1 = 'Tab';
      const ARROW_UP_KEY$1 = 'ArrowUp';
      const ARROW_DOWN_KEY$1 = 'ArrowDown';
      const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button
    
      const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
      const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
      const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
      const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
      const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
      const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
      const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
      const CLASS_NAME_SHOW$6 = 'show';
      const CLASS_NAME_DROPUP = 'dropup';
      const CLASS_NAME_DROPEND = 'dropend';
      const CLASS_NAME_DROPSTART = 'dropstart';
      const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
      const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
      const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
      const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
      const SELECTOR_MENU = '.dropdown-menu';
      const SELECTOR_NAVBAR = '.navbar';
      const SELECTOR_NAVBAR_NAV = '.navbar-nav';
      const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
      const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
      const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
      const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
      const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
      const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
      const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
      const PLACEMENT_TOPCENTER = 'top';
      const PLACEMENT_BOTTOMCENTER = 'bottom';
      const Default$9 = {
        autoClose: true,
        boundary: 'clippingParents',
        display: 'dynamic',
        offset: [0, 2],
        popperConfig: null,
        reference: 'toggle'
      };
      const DefaultType$9 = {
        autoClose: '(boolean|string)',
        boundary: '(string|element)',
        display: 'string',
        offset: '(array|string|function)',
        popperConfig: '(null|object|function)',
        reference: '(string|element|object)'
      };
      /**
       * Class definition
       */
    
      class Dropdown extends BaseComponent {
        constructor(element, config) {
          super(element, config);
          this._popper = null;
          this._parent = this._element.parentNode; // dropdown wrapper
          // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/
    
          this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
          this._inNavbar = this._detectNavbar();
        } // Getters
    
    
        static get Default() {
          return Default$9;
        }
    
        static get DefaultType() {
          return DefaultType$9;
        }
    
        static get NAME() {
          return NAME$a;
        } // Public
    
    
        toggle() {
          return this._isShown() ? this.hide() : this.show();
        }
    
        show() {
          if (isDisabled(this._element) || this._isShown()) {
            return;
          }
    
          const relatedTarget = {
            relatedTarget: this._element
          };
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    
          if (showEvent.defaultPrevented) {
            return;
          }
    
          this._createPopper(); // If this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
    
    
          if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
            for (const element of [].concat(...document.body.children)) {
              EventHandler.on(element, 'mouseover', noop);
            }
          }
    
          this._element.focus();
    
          this._element.setAttribute('aria-expanded', true);
    
          this._menu.classList.add(CLASS_NAME_SHOW$6);
    
          this._element.classList.add(CLASS_NAME_SHOW$6);
    
          EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
        }
    
        hide() {
          if (isDisabled(this._element) || !this._isShown()) {
            return;
          }
    
          const relatedTarget = {
            relatedTarget: this._element
          };
    
          this._completeHide(relatedTarget);
        }
    
        dispose() {
          if (this._popper) {
            this._popper.destroy();
          }
    
          super.dispose();
        }
    
        update() {
          this._inNavbar = this._detectNavbar();
    
          if (this._popper) {
            this._popper.update();
          }
        } // Private
    
    
        _completeHide(relatedTarget) {
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    
          if (hideEvent.defaultPrevented) {
            return;
          } // If this is a touch-enabled device we remove the extra
          // empty mouseover listeners we added for iOS support
    
    
          if ('ontouchstart' in document.documentElement) {
            for (const element of [].concat(...document.body.children)) {
              EventHandler.off(element, 'mouseover', noop);
            }
          }
    
          if (this._popper) {
            this._popper.destroy();
          }
    
          this._menu.classList.remove(CLASS_NAME_SHOW$6);
    
          this._element.classList.remove(CLASS_NAME_SHOW$6);
    
          this._element.setAttribute('aria-expanded', 'false');
    
          Manipulator.removeDataAttribute(this._menu, 'popper');
          EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
        }
    
        _getConfig(config) {
          config = super._getConfig(config);
    
          if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
            // Popper virtual elements require a getBoundingClientRect method
            throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
          }
    
          return config;
        }
    
        _createPopper() {
          if (typeof Popper__namespace === 'undefined') {
            throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
          }
    
          let referenceElement = this._element;
    
          if (this._config.reference === 'parent') {
            referenceElement = this._parent;
          } else if (isElement(this._config.reference)) {
            referenceElement = getElement(this._config.reference);
          } else if (typeof this._config.reference === 'object') {
            referenceElement = this._config.reference;
          }
    
          const popperConfig = this._getPopperConfig();
    
          this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);
        }
    
        _isShown() {
          return this._menu.classList.contains(CLASS_NAME_SHOW$6);
        }
    
        _getPlacement() {
          const parentDropdown = this._parent;
    
          if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
            return PLACEMENT_RIGHT;
          }
    
          if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
            return PLACEMENT_LEFT;
          }
    
          if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
            return PLACEMENT_TOPCENTER;
          }
    
          if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
            return PLACEMENT_BOTTOMCENTER;
          } // We need to trim the value because custom properties can also include spaces
    
    
          const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
    
          if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
            return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
          }
    
          return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
        }
    
        _detectNavbar() {
          return this._element.closest(SELECTOR_NAVBAR) !== null;
        }
    
        _getOffset() {
          const {
            offset
          } = this._config;
    
          if (typeof offset === 'string') {
            return offset.split(',').map(value => Number.parseInt(value, 10));
          }
    
          if (typeof offset === 'function') {
            return popperData => offset(popperData, this._element);
          }
    
          return offset;
        }
    
        _getPopperConfig() {
          const defaultBsPopperConfig = {
            placement: this._getPlacement(),
            modifiers: [{
              name: 'preventOverflow',
              options: {
                boundary: this._config.boundary
              }
            }, {
              name: 'offset',
              options: {
                offset: this._getOffset()
              }
            }]
          }; // Disable Popper if we have a static display or Dropdown is in Navbar
    
          if (this._inNavbar || this._config.display === 'static') {
            Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove
    
            defaultBsPopperConfig.modifiers = [{
              name: 'applyStyles',
              enabled: false
            }];
          }
    
          return { ...defaultBsPopperConfig,
            ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
          };
        }
    
        _selectMenuItem({
          key,
          target
        }) {
          const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));
    
          if (!items.length) {
            return;
          } // if target isn't included in items (e.g. when expanding the dropdown)
          // allow cycling to get the last item in case key equals ARROW_UP_KEY
    
    
          getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Dropdown.getOrCreateInstance(this, config);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (typeof data[config] === 'undefined') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config]();
          });
        }
    
        static clearMenus(event) {
          if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
            return;
          }
    
          const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    
          for (const toggle of openToggles) {
            const context = Dropdown.getInstance(toggle);
    
            if (!context || context._config.autoClose === false) {
              continue;
            }
    
            const composedPath = event.composedPath();
            const isMenuTarget = composedPath.includes(context._menu);
    
            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
              continue;
            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
    
    
            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
              continue;
            }
    
            const relatedTarget = {
              relatedTarget: context._element
            };
    
            if (event.type === 'click') {
              relatedTarget.clickEvent = event;
            }
    
            context._completeHide(relatedTarget);
          }
        }
    
        static dataApiKeydownHandler(event) {
          // If not an UP | DOWN | ESCAPE key => not a dropdown command
          // If input/textarea && if key is other than ESCAPE => not a dropdown command
          const isInput = /input|textarea/i.test(event.target.tagName);
          const isEscapeEvent = event.key === ESCAPE_KEY$2;
          const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    
          if (!isUpOrDownEvent && !isEscapeEvent) {
            return;
          }
    
          if (isInput && !isEscapeEvent) {
            return;
          }
    
          event.preventDefault(); // todo: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.2/forms/input-group/
    
          const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
          const instance = Dropdown.getOrCreateInstance(getToggleButton);
    
          if (isUpOrDownEvent) {
            event.stopPropagation();
            instance.show();
    
            instance._selectMenuItem(event);
    
            return;
          }
    
          if (instance._isShown()) {
            // else is escape and we check if it is shown
            event.stopPropagation();
            instance.hide();
            getToggleButton.focus();
          }
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
      EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
      EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
      EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
      EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
        event.preventDefault();
        Dropdown.getOrCreateInstance(this).toggle();
      });
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Dropdown);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/scrollBar.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
      const SELECTOR_STICKY_CONTENT = '.sticky-top';
      const PROPERTY_PADDING = 'padding-right';
      const PROPERTY_MARGIN = 'margin-right';
      /**
       * Class definition
       */
    
      class ScrollBarHelper {
        constructor() {
          this._element = document.body;
        } // Public
    
    
        getWidth() {
          // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
          const documentWidth = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - documentWidth);
        }
    
        hide() {
          const width = this.getWidth();
    
          this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width
    
    
          this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
    
    
          this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
    
          this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
        }
    
        reset() {
          this._resetElementAttributes(this._element, 'overflow');
    
          this._resetElementAttributes(this._element, PROPERTY_PADDING);
    
          this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    
          this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
        }
    
        isOverflowing() {
          return this.getWidth() > 0;
        } // Private
    
    
        _disableOverFlow() {
          this._saveInitialAttribute(this._element, 'overflow');
    
          this._element.style.overflow = 'hidden';
        }
    
        _setElementAttributes(selector, styleProperty, callback) {
          const scrollbarWidth = this.getWidth();
    
          const manipulationCallBack = element => {
            if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
              return;
            }
    
            this._saveInitialAttribute(element, styleProperty);
    
            const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
            element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
          };
    
          this._applyManipulationCallback(selector, manipulationCallBack);
        }
    
        _saveInitialAttribute(element, styleProperty) {
          const actualValue = element.style.getPropertyValue(styleProperty);
    
          if (actualValue) {
            Manipulator.setDataAttribute(element, styleProperty, actualValue);
          }
        }
    
        _resetElementAttributes(selector, styleProperty) {
          const manipulationCallBack = element => {
            const value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero
    
            if (value === null) {
              element.style.removeProperty(styleProperty);
              return;
            }
    
            Manipulator.removeDataAttribute(element, styleProperty);
            element.style.setProperty(styleProperty, value);
          };
    
          this._applyManipulationCallback(selector, manipulationCallBack);
        }
    
        _applyManipulationCallback(selector, callBack) {
          if (isElement(selector)) {
            callBack(selector);
            return;
          }
    
          for (const sel of SelectorEngine.find(selector, this._element)) {
            callBack(sel);
          }
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/backdrop.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$9 = 'backdrop';
      const CLASS_NAME_FADE$4 = 'fade';
      const CLASS_NAME_SHOW$5 = 'show';
      const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
      const Default$8 = {
        className: 'modal-backdrop',
        clickCallback: null,
        isAnimated: false,
        isVisible: true,
        // if false, we use the backdrop helper without adding any element to the dom
        rootElement: 'body' // give the choice to place backdrop under different elements
    
      };
      const DefaultType$8 = {
        className: 'string',
        clickCallback: '(function|null)',
        isAnimated: 'boolean',
        isVisible: 'boolean',
        rootElement: '(element|string)'
      };
      /**
       * Class definition
       */
    
      class Backdrop extends Config {
        constructor(config) {
          super();
          this._config = this._getConfig(config);
          this._isAppended = false;
          this._element = null;
        } // Getters
    
    
        static get Default() {
          return Default$8;
        }
    
        static get DefaultType() {
          return DefaultType$8;
        }
    
        static get NAME() {
          return NAME$9;
        } // Public
    
    
        show(callback) {
          if (!this._config.isVisible) {
            execute(callback);
            return;
          }
    
          this._append();
    
          const element = this._getElement();
    
          if (this._config.isAnimated) {
            reflow(element);
          }
    
          element.classList.add(CLASS_NAME_SHOW$5);
    
          this._emulateAnimation(() => {
            execute(callback);
          });
        }
    
        hide(callback) {
          if (!this._config.isVisible) {
            execute(callback);
            return;
          }
    
          this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    
          this._emulateAnimation(() => {
            this.dispose();
            execute(callback);
          });
        }
    
        dispose() {
          if (!this._isAppended) {
            return;
          }
    
          EventHandler.off(this._element, EVENT_MOUSEDOWN);
    
          this._element.remove();
    
          this._isAppended = false;
        } // Private
    
    
        _getElement() {
          if (!this._element) {
            const backdrop = document.createElement('div');
            backdrop.className = this._config.className;
    
            if (this._config.isAnimated) {
              backdrop.classList.add(CLASS_NAME_FADE$4);
            }
    
            this._element = backdrop;
          }
    
          return this._element;
        }
    
        _configAfterMerge(config) {
          // use getElement() with the default "body" to get a fresh Element on each instantiation
          config.rootElement = getElement(config.rootElement);
          return config;
        }
    
        _append() {
          if (this._isAppended) {
            return;
          }
    
          const element = this._getElement();
    
          this._config.rootElement.append(element);
    
          EventHandler.on(element, EVENT_MOUSEDOWN, () => {
            execute(this._config.clickCallback);
          });
          this._isAppended = true;
        }
    
        _emulateAnimation(callback) {
          executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/focustrap.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$8 = 'focustrap';
      const DATA_KEY$5 = 'bs.focustrap';
      const EVENT_KEY$5 = `.${DATA_KEY$5}`;
      const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
      const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
      const TAB_KEY = 'Tab';
      const TAB_NAV_FORWARD = 'forward';
      const TAB_NAV_BACKWARD = 'backward';
      const Default$7 = {
        autofocus: true,
        trapElement: null // The element to trap focus inside of
    
      };
      const DefaultType$7 = {
        autofocus: 'boolean',
        trapElement: 'element'
      };
      /**
       * Class definition
       */
    
      class FocusTrap extends Config {
        constructor(config) {
          super();
          this._config = this._getConfig(config);
          this._isActive = false;
          this._lastTabNavDirection = null;
        } // Getters
    
    
        static get Default() {
          return Default$7;
        }
    
        static get DefaultType() {
          return DefaultType$7;
        }
    
        static get NAME() {
          return NAME$8;
        } // Public
    
    
        activate() {
          if (this._isActive) {
            return;
          }
    
          if (this._config.autofocus) {
            this._config.trapElement.focus();
          }
    
          EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
    
          EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
          EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
          this._isActive = true;
        }
    
        deactivate() {
          if (!this._isActive) {
            return;
          }
    
          this._isActive = false;
          EventHandler.off(document, EVENT_KEY$5);
        } // Private
    
    
        _handleFocusin(event) {
          const {
            trapElement
          } = this._config;
    
          if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
            return;
          }
    
          const elements = SelectorEngine.focusableChildren(trapElement);
    
          if (elements.length === 0) {
            trapElement.focus();
          } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
            elements[elements.length - 1].focus();
          } else {
            elements[0].focus();
          }
        }
    
        _handleKeydown(event) {
          if (event.key !== TAB_KEY) {
            return;
          }
    
          this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): modal.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$7 = 'modal';
      const DATA_KEY$4 = 'bs.modal';
      const EVENT_KEY$4 = `.${DATA_KEY$4}`;
      const DATA_API_KEY$2 = '.data-api';
      const ESCAPE_KEY$1 = 'Escape';
      const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
      const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
      const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
      const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
      const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
      const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
      const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
      const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
      const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
      const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
      const CLASS_NAME_OPEN = 'modal-open';
      const CLASS_NAME_FADE$3 = 'fade';
      const CLASS_NAME_SHOW$4 = 'show';
      const CLASS_NAME_STATIC = 'modal-static';
      const OPEN_SELECTOR$1 = '.modal.show';
      const SELECTOR_DIALOG = '.modal-dialog';
      const SELECTOR_MODAL_BODY = '.modal-body';
      const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
      const Default$6 = {
        backdrop: true,
        focus: true,
        keyboard: true
      };
      const DefaultType$6 = {
        backdrop: '(boolean|string)',
        focus: 'boolean',
        keyboard: 'boolean'
      };
      /**
       * Class definition
       */
    
      class Modal extends BaseComponent {
        constructor(element, config) {
          super(element, config);
          this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
          this._backdrop = this._initializeBackDrop();
          this._focustrap = this._initializeFocusTrap();
          this._isShown = false;
          this._isTransitioning = false;
          this._scrollBar = new ScrollBarHelper();
    
          this._addEventListeners();
        } // Getters
    
    
        static get Default() {
          return Default$6;
        }
    
        static get DefaultType() {
          return DefaultType$6;
        }
    
        static get NAME() {
          return NAME$7;
        } // Public
    
    
        toggle(relatedTarget) {
          return this._isShown ? this.hide() : this.show(relatedTarget);
        }
    
        show(relatedTarget) {
          if (this._isShown || this._isTransitioning) {
            return;
          }
    
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
            relatedTarget
          });
    
          if (showEvent.defaultPrevented) {
            return;
          }
    
          this._isShown = true;
          this._isTransitioning = true;
    
          this._scrollBar.hide();
    
          document.body.classList.add(CLASS_NAME_OPEN);
    
          this._adjustDialog();
    
          this._backdrop.show(() => this._showElement(relatedTarget));
        }
    
        hide() {
          if (!this._isShown || this._isTransitioning) {
            return;
          }
    
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    
          if (hideEvent.defaultPrevented) {
            return;
          }
    
          this._isShown = false;
          this._isTransitioning = true;
    
          this._focustrap.deactivate();
    
          this._element.classList.remove(CLASS_NAME_SHOW$4);
    
          this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
        }
    
        dispose() {
          for (const htmlElement of [window, this._dialog]) {
            EventHandler.off(htmlElement, EVENT_KEY$4);
          }
    
          this._backdrop.dispose();
    
          this._focustrap.deactivate();
    
          super.dispose();
        }
    
        handleUpdate() {
          this._adjustDialog();
        } // Private
    
    
        _initializeBackDrop() {
          return new Backdrop({
            isVisible: Boolean(this._config.backdrop),
            // 'static' option will be translated to true, and booleans will keep their value,
            isAnimated: this._isAnimated()
          });
        }
    
        _initializeFocusTrap() {
          return new FocusTrap({
            trapElement: this._element
          });
        }
    
        _showElement(relatedTarget) {
          // try to append dynamic modal
          if (!document.body.contains(this._element)) {
            document.body.append(this._element);
          }
    
          this._element.style.display = 'block';
    
          this._element.removeAttribute('aria-hidden');
    
          this._element.setAttribute('aria-modal', true);
    
          this._element.setAttribute('role', 'dialog');
    
          this._element.scrollTop = 0;
          const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    
          if (modalBody) {
            modalBody.scrollTop = 0;
          }
    
          reflow(this._element);
    
          this._element.classList.add(CLASS_NAME_SHOW$4);
    
          const transitionComplete = () => {
            if (this._config.focus) {
              this._focustrap.activate();
            }
    
            this._isTransitioning = false;
            EventHandler.trigger(this._element, EVENT_SHOWN$4, {
              relatedTarget
            });
          };
    
          this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
        }
    
        _addEventListeners() {
          EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
            if (event.key !== ESCAPE_KEY$1) {
              return;
            }
    
            if (this._config.keyboard) {
              event.preventDefault();
              this.hide();
              return;
            }
    
            this._triggerBackdropTransition();
          });
          EventHandler.on(window, EVENT_RESIZE$1, () => {
            if (this._isShown && !this._isTransitioning) {
              this._adjustDialog();
            }
          });
          EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
            // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
            EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
              if (this._element !== event.target || this._element !== event2.target) {
                return;
              }
    
              if (this._config.backdrop === 'static') {
                this._triggerBackdropTransition();
    
                return;
              }
    
              if (this._config.backdrop) {
                this.hide();
              }
            });
          });
        }
    
        _hideModal() {
          this._element.style.display = 'none';
    
          this._element.setAttribute('aria-hidden', true);
    
          this._element.removeAttribute('aria-modal');
    
          this._element.removeAttribute('role');
    
          this._isTransitioning = false;
    
          this._backdrop.hide(() => {
            document.body.classList.remove(CLASS_NAME_OPEN);
    
            this._resetAdjustments();
    
            this._scrollBar.reset();
    
            EventHandler.trigger(this._element, EVENT_HIDDEN$4);
          });
        }
    
        _isAnimated() {
          return this._element.classList.contains(CLASS_NAME_FADE$3);
        }
    
        _triggerBackdropTransition() {
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    
          if (hideEvent.defaultPrevented) {
            return;
          }
    
          const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
          const initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed
    
          if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
            return;
          }
    
          if (!isModalOverflowing) {
            this._element.style.overflowY = 'hidden';
          }
    
          this._element.classList.add(CLASS_NAME_STATIC);
    
          this._queueCallback(() => {
            this._element.classList.remove(CLASS_NAME_STATIC);
    
            this._queueCallback(() => {
              this._element.style.overflowY = initialOverflowY;
            }, this._dialog);
          }, this._dialog);
    
          this._element.focus();
        }
        /**
         * The following methods are used to handle overflowing modals
         */
    
    
        _adjustDialog() {
          const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    
          const scrollbarWidth = this._scrollBar.getWidth();
    
          const isBodyOverflowing = scrollbarWidth > 0;
    
          if (isBodyOverflowing && !isModalOverflowing) {
            const property = isRTL() ? 'paddingLeft' : 'paddingRight';
            this._element.style[property] = `${scrollbarWidth}px`;
          }
    
          if (!isBodyOverflowing && isModalOverflowing) {
            const property = isRTL() ? 'paddingRight' : 'paddingLeft';
            this._element.style[property] = `${scrollbarWidth}px`;
          }
        }
    
        _resetAdjustments() {
          this._element.style.paddingLeft = '';
          this._element.style.paddingRight = '';
        } // Static
    
    
        static jQueryInterface(config, relatedTarget) {
          return this.each(function () {
            const data = Modal.getOrCreateInstance(this, config);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (typeof data[config] === 'undefined') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config](relatedTarget);
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
        const target = getElementFromSelector(this);
    
        if (['A', 'AREA'].includes(this.tagName)) {
          event.preventDefault();
        }
    
        EventHandler.one(target, EVENT_SHOW$4, showEvent => {
          if (showEvent.defaultPrevented) {
            // only register focus restorer if modal will actually get shown
            return;
          }
    
          EventHandler.one(target, EVENT_HIDDEN$4, () => {
            if (isVisible(this)) {
              this.focus();
            }
          });
        }); // avoid conflict when clicking modal toggler while another one is open
    
        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    
        if (alreadyOpen) {
          Modal.getInstance(alreadyOpen).hide();
        }
    
        const data = Modal.getOrCreateInstance(target);
        data.toggle(this);
      });
      enableDismissTrigger(Modal);
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Modal);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): offcanvas.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$6 = 'offcanvas';
      const DATA_KEY$3 = 'bs.offcanvas';
      const EVENT_KEY$3 = `.${DATA_KEY$3}`;
      const DATA_API_KEY$1 = '.data-api';
      const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
      const ESCAPE_KEY = 'Escape';
      const CLASS_NAME_SHOW$3 = 'show';
      const CLASS_NAME_SHOWING$1 = 'showing';
      const CLASS_NAME_HIDING = 'hiding';
      const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
      const OPEN_SELECTOR = '.offcanvas.show';
      const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
      const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
      const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
      const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
      const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
      const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
      const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
      const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
      const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
      const Default$5 = {
        backdrop: true,
        keyboard: true,
        scroll: false
      };
      const DefaultType$5 = {
        backdrop: '(boolean|string)',
        keyboard: 'boolean',
        scroll: 'boolean'
      };
      /**
       * Class definition
       */
    
      class Offcanvas extends BaseComponent {
        constructor(element, config) {
          super(element, config);
          this._isShown = false;
          this._backdrop = this._initializeBackDrop();
          this._focustrap = this._initializeFocusTrap();
    
          this._addEventListeners();
        } // Getters
    
    
        static get Default() {
          return Default$5;
        }
    
        static get DefaultType() {
          return DefaultType$5;
        }
    
        static get NAME() {
          return NAME$6;
        } // Public
    
    
        toggle(relatedTarget) {
          return this._isShown ? this.hide() : this.show(relatedTarget);
        }
    
        show(relatedTarget) {
          if (this._isShown) {
            return;
          }
    
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
            relatedTarget
          });
    
          if (showEvent.defaultPrevented) {
            return;
          }
    
          this._isShown = true;
    
          this._backdrop.show();
    
          if (!this._config.scroll) {
            new ScrollBarHelper().hide();
          }
    
          this._element.setAttribute('aria-modal', true);
    
          this._element.setAttribute('role', 'dialog');
    
          this._element.classList.add(CLASS_NAME_SHOWING$1);
    
          const completeCallBack = () => {
            if (!this._config.scroll || this._config.backdrop) {
              this._focustrap.activate();
            }
    
            this._element.classList.add(CLASS_NAME_SHOW$3);
    
            this._element.classList.remove(CLASS_NAME_SHOWING$1);
    
            EventHandler.trigger(this._element, EVENT_SHOWN$3, {
              relatedTarget
            });
          };
    
          this._queueCallback(completeCallBack, this._element, true);
        }
    
        hide() {
          if (!this._isShown) {
            return;
          }
    
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    
          if (hideEvent.defaultPrevented) {
            return;
          }
    
          this._focustrap.deactivate();
    
          this._element.blur();
    
          this._isShown = false;
    
          this._element.classList.add(CLASS_NAME_HIDING);
    
          this._backdrop.hide();
    
          const completeCallback = () => {
            this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
    
            this._element.removeAttribute('aria-modal');
    
            this._element.removeAttribute('role');
    
            if (!this._config.scroll) {
              new ScrollBarHelper().reset();
            }
    
            EventHandler.trigger(this._element, EVENT_HIDDEN$3);
          };
    
          this._queueCallback(completeCallback, this._element, true);
        }
    
        dispose() {
          this._backdrop.dispose();
    
          this._focustrap.deactivate();
    
          super.dispose();
        } // Private
    
    
        _initializeBackDrop() {
          const clickCallback = () => {
            if (this._config.backdrop === 'static') {
              EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
              return;
            }
    
            this.hide();
          }; // 'static' option will be translated to true, and booleans will keep their value
    
    
          const isVisible = Boolean(this._config.backdrop);
          return new Backdrop({
            className: CLASS_NAME_BACKDROP,
            isVisible,
            isAnimated: true,
            rootElement: this._element.parentNode,
            clickCallback: isVisible ? clickCallback : null
          });
        }
    
        _initializeFocusTrap() {
          return new FocusTrap({
            trapElement: this._element
          });
        }
    
        _addEventListeners() {
          EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
            if (event.key !== ESCAPE_KEY) {
              return;
            }
    
            if (!this._config.keyboard) {
              EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
              return;
            }
    
            this.hide();
          });
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Offcanvas.getOrCreateInstance(this, config);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config](this);
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
        const target = getElementFromSelector(this);
    
        if (['A', 'AREA'].includes(this.tagName)) {
          event.preventDefault();
        }
    
        if (isDisabled(this)) {
          return;
        }
    
        EventHandler.one(target, EVENT_HIDDEN$3, () => {
          // focus on trigger when it is closed
          if (isVisible(this)) {
            this.focus();
          }
        }); // avoid conflict when clicking a toggler of an offcanvas, while another is open
    
        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    
        if (alreadyOpen && alreadyOpen !== target) {
          Offcanvas.getInstance(alreadyOpen).hide();
        }
    
        const data = Offcanvas.getOrCreateInstance(target);
        data.toggle(this);
      });
      EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
        for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
          Offcanvas.getOrCreateInstance(selector).show();
        }
      });
      EventHandler.on(window, EVENT_RESIZE, () => {
        for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {
          if (getComputedStyle(element).position !== 'fixed') {
            Offcanvas.getOrCreateInstance(element).hide();
          }
        }
      });
      enableDismissTrigger(Offcanvas);
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Offcanvas);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/sanitizer.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
      const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
      /**
       * A pattern that recognizes a commonly useful subset of URLs that are safe.
       *
       * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
       */
    
      const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
      /**
       * A pattern that matches safe data URLs. Only matches image, video and audio types.
       *
       * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
       */
    
      const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
    
      const allowedAttribute = (attribute, allowedAttributeList) => {
        const attributeName = attribute.nodeName.toLowerCase();
    
        if (allowedAttributeList.includes(attributeName)) {
          if (uriAttributes.has(attributeName)) {
            return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
          }
    
          return true;
        } // Check if a regular expression validates the attribute.
    
    
        return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
      };
    
      const DefaultAllowlist = {
        // Global attributes allowed on any supplied element below.
        '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
        a: ['target', 'href', 'title', 'rel'],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
      };
      function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
        if (!unsafeHtml.length) {
          return unsafeHtml;
        }
    
        if (sanitizeFunction && typeof sanitizeFunction === 'function') {
          return sanitizeFunction(unsafeHtml);
        }
    
        const domParser = new window.DOMParser();
        const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
        const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
    
        for (const element of elements) {
          const elementName = element.nodeName.toLowerCase();
    
          if (!Object.keys(allowList).includes(elementName)) {
            element.remove();
            continue;
          }
    
          const attributeList = [].concat(...element.attributes);
          const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
    
          for (const attribute of attributeList) {
            if (!allowedAttribute(attribute, allowedAttributes)) {
              element.removeAttribute(attribute.nodeName);
            }
          }
        }
    
        return createdDocument.body.innerHTML;
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): util/template-factory.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$5 = 'TemplateFactory';
      const Default$4 = {
        allowList: DefaultAllowlist,
        content: {},
        // { selector : text ,  selector2 : text2 , }
        extraClass: '',
        html: false,
        sanitize: true,
        sanitizeFn: null,
        template: '<div></div>'
      };
      const DefaultType$4 = {
        allowList: 'object',
        content: 'object',
        extraClass: '(string|function)',
        html: 'boolean',
        sanitize: 'boolean',
        sanitizeFn: '(null|function)',
        template: 'string'
      };
      const DefaultContentType = {
        entry: '(string|element|function|null)',
        selector: '(string|element)'
      };
      /**
       * Class definition
       */
    
      class TemplateFactory extends Config {
        constructor(config) {
          super();
          this._config = this._getConfig(config);
        } // Getters
    
    
        static get Default() {
          return Default$4;
        }
    
        static get DefaultType() {
          return DefaultType$4;
        }
    
        static get NAME() {
          return NAME$5;
        } // Public
    
    
        getContent() {
          return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);
        }
    
        hasContent() {
          return this.getContent().length > 0;
        }
    
        changeContent(content) {
          this._checkContent(content);
    
          this._config.content = { ...this._config.content,
            ...content
          };
          return this;
        }
    
        toHtml() {
          const templateWrapper = document.createElement('div');
          templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    
          for (const [selector, text] of Object.entries(this._config.content)) {
            this._setContent(templateWrapper, text, selector);
          }
    
          const template = templateWrapper.children[0];
    
          const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    
          if (extraClass) {
            template.classList.add(...extraClass.split(' '));
          }
    
          return template;
        } // Private
    
    
        _typeCheckConfig(config) {
          super._typeCheckConfig(config);
    
          this._checkContent(config.content);
        }
    
        _checkContent(arg) {
          for (const [selector, content] of Object.entries(arg)) {
            super._typeCheckConfig({
              selector,
              entry: content
            }, DefaultContentType);
          }
        }
    
        _setContent(template, content, selector) {
          const templateElement = SelectorEngine.findOne(selector, template);
    
          if (!templateElement) {
            return;
          }
    
          content = this._resolvePossibleFunction(content);
    
          if (!content) {
            templateElement.remove();
            return;
          }
    
          if (isElement(content)) {
            this._putElementInTemplate(getElement(content), templateElement);
    
            return;
          }
    
          if (this._config.html) {
            templateElement.innerHTML = this._maybeSanitize(content);
            return;
          }
    
          templateElement.textContent = content;
        }
    
        _maybeSanitize(arg) {
          return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
        }
    
        _resolvePossibleFunction(arg) {
          return typeof arg === 'function' ? arg(this) : arg;
        }
    
        _putElementInTemplate(element, templateElement) {
          if (this._config.html) {
            templateElement.innerHTML = '';
            templateElement.append(element);
            return;
          }
    
          templateElement.textContent = element.textContent;
        }
    
      }
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): tooltip.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$4 = 'tooltip';
      const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
      const CLASS_NAME_FADE$2 = 'fade';
      const CLASS_NAME_MODAL = 'modal';
      const CLASS_NAME_SHOW$2 = 'show';
      const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
      const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
      const EVENT_MODAL_HIDE = 'hide.bs.modal';
      const TRIGGER_HOVER = 'hover';
      const TRIGGER_FOCUS = 'focus';
      const TRIGGER_CLICK = 'click';
      const TRIGGER_MANUAL = 'manual';
      const EVENT_HIDE$2 = 'hide';
      const EVENT_HIDDEN$2 = 'hidden';
      const EVENT_SHOW$2 = 'show';
      const EVENT_SHOWN$2 = 'shown';
      const EVENT_INSERTED = 'inserted';
      const EVENT_CLICK$1 = 'click';
      const EVENT_FOCUSIN$1 = 'focusin';
      const EVENT_FOCUSOUT$1 = 'focusout';
      const EVENT_MOUSEENTER = 'mouseenter';
      const EVENT_MOUSELEAVE = 'mouseleave';
      const AttachmentMap = {
        AUTO: 'auto',
        TOP: 'top',
        RIGHT: isRTL() ? 'left' : 'right',
        BOTTOM: 'bottom',
        LEFT: isRTL() ? 'right' : 'left'
      };
      const Default$3 = {
        allowList: DefaultAllowlist,
        animation: true,
        boundary: 'clippingParents',
        container: false,
        customClass: '',
        delay: 0,
        fallbackPlacements: ['top', 'right', 'bottom', 'left'],
        html: false,
        offset: [0, 0],
        placement: 'top',
        popperConfig: null,
        sanitize: true,
        sanitizeFn: null,
        selector: false,
        template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
        title: '',
        trigger: 'hover focus'
      };
      const DefaultType$3 = {
        allowList: 'object',
        animation: 'boolean',
        boundary: '(string|element)',
        container: '(string|element|boolean)',
        customClass: '(string|function)',
        delay: '(number|object)',
        fallbackPlacements: 'array',
        html: 'boolean',
        offset: '(array|string|function)',
        placement: '(string|function)',
        popperConfig: '(null|object|function)',
        sanitize: 'boolean',
        sanitizeFn: '(null|function)',
        selector: '(string|boolean)',
        template: 'string',
        title: '(string|element|function)',
        trigger: 'string'
      };
      /**
       * Class definition
       */
    
      class Tooltip extends BaseComponent {
        constructor(element, config) {
          if (typeof Popper__namespace === 'undefined') {
            throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
          }
    
          super(element, config); // Private
    
          this._isEnabled = true;
          this._timeout = 0;
          this._isHovered = null;
          this._activeTrigger = {};
          this._popper = null;
          this._templateFactory = null;
          this._newContent = null; // Protected
    
          this.tip = null;
    
          this._setListeners();
    
          if (!this._config.selector) {
            this._fixTitle();
          }
        } // Getters
    
    
        static get Default() {
          return Default$3;
        }
    
        static get DefaultType() {
          return DefaultType$3;
        }
    
        static get NAME() {
          return NAME$4;
        } // Public
    
    
        enable() {
          this._isEnabled = true;
        }
    
        disable() {
          this._isEnabled = false;
        }
    
        toggleEnabled() {
          this._isEnabled = !this._isEnabled;
        }
    
        toggle() {
          if (!this._isEnabled) {
            return;
          }
    
          this._activeTrigger.click = !this._activeTrigger.click;
    
          if (this._isShown()) {
            this._leave();
    
            return;
          }
    
          this._enter();
        }
    
        dispose() {
          clearTimeout(this._timeout);
          EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    
          if (this._element.getAttribute('data-bs-original-title')) {
            this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
          }
    
          this._disposePopper();
    
          super.dispose();
        }
    
        show() {
          if (this._element.style.display === 'none') {
            throw new Error('Please use show on visible elements');
          }
    
          if (!(this._isWithContent() && this._isEnabled)) {
            return;
          }
    
          const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
          const shadowRoot = findShadowRoot(this._element);
    
          const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    
          if (showEvent.defaultPrevented || !isInTheDom) {
            return;
          } // todo v6 remove this OR make it optional
    
    
          this._disposePopper();
    
          const tip = this._getTipElement();
    
          this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
    
          const {
            container
          } = this._config;
    
          if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
            container.append(tip);
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
          }
    
          this._popper = this._createPopper(tip);
          tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
    
          if ('ontouchstart' in document.documentElement) {
            for (const element of [].concat(...document.body.children)) {
              EventHandler.on(element, 'mouseover', noop);
            }
          }
    
          const complete = () => {
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
    
            if (this._isHovered === false) {
              this._leave();
            }
    
            this._isHovered = false;
          };
    
          this._queueCallback(complete, this.tip, this._isAnimated());
        }
    
        hide() {
          if (!this._isShown()) {
            return;
          }
    
          const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    
          if (hideEvent.defaultPrevented) {
            return;
          }
    
          const tip = this._getTipElement();
    
          tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra
          // empty mouseover listeners we added for iOS support
    
          if ('ontouchstart' in document.documentElement) {
            for (const element of [].concat(...document.body.children)) {
              EventHandler.off(element, 'mouseover', noop);
            }
          }
    
          this._activeTrigger[TRIGGER_CLICK] = false;
          this._activeTrigger[TRIGGER_FOCUS] = false;
          this._activeTrigger[TRIGGER_HOVER] = false;
          this._isHovered = null; // it is a trick to support manual triggering
    
          const complete = () => {
            if (this._isWithActiveTrigger()) {
              return;
            }
    
            if (!this._isHovered) {
              this._disposePopper();
            }
    
            this._element.removeAttribute('aria-describedby');
    
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
          };
    
          this._queueCallback(complete, this.tip, this._isAnimated());
        }
    
        update() {
          if (this._popper) {
            this._popper.update();
          }
        } // Protected
    
    
        _isWithContent() {
          return Boolean(this._getTitle());
        }
    
        _getTipElement() {
          if (!this.tip) {
            this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
          }
    
          return this.tip;
        }
    
        _createTipElement(content) {
          const tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6
    
    
          if (!tip) {
            return null;
          }
    
          tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only
    
          tip.classList.add(`bs-${this.constructor.NAME}-auto`);
          const tipId = getUID(this.constructor.NAME).toString();
          tip.setAttribute('id', tipId);
    
          if (this._isAnimated()) {
            tip.classList.add(CLASS_NAME_FADE$2);
          }
    
          return tip;
        }
    
        setContent(content) {
          this._newContent = content;
    
          if (this._isShown()) {
            this._disposePopper();
    
            this.show();
          }
        }
    
        _getTemplateFactory(content) {
          if (this._templateFactory) {
            this._templateFactory.changeContent(content);
          } else {
            this._templateFactory = new TemplateFactory({ ...this._config,
              // the `content` var has to be after `this._config`
              // to override config.content in case of popover
              content,
              extraClass: this._resolvePossibleFunction(this._config.customClass)
            });
          }
    
          return this._templateFactory;
        }
    
        _getContentForTemplate() {
          return {
            [SELECTOR_TOOLTIP_INNER]: this._getTitle()
          };
        }
    
        _getTitle() {
          return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
        } // Private
    
    
        _initializeOnDelegatedTarget(event) {
          return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
        }
    
        _isAnimated() {
          return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
        }
    
        _isShown() {
          return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
        }
    
        _createPopper(tip) {
          const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;
          const attachment = AttachmentMap[placement.toUpperCase()];
          return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));
        }
    
        _getOffset() {
          const {
            offset
          } = this._config;
    
          if (typeof offset === 'string') {
            return offset.split(',').map(value => Number.parseInt(value, 10));
          }
    
          if (typeof offset === 'function') {
            return popperData => offset(popperData, this._element);
          }
    
          return offset;
        }
    
        _resolvePossibleFunction(arg) {
          return typeof arg === 'function' ? arg.call(this._element) : arg;
        }
    
        _getPopperConfig(attachment) {
          const defaultBsPopperConfig = {
            placement: attachment,
            modifiers: [{
              name: 'flip',
              options: {
                fallbackPlacements: this._config.fallbackPlacements
              }
            }, {
              name: 'offset',
              options: {
                offset: this._getOffset()
              }
            }, {
              name: 'preventOverflow',
              options: {
                boundary: this._config.boundary
              }
            }, {
              name: 'arrow',
              options: {
                element: `.${this.constructor.NAME}-arrow`
              }
            }, {
              name: 'preSetPlacement',
              enabled: true,
              phase: 'beforeMain',
              fn: data => {
                // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
                // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
                this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
              }
            }]
          };
          return { ...defaultBsPopperConfig,
            ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
          };
        }
    
        _setListeners() {
          const triggers = this._config.trigger.split(' ');
    
          for (const trigger of triggers) {
            if (trigger === 'click') {
              EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {
                const context = this._initializeOnDelegatedTarget(event);
    
                context.toggle();
              });
            } else if (trigger !== TRIGGER_MANUAL) {
              const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
              const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
              EventHandler.on(this._element, eventIn, this._config.selector, event => {
                const context = this._initializeOnDelegatedTarget(event);
    
                context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
    
                context._enter();
              });
              EventHandler.on(this._element, eventOut, this._config.selector, event => {
                const context = this._initializeOnDelegatedTarget(event);
    
                context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
    
                context._leave();
              });
            }
          }
    
          this._hideModalHandler = () => {
            if (this._element) {
              this.hide();
            }
          };
    
          EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
        }
    
        _fixTitle() {
          const title = this._element.getAttribute('title');
    
          if (!title) {
            return;
          }
    
          if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
            this._element.setAttribute('aria-label', title);
          }
    
          this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
    
    
          this._element.removeAttribute('title');
        }
    
        _enter() {
          if (this._isShown() || this._isHovered) {
            this._isHovered = true;
            return;
          }
    
          this._isHovered = true;
    
          this._setTimeout(() => {
            if (this._isHovered) {
              this.show();
            }
          }, this._config.delay.show);
        }
    
        _leave() {
          if (this._isWithActiveTrigger()) {
            return;
          }
    
          this._isHovered = false;
    
          this._setTimeout(() => {
            if (!this._isHovered) {
              this.hide();
            }
          }, this._config.delay.hide);
        }
    
        _setTimeout(handler, timeout) {
          clearTimeout(this._timeout);
          this._timeout = setTimeout(handler, timeout);
        }
    
        _isWithActiveTrigger() {
          return Object.values(this._activeTrigger).includes(true);
        }
    
        _getConfig(config) {
          const dataAttributes = Manipulator.getDataAttributes(this._element);
    
          for (const dataAttribute of Object.keys(dataAttributes)) {
            if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
              delete dataAttributes[dataAttribute];
            }
          }
    
          config = { ...dataAttributes,
            ...(typeof config === 'object' && config ? config : {})
          };
          config = this._mergeConfigObj(config);
          config = this._configAfterMerge(config);
    
          this._typeCheckConfig(config);
    
          return config;
        }
    
        _configAfterMerge(config) {
          config.container = config.container === false ? document.body : getElement(config.container);
    
          if (typeof config.delay === 'number') {
            config.delay = {
              show: config.delay,
              hide: config.delay
            };
          }
    
          if (typeof config.title === 'number') {
            config.title = config.title.toString();
          }
    
          if (typeof config.content === 'number') {
            config.content = config.content.toString();
          }
    
          return config;
        }
    
        _getDelegateConfig() {
          const config = {};
    
          for (const key in this._config) {
            if (this.constructor.Default[key] !== this._config[key]) {
              config[key] = this._config[key];
            }
          }
    
          config.selector = false;
          config.trigger = 'manual'; // In the future can be replaced with:
          // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
          // `Object.fromEntries(keysWithDifferentValues)`
    
          return config;
        }
    
        _disposePopper() {
          if (this._popper) {
            this._popper.destroy();
    
            this._popper = null;
          }
    
          if (this.tip) {
            this.tip.remove();
            this.tip = null;
          }
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Tooltip.getOrCreateInstance(this, config);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (typeof data[config] === 'undefined') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config]();
          });
        }
    
      }
      /**
       * jQuery
       */
    
    
      defineJQueryPlugin(Tooltip);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): popover.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$3 = 'popover';
      const SELECTOR_TITLE = '.popover-header';
      const SELECTOR_CONTENT = '.popover-body';
      const Default$2 = { ...Tooltip.Default,
        content: '',
        offset: [0, 8],
        placement: 'right',
        template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
        trigger: 'click'
      };
      const DefaultType$2 = { ...Tooltip.DefaultType,
        content: '(null|string|element|function)'
      };
      /**
       * Class definition
       */
    
      class Popover extends Tooltip {
        // Getters
        static get Default() {
          return Default$2;
        }
    
        static get DefaultType() {
          return DefaultType$2;
        }
    
        static get NAME() {
          return NAME$3;
        } // Overrides
    
    
        _isWithContent() {
          return this._getTitle() || this._getContent();
        } // Private
    
    
        _getContentForTemplate() {
          return {
            [SELECTOR_TITLE]: this._getTitle(),
            [SELECTOR_CONTENT]: this._getContent()
          };
        }
    
        _getContent() {
          return this._resolvePossibleFunction(this._config.content);
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Popover.getOrCreateInstance(this, config);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (typeof data[config] === 'undefined') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config]();
          });
        }
    
      }
      /**
       * jQuery
       */
    
    
      defineJQueryPlugin(Popover);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): scrollspy.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$2 = 'scrollspy';
      const DATA_KEY$2 = 'bs.scrollspy';
      const EVENT_KEY$2 = `.${DATA_KEY$2}`;
      const DATA_API_KEY = '.data-api';
      const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
      const EVENT_CLICK = `click${EVENT_KEY$2}`;
      const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
      const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
      const CLASS_NAME_ACTIVE$1 = 'active';
      const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
      const SELECTOR_TARGET_LINKS = '[href]';
      const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
      const SELECTOR_NAV_LINKS = '.nav-link';
      const SELECTOR_NAV_ITEMS = '.nav-item';
      const SELECTOR_LIST_ITEMS = '.list-group-item';
      const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
      const SELECTOR_DROPDOWN = '.dropdown';
      const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
      const Default$1 = {
        offset: null,
        // TODO: v6 @deprecated, keep it for backwards compatibility reasons
        rootMargin: '0px 0px -25%',
        smoothScroll: false,
        target: null,
        threshold: [0.1, 0.5, 1]
      };
      const DefaultType$1 = {
        offset: '(number|null)',
        // TODO v6 @deprecated, keep it for backwards compatibility reasons
        rootMargin: 'string',
        smoothScroll: 'boolean',
        target: 'element',
        threshold: 'array'
      };
      /**
       * Class definition
       */
    
      class ScrollSpy extends BaseComponent {
        constructor(element, config) {
          super(element, config); // this._element is the observablesContainer and config.target the menu links wrapper
    
          this._targetLinks = new Map();
          this._observableSections = new Map();
          this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
          this._activeTarget = null;
          this._observer = null;
          this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0
          };
          this.refresh(); // initialize
        } // Getters
    
    
        static get Default() {
          return Default$1;
        }
    
        static get DefaultType() {
          return DefaultType$1;
        }
    
        static get NAME() {
          return NAME$2;
        } // Public
    
    
        refresh() {
          this._initializeTargetsAndObservables();
    
          this._maybeEnableSmoothScroll();
    
          if (this._observer) {
            this._observer.disconnect();
          } else {
            this._observer = this._getNewObserver();
          }
    
          for (const section of this._observableSections.values()) {
            this._observer.observe(section);
          }
        }
    
        dispose() {
          this._observer.disconnect();
    
          super.dispose();
        } // Private
    
    
        _configAfterMerge(config) {
          // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
          config.target = getElement(config.target) || document.body; // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
    
          config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
    
          if (typeof config.threshold === 'string') {
            config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));
          }
    
          return config;
        }
    
        _maybeEnableSmoothScroll() {
          if (!this._config.smoothScroll) {
            return;
          } // unregister any previous listeners
    
    
          EventHandler.off(this._config.target, EVENT_CLICK);
          EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
            const observableSection = this._observableSections.get(event.target.hash);
    
            if (observableSection) {
              event.preventDefault();
              const root = this._rootElement || window;
              const height = observableSection.offsetTop - this._element.offsetTop;
    
              if (root.scrollTo) {
                root.scrollTo({
                  top: height,
                  behavior: 'smooth'
                });
                return;
              } // Chrome 60 doesn't support `scrollTo`
    
    
              root.scrollTop = height;
            }
          });
        }
    
        _getNewObserver() {
          const options = {
            root: this._rootElement,
            threshold: this._config.threshold,
            rootMargin: this._config.rootMargin
          };
          return new IntersectionObserver(entries => this._observerCallback(entries), options);
        } // The logic of selection
    
    
        _observerCallback(entries) {
          const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);
    
          const activate = entry => {
            this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
    
            this._process(targetElement(entry));
          };
    
          const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
          const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
          this._previousScrollData.parentScrollTop = parentScrollTop;
    
          for (const entry of entries) {
            if (!entry.isIntersecting) {
              this._activeTarget = null;
    
              this._clearActiveClass(targetElement(entry));
    
              continue;
            }
    
            const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop
    
            if (userScrollsDown && entryIsLowerThanPrevious) {
              activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
    
              if (!parentScrollTop) {
                return;
              }
    
              continue;
            } // if we are scrolling up, pick the smallest offsetTop
    
    
            if (!userScrollsDown && !entryIsLowerThanPrevious) {
              activate(entry);
            }
          }
        }
    
        _initializeTargetsAndObservables() {
          this._targetLinks = new Map();
          this._observableSections = new Map();
          const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    
          for (const anchor of targetLinks) {
            // ensure that the anchor has an id and is not disabled
            if (!anchor.hash || isDisabled(anchor)) {
              continue;
            }
    
            const observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible
    
            if (isVisible(observableSection)) {
              this._targetLinks.set(anchor.hash, anchor);
    
              this._observableSections.set(anchor.hash, observableSection);
            }
          }
        }
    
        _process(target) {
          if (this._activeTarget === target) {
            return;
          }
    
          this._clearActiveClass(this._config.target);
    
          this._activeTarget = target;
          target.classList.add(CLASS_NAME_ACTIVE$1);
    
          this._activateParents(target);
    
          EventHandler.trigger(this._element, EVENT_ACTIVATE, {
            relatedTarget: target
          });
        }
    
        _activateParents(target) {
          // Activate dropdown parents
          if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
            SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
            return;
          }
    
          for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
            // Set triggered links parents as active
            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
            for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
              item.classList.add(CLASS_NAME_ACTIVE$1);
            }
          }
        }
    
        _clearActiveClass(parent) {
          parent.classList.remove(CLASS_NAME_ACTIVE$1);
          const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    
          for (const node of activeNodes) {
            node.classList.remove(CLASS_NAME_ACTIVE$1);
          }
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = ScrollSpy.getOrCreateInstance(this, config);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config]();
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
        for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
          ScrollSpy.getOrCreateInstance(spy);
        }
      });
      /**
       * jQuery
       */
    
      defineJQueryPlugin(ScrollSpy);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): tab.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME$1 = 'tab';
      const DATA_KEY$1 = 'bs.tab';
      const EVENT_KEY$1 = `.${DATA_KEY$1}`;
      const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
      const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
      const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
      const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
      const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
      const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
      const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
      const ARROW_LEFT_KEY = 'ArrowLeft';
      const ARROW_RIGHT_KEY = 'ArrowRight';
      const ARROW_UP_KEY = 'ArrowUp';
      const ARROW_DOWN_KEY = 'ArrowDown';
      const CLASS_NAME_ACTIVE = 'active';
      const CLASS_NAME_FADE$1 = 'fade';
      const CLASS_NAME_SHOW$1 = 'show';
      const CLASS_DROPDOWN = 'dropdown';
      const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
      const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
      const NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';
      const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
      const SELECTOR_OUTER = '.nav-item, .list-group-item';
      const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
      const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // todo:v6: could be only `tab`
    
      const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
      const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
      /**
       * Class definition
       */
    
      class Tab extends BaseComponent {
        constructor(element) {
          super(element);
          this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    
          if (!this._parent) {
            return; // todo: should Throw exception on v6
            // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
          } // Set up initial aria attributes
    
    
          this._setInitialAttributes(this._parent, this._getChildren());
    
          EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
        } // Getters
    
    
        static get NAME() {
          return NAME$1;
        } // Public
    
    
        show() {
          // Shows this elem and deactivate the active sibling if exists
          const innerElem = this._element;
    
          if (this._elemIsActive(innerElem)) {
            return;
          } // Search for active tab on same parent to deactivate it
    
    
          const active = this._getActiveElem();
    
          const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
            relatedTarget: innerElem
          }) : null;
          const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
            relatedTarget: active
          });
    
          if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
            return;
          }
    
          this._deactivate(active, innerElem);
    
          this._activate(innerElem, active);
        } // Private
    
    
        _activate(element, relatedElem) {
          if (!element) {
            return;
          }
    
          element.classList.add(CLASS_NAME_ACTIVE);
    
          this._activate(getElementFromSelector(element)); // Search and activate/show the proper section
    
    
          const complete = () => {
            if (element.getAttribute('role') !== 'tab') {
              element.classList.add(CLASS_NAME_SHOW$1);
              return;
            }
    
            element.removeAttribute('tabindex');
            element.setAttribute('aria-selected', true);
    
            this._toggleDropDown(element, true);
    
            EventHandler.trigger(element, EVENT_SHOWN$1, {
              relatedTarget: relatedElem
            });
          };
    
          this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
        }
    
        _deactivate(element, relatedElem) {
          if (!element) {
            return;
          }
    
          element.classList.remove(CLASS_NAME_ACTIVE);
          element.blur();
    
          this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too
    
    
          const complete = () => {
            if (element.getAttribute('role') !== 'tab') {
              element.classList.remove(CLASS_NAME_SHOW$1);
              return;
            }
    
            element.setAttribute('aria-selected', false);
            element.setAttribute('tabindex', '-1');
    
            this._toggleDropDown(element, false);
    
            EventHandler.trigger(element, EVENT_HIDDEN$1, {
              relatedTarget: relatedElem
            });
          };
    
          this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
        }
    
        _keydown(event) {
          if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
            return;
          }
    
          event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
    
          event.preventDefault();
          const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
          const nextActiveElement = getNextActiveElement(this._getChildren().filter(element => !isDisabled(element)), event.target, isNext, true);
    
          if (nextActiveElement) {
            nextActiveElement.focus({
              preventScroll: true
            });
            Tab.getOrCreateInstance(nextActiveElement).show();
          }
        }
    
        _getChildren() {
          // collection of inner elements
          return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
        }
    
        _getActiveElem() {
          return this._getChildren().find(child => this._elemIsActive(child)) || null;
        }
    
        _setInitialAttributes(parent, children) {
          this._setAttributeIfNotExists(parent, 'role', 'tablist');
    
          for (const child of children) {
            this._setInitialAttributesOnChild(child);
          }
        }
    
        _setInitialAttributesOnChild(child) {
          child = this._getInnerElement(child);
    
          const isActive = this._elemIsActive(child);
    
          const outerElem = this._getOuterElement(child);
    
          child.setAttribute('aria-selected', isActive);
    
          if (outerElem !== child) {
            this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
          }
    
          if (!isActive) {
            child.setAttribute('tabindex', '-1');
          }
    
          this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too
    
    
          this._setInitialAttributesOnTargetPanel(child);
        }
    
        _setInitialAttributesOnTargetPanel(child) {
          const target = getElementFromSelector(child);
    
          if (!target) {
            return;
          }
    
          this._setAttributeIfNotExists(target, 'role', 'tabpanel');
    
          if (child.id) {
            this._setAttributeIfNotExists(target, 'aria-labelledby', `#${child.id}`);
          }
        }
    
        _toggleDropDown(element, open) {
          const outerElem = this._getOuterElement(element);
    
          if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
            return;
          }
    
          const toggle = (selector, className) => {
            const element = SelectorEngine.findOne(selector, outerElem);
    
            if (element) {
              element.classList.toggle(className, open);
            }
          };
    
          toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
          toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
          outerElem.setAttribute('aria-expanded', open);
        }
    
        _setAttributeIfNotExists(element, attribute, value) {
          if (!element.hasAttribute(attribute)) {
            element.setAttribute(attribute, value);
          }
        }
    
        _elemIsActive(elem) {
          return elem.classList.contains(CLASS_NAME_ACTIVE);
        } // Try to get the inner element (usually the .nav-link)
    
    
        _getInnerElement(elem) {
          return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
        } // Try to get the outer element (usually the .nav-item)
    
    
        _getOuterElement(elem) {
          return elem.closest(SELECTOR_OUTER) || elem;
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Tab.getOrCreateInstance(this);
    
            if (typeof config !== 'string') {
              return;
            }
    
            if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
              throw new TypeError(`No method named "${config}"`);
            }
    
            data[config]();
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
        if (['A', 'AREA'].includes(this.tagName)) {
          event.preventDefault();
        }
    
        if (isDisabled(this)) {
          return;
        }
    
        Tab.getOrCreateInstance(this).show();
      });
      /**
       * Initialize on focus
       */
    
      EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
        for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
          Tab.getOrCreateInstance(element);
        }
      });
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Tab);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): toast.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      /**
       * Constants
       */
    
      const NAME = 'toast';
      const DATA_KEY = 'bs.toast';
      const EVENT_KEY = `.${DATA_KEY}`;
      const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
      const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
      const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
      const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
      const EVENT_HIDE = `hide${EVENT_KEY}`;
      const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
      const EVENT_SHOW = `show${EVENT_KEY}`;
      const EVENT_SHOWN = `shown${EVENT_KEY}`;
      const CLASS_NAME_FADE = 'fade';
      const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
    
      const CLASS_NAME_SHOW = 'show';
      const CLASS_NAME_SHOWING = 'showing';
      const DefaultType = {
        animation: 'boolean',
        autohide: 'boolean',
        delay: 'number'
      };
      const Default = {
        animation: true,
        autohide: true,
        delay: 5000
      };
      /**
       * Class definition
       */
    
      class Toast extends BaseComponent {
        constructor(element, config) {
          super(element, config);
          this._timeout = null;
          this._hasMouseInteraction = false;
          this._hasKeyboardInteraction = false;
    
          this._setListeners();
        } // Getters
    
    
        static get Default() {
          return Default;
        }
    
        static get DefaultType() {
          return DefaultType;
        }
    
        static get NAME() {
          return NAME;
        } // Public
    
    
        show() {
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    
          if (showEvent.defaultPrevented) {
            return;
          }
    
          this._clearTimeout();
    
          if (this._config.animation) {
            this._element.classList.add(CLASS_NAME_FADE);
          }
    
          const complete = () => {
            this._element.classList.remove(CLASS_NAME_SHOWING);
    
            EventHandler.trigger(this._element, EVENT_SHOWN);
    
            this._maybeScheduleHide();
          };
    
          this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
    
    
          reflow(this._element);
    
          this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    
          this._queueCallback(complete, this._element, this._config.animation);
        }
    
        hide() {
          if (!this.isShown()) {
            return;
          }
    
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    
          if (hideEvent.defaultPrevented) {
            return;
          }
    
          const complete = () => {
            this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
    
    
            this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
    
            EventHandler.trigger(this._element, EVENT_HIDDEN);
          };
    
          this._element.classList.add(CLASS_NAME_SHOWING);
    
          this._queueCallback(complete, this._element, this._config.animation);
        }
    
        dispose() {
          this._clearTimeout();
    
          if (this.isShown()) {
            this._element.classList.remove(CLASS_NAME_SHOW);
          }
    
          super.dispose();
        }
    
        isShown() {
          return this._element.classList.contains(CLASS_NAME_SHOW);
        } // Private
    
    
        _maybeScheduleHide() {
          if (!this._config.autohide) {
            return;
          }
    
          if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
            return;
          }
    
          this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay);
        }
    
        _onInteraction(event, isInteracting) {
          switch (event.type) {
            case 'mouseover':
            case 'mouseout':
              {
                this._hasMouseInteraction = isInteracting;
                break;
              }
    
            case 'focusin':
            case 'focusout':
              {
                this._hasKeyboardInteraction = isInteracting;
                break;
              }
          }
    
          if (isInteracting) {
            this._clearTimeout();
    
            return;
          }
    
          const nextElement = event.relatedTarget;
    
          if (this._element === nextElement || this._element.contains(nextElement)) {
            return;
          }
    
          this._maybeScheduleHide();
        }
    
        _setListeners() {
          EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
          EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
          EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
          EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
        }
    
        _clearTimeout() {
          clearTimeout(this._timeout);
          this._timeout = null;
        } // Static
    
    
        static jQueryInterface(config) {
          return this.each(function () {
            const data = Toast.getOrCreateInstance(this, config);
    
            if (typeof config === 'string') {
              if (typeof data[config] === 'undefined') {
                throw new TypeError(`No method named "${config}"`);
              }
    
              data[config](this);
            }
          });
        }
    
      }
      /**
       * Data API implementation
       */
    
    
      enableDismissTrigger(Toast);
      /**
       * jQuery
       */
    
      defineJQueryPlugin(Toast);
    
      /**
       * --------------------------------------------------------------------------
       * Bootstrap (v5.2.3): index.umd.js
       * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
       * --------------------------------------------------------------------------
       */
      const index_umd = {
        Alert,
        Button,
        Carousel,
        Collapse,
        Dropdown,
        Modal,
        Offcanvas,
        Popover,
        ScrollSpy,
        Tab,
        Toast,
        Tooltip
      };
    
      return index_umd;
    
    }));
    
    
    },{"@popperjs/core":1}],4:[function(require,module,exports){
    /**
     * matchesSelector v2.0.2
     * matchesSelector( element, '.selector' )
     * MIT license
     */
    
    /*jshint browser: true, strict: true, undef: true, unused: true */
    
    ( function( window, factory ) {
      /*global define: false, module: false */
      'use strict';
      // universal module definition
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.matchesSelector = factory();
      }
    
    }( window, function factory() {
      'use strict';
    
      var matchesMethod = ( function() {
        var ElemProto = window.Element.prototype;
        // check for the standard method name first
        if ( ElemProto.matches ) {
          return 'matches';
        }
        // check un-prefixed
        if ( ElemProto.matchesSelector ) {
          return 'matchesSelector';
        }
        // check vendor prefixes
        var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];
    
        for ( var i=0; i < prefixes.length; i++ ) {
          var prefix = prefixes[i];
          var method = prefix + 'MatchesSelector';
          if ( ElemProto[ method ] ) {
            return method;
          }
        }
      })();
    
      return function matchesSelector( elem, selector ) {
        return elem[ matchesMethod ]( selector );
      };
    
    }));
    
    },{}],5:[function(require,module,exports){
    /**
     * EvEmitter v2.1.1
     * Lil' event emitter
     * MIT License
     */
    
    ( function( global, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS - Browserify, Webpack
        module.exports = factory();
      } else {
        // Browser globals
        global.EvEmitter = factory();
      }
    
    }( typeof window != 'undefined' ? window : this, function() {
    
    function EvEmitter() {}
    
    let proto = EvEmitter.prototype;
    
    proto.on = function( eventName, listener ) {
      if ( !eventName || !listener ) return this;
    
      // set events hash
      let events = this._events = this._events || {};
      // set listeners array
      let listeners = events[ eventName ] = events[ eventName ] || [];
      // only add once
      if ( !listeners.includes( listener ) ) {
        listeners.push( listener );
      }
    
      return this;
    };
    
    proto.once = function( eventName, listener ) {
      if ( !eventName || !listener ) return this;
    
      // add event
      this.on( eventName, listener );
      // set once flag
      // set onceEvents hash
      let onceEvents = this._onceEvents = this._onceEvents || {};
      // set onceListeners object
      let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
      // set flag
      onceListeners[ listener ] = true;
    
      return this;
    };
    
    proto.off = function( eventName, listener ) {
      let listeners = this._events && this._events[ eventName ];
      if ( !listeners || !listeners.length ) return this;
    
      let index = listeners.indexOf( listener );
      if ( index != -1 ) {
        listeners.splice( index, 1 );
      }
    
      return this;
    };
    
    proto.emitEvent = function( eventName, args ) {
      let listeners = this._events && this._events[ eventName ];
      if ( !listeners || !listeners.length ) return this;
    
      // copy over to avoid interference if .off() in listener
      listeners = listeners.slice( 0 );
      args = args || [];
      // once stuff
      let onceListeners = this._onceEvents && this._onceEvents[ eventName ];
    
      for ( let listener of listeners ) {
        let isOnce = onceListeners && onceListeners[ listener ];
        if ( isOnce ) {
          // remove listener
          // remove before trigger to prevent recursion
          this.off( eventName, listener );
          // unset once flag
          delete onceListeners[ listener ];
        }
        // trigger listener
        listener.apply( this, args );
      }
    
      return this;
    };
    
    proto.allOff = function() {
      delete this._events;
      delete this._onceEvents;
      return this;
    };
    
    return EvEmitter;
    
    } ) );
    
    },{}],6:[function(require,module,exports){
    /**
     * Fizzy UI utils v3.0.0
     * MIT license
     */
    
    ( function( global, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory( global );
      } else {
        // browser global
        global.fizzyUIUtils = factory( global );
      }
    
    }( this, function factory( global ) {
    
    let utils = {};
    
    // ----- extend ----- //
    
    // extends objects
    utils.extend = function( a, b ) {
      return Object.assign( a, b );
    };
    
    // ----- modulo ----- //
    
    utils.modulo = function( num, div ) {
      return ( ( num % div ) + div ) % div;
    };
    
    // ----- makeArray ----- //
    
    // turn element or nodeList into an array
    utils.makeArray = function( obj ) {
      // use object if already an array
      if ( Array.isArray( obj ) ) return obj;
    
      // return empty array if undefined or null. #6
      if ( obj === null || obj === undefined ) return [];
    
      let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
      // convert nodeList to array
      if ( isArrayLike ) return [ ...obj ];
    
      // array of single index
      return [ obj ];
    };
    
    // ----- removeFrom ----- //
    
    utils.removeFrom = function( ary, obj ) {
      let index = ary.indexOf( obj );
      if ( index != -1 ) {
        ary.splice( index, 1 );
      }
    };
    
    // ----- getParent ----- //
    
    utils.getParent = function( elem, selector ) {
      while ( elem.parentNode && elem != document.body ) {
        elem = elem.parentNode;
        if ( elem.matches( selector ) ) return elem;
      }
    };
    
    // ----- getQueryElement ----- //
    
    // use element as selector string
    utils.getQueryElement = function( elem ) {
      if ( typeof elem == 'string' ) {
        return document.querySelector( elem );
      }
      return elem;
    };
    
    // ----- handleEvent ----- //
    
    // enable .ontype to trigger from .addEventListener( elem, 'type' )
    utils.handleEvent = function( event ) {
      let method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };
    
    // ----- filterFindElements ----- //
    
    utils.filterFindElements = function( elems, selector ) {
      // make array of elems
      elems = utils.makeArray( elems );
    
      return elems
        // check that elem is an actual element
        .filter( ( elem ) => elem instanceof HTMLElement )
        .reduce( ( ffElems, elem ) => {
          // add elem if no selector
          if ( !selector ) {
            ffElems.push( elem );
            return ffElems;
          }
          // filter & find items if we have a selector
          // filter
          if ( elem.matches( selector ) ) {
            ffElems.push( elem );
          }
          // find children
          let childElems = elem.querySelectorAll( selector );
          // concat childElems to filterFound array
          ffElems = ffElems.concat( ...childElems );
          return ffElems;
        }, [] );
    };
    
    // ----- debounceMethod ----- //
    
    utils.debounceMethod = function( _class, methodName, threshold ) {
      threshold = threshold || 100;
      // original method
      let method = _class.prototype[ methodName ];
      let timeoutName = methodName + 'Timeout';
    
      _class.prototype[ methodName ] = function() {
        clearTimeout( this[ timeoutName ] );
    
        let args = arguments;
        this[ timeoutName ] = setTimeout( () => {
          method.apply( this, args );
          delete this[ timeoutName ];
        }, threshold );
      };
    };
    
    // ----- docReady ----- //
    
    utils.docReady = function( onDocReady ) {
      let readyState = document.readyState;
      if ( readyState == 'complete' || readyState == 'interactive' ) {
        // do async to allow for other scripts to run. metafizzy/flickity#441
        setTimeout( onDocReady );
      } else {
        document.addEventListener( 'DOMContentLoaded', onDocReady );
      }
    };
    
    // ----- htmlInit ----- //
    
    // http://bit.ly/3oYLusc
    utils.toDashed = function( str ) {
      return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
        return $1 + '-' + $2;
      } ).toLowerCase();
    };
    
    let console = global.console;
    
    // allow user to initialize classes via [data-namespace] or .js-namespace class
    // htmlInit( Widget, 'widgetName' )
    // options are parsed from data-namespace-options
    utils.htmlInit = function( WidgetClass, namespace ) {
      utils.docReady( function() {
        let dashedNamespace = utils.toDashed( namespace );
        let dataAttr = 'data-' + dashedNamespace;
        let dataAttrElems = document.querySelectorAll( `[${dataAttr}]` );
        let jQuery = global.jQuery;
    
        [ ...dataAttrElems ].forEach( ( elem ) => {
          let attr = elem.getAttribute( dataAttr );
          let options;
          try {
            options = attr && JSON.parse( attr );
          } catch ( error ) {
            // log error, do not initialize
            if ( console ) {
              console.error( `Error parsing ${dataAttr} on ${elem.className}: ${error}` );
            }
            return;
          }
          // initialize
          let instance = new WidgetClass( elem, options );
          // make available via $().data('namespace')
          if ( jQuery ) {
            jQuery.data( elem, namespace, instance );
          }
        } );
    
      } );
    };
    
    // -----  ----- //
    
    return utils;
    
    } ) );
    
    },{}],7:[function(require,module,exports){
    // add, remove cell
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            require('./core'),
            require('fizzy-ui-utils'),
        );
      } else {
        // browser global
        factory(
            window.Flickity,
            window.fizzyUIUtils,
        );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( Flickity, utils ) {
    
    // append cells to a document fragment
    function getCellsFragment( cells ) {
      let fragment = document.createDocumentFragment();
      cells.forEach( ( cell ) => fragment.appendChild( cell.element ) );
      return fragment;
    }
    
    // -------------------------- add/remove cell prototype -------------------------- //
    
    let proto = Flickity.prototype;
    
    /**
     * Insert, prepend, or append cells
     * @param {[Element, Array, NodeList]} elems - Elements to insert
     * @param {Integer} index - Zero-based number to insert
     */
    proto.insert = function( elems, index ) {
      let cells = this._makeCells( elems );
      if ( !cells || !cells.length ) return;
    
      let len = this.cells.length;
      // default to append
      index = index === undefined ? len : index;
      // add cells with document fragment
      let fragment = getCellsFragment( cells );
      // append to slider
      let isAppend = index === len;
      if ( isAppend ) {
        this.slider.appendChild( fragment );
      } else {
        let insertCellElement = this.cells[ index ].element;
        this.slider.insertBefore( fragment, insertCellElement );
      }
      // add to this.cells
      if ( index === 0 ) {
        // prepend, add to start
        this.cells = cells.concat( this.cells );
      } else if ( isAppend ) {
        // append, add to end
        this.cells = this.cells.concat( cells );
      } else {
        // insert in this.cells
        let endCells = this.cells.splice( index, len - index );
        this.cells = this.cells.concat( cells ).concat( endCells );
      }
    
      this._sizeCells( cells );
      this.cellChange( index );
      this.positionSliderAtSelected();
    };
    
    proto.append = function( elems ) {
      this.insert( elems, this.cells.length );
    };
    
    proto.prepend = function( elems ) {
      this.insert( elems, 0 );
    };
    
    /**
     * Remove cells
     * @param {[Element, Array, NodeList]} elems - ELements to remove
     */
    proto.remove = function( elems ) {
      let cells = this.getCells( elems );
      if ( !cells || !cells.length ) return;
    
      let minCellIndex = this.cells.length - 1;
      // remove cells from collection & DOM
      cells.forEach( ( cell ) => {
        cell.remove();
        let index = this.cells.indexOf( cell );
        minCellIndex = Math.min( index, minCellIndex );
        utils.removeFrom( this.cells, cell );
      } );
    
      this.cellChange( minCellIndex );
      this.positionSliderAtSelected();
    };
    
    /**
     * logic to be run after a cell's size changes
     * @param {Element} elem - cell's element
     */
    proto.cellSizeChange = function( elem ) {
      let cell = this.getCell( elem );
      if ( !cell ) return;
    
      cell.getSize();
    
      let index = this.cells.indexOf( cell );
      this.cellChange( index );
      // do not position slider after lazy load
    };
    
    /**
     * logic any time a cell is changed: added, removed, or size changed
     * @param {Integer} changedCellIndex - index of the changed cell, optional
     */
    proto.cellChange = function( changedCellIndex ) {
      let prevSelectedElem = this.selectedElement;
      this._positionCells( changedCellIndex );
      this._updateWrapShiftCells();
      this.setGallerySize();
      // update selectedIndex, try to maintain position & select previous selected element
      let cell = this.getCell( prevSelectedElem );
      if ( cell ) this.selectedIndex = this.getCellSlideIndex( cell );
      this.selectedIndex = Math.min( this.slides.length - 1, this.selectedIndex );
    
      this.emitEvent( 'cellChange', [ changedCellIndex ] );
      // position slider
      this.select( this.selectedIndex );
    };
    
    // -----  ----- //
    
    return Flickity;
    
    } ) );
    
    },{"./core":10,"fizzy-ui-utils":6}],8:[function(require,module,exports){
    // animate
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory( require('fizzy-ui-utils') );
      } else {
        // browser global
        window.Flickity = window.Flickity || {};
        window.Flickity.animatePrototype = factory( window.fizzyUIUtils );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( utils ) {
    
    // -------------------------- animate -------------------------- //
    
    let proto = {};
    
    proto.startAnimation = function() {
      if ( this.isAnimating ) return;
    
      this.isAnimating = true;
      this.restingFrames = 0;
      this.animate();
    };
    
    proto.animate = function() {
      this.applyDragForce();
      this.applySelectedAttraction();
    
      let previousX = this.x;
    
      this.integratePhysics();
      this.positionSlider();
      this.settle( previousX );
      // animate next frame
      if ( this.isAnimating ) requestAnimationFrame( () => this.animate() );
    };
    
    proto.positionSlider = function() {
      let x = this.x;
      // wrap position around
      if ( this.isWrapping ) {
        x = utils.modulo( x, this.slideableWidth ) - this.slideableWidth;
        this.shiftWrapCells( x );
      }
    
      this.setTranslateX( x, this.isAnimating );
      this.dispatchScrollEvent();
    };
    
    proto.setTranslateX = function( x, is3d ) {
      x += this.cursorPosition;
      // reverse if right-to-left and using transform
      if ( this.options.rightToLeft ) x = -x;
      let translateX = this.getPositionValue( x );
      // use 3D transforms for hardware acceleration on iOS
      // but use 2D when settled, for better font-rendering
      this.slider.style.transform = is3d ?
        `translate3d(${translateX},0,0)` : `translateX(${translateX})`;
    };
    
    proto.dispatchScrollEvent = function() {
      let firstSlide = this.slides[0];
      if ( !firstSlide ) return;
    
      let positionX = -this.x - firstSlide.target;
      let progress = positionX / this.slidesWidth;
      this.dispatchEvent( 'scroll', null, [ progress, positionX ] );
    };
    
    proto.positionSliderAtSelected = function() {
      if ( !this.cells.length ) return;
    
      this.x = -this.selectedSlide.target;
      this.velocity = 0; // stop wobble
      this.positionSlider();
    };
    
    proto.getPositionValue = function( position ) {
      if ( this.options.percentPosition ) {
        // percent position, round to 2 digits, like 12.34%
        return ( Math.round( ( position / this.size.innerWidth ) * 10000 ) * 0.01 ) + '%';
      } else {
        // pixel positioning
        return Math.round( position ) + 'px';
      }
    };
    
    proto.settle = function( previousX ) {
      // keep track of frames where x hasn't moved
      let isResting = !this.isPointerDown &&
          Math.round( this.x * 100 ) === Math.round( previousX * 100 );
      if ( isResting ) this.restingFrames++;
      // stop animating if resting for 3 or more frames
      if ( this.restingFrames > 2 ) {
        this.isAnimating = false;
        delete this.isFreeScrolling;
        // render position with translateX when settled
        this.positionSlider();
        this.dispatchEvent( 'settle', null, [ this.selectedIndex ] );
      }
    };
    
    proto.shiftWrapCells = function( x ) {
      // shift before cells
      let beforeGap = this.cursorPosition + x;
      this._shiftCells( this.beforeShiftCells, beforeGap, -1 );
      // shift after cells
      let afterGap = this.size.innerWidth - ( x + this.slideableWidth + this.cursorPosition );
      this._shiftCells( this.afterShiftCells, afterGap, 1 );
    };
    
    proto._shiftCells = function( cells, gap, shift ) {
      cells.forEach( ( cell ) => {
        let cellShift = gap > 0 ? shift : 0;
        this._wrapShiftCell( cell, cellShift );
        gap -= cell.size.outerWidth;
      } );
    };
    
    proto._unshiftCells = function( cells ) {
      if ( !cells || !cells.length ) return;
    
      cells.forEach( ( cell ) => this._wrapShiftCell( cell, 0 ) );
    };
    
    // @param {Integer} shift - 0, 1, or -1
    proto._wrapShiftCell = function( cell, shift ) {
      this._renderCellPosition( cell, cell.x + this.slideableWidth * shift );
    };
    
    // -------------------------- physics -------------------------- //
    
    proto.integratePhysics = function() {
      this.x += this.velocity;
      this.velocity *= this.getFrictionFactor();
    };
    
    proto.applyForce = function( force ) {
      this.velocity += force;
    };
    
    proto.getFrictionFactor = function() {
      return 1 - this.options[ this.isFreeScrolling ? 'freeScrollFriction' : 'friction' ];
    };
    
    proto.getRestingPosition = function() {
      // my thanks to Steven Wittens, who simplified this math greatly
      return this.x + this.velocity / ( 1 - this.getFrictionFactor() );
    };
    
    proto.applyDragForce = function() {
      if ( !this.isDraggable || !this.isPointerDown ) return;
    
      // change the position to drag position by applying force
      let dragVelocity = this.dragX - this.x;
      let dragForce = dragVelocity - this.velocity;
      this.applyForce( dragForce );
    };
    
    proto.applySelectedAttraction = function() {
      // do not attract if pointer down or no slides
      let dragDown = this.isDraggable && this.isPointerDown;
      if ( dragDown || this.isFreeScrolling || !this.slides.length ) return;
    
      let distance = this.selectedSlide.target * -1 - this.x;
      let force = distance * this.options.selectedAttraction;
      this.applyForce( force );
    };
    
    return proto;
    
    } ) );
    
    },{"fizzy-ui-utils":6}],9:[function(require,module,exports){
    // Flickity.Cell
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory( require('get-size') );
      } else {
        // browser global
        window.Flickity = window.Flickity || {};
        window.Flickity.Cell = factory( window.getSize );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( getSize ) {
    
    const cellClassName = 'flickity-cell';
    
    function Cell( elem ) {
      this.element = elem;
      this.element.classList.add( cellClassName );
    
      this.x = 0;
      this.unselect();
    }
    
    let proto = Cell.prototype;
    
    proto.destroy = function() {
      // reset style
      this.unselect();
      this.element.classList.remove( cellClassName );
      this.element.style.transform = '';
      this.element.removeAttribute('aria-hidden');
    };
    
    proto.getSize = function() {
      this.size = getSize( this.element );
    };
    
    proto.select = function() {
      this.element.classList.add('is-selected');
      this.element.removeAttribute('aria-hidden');
    };
    
    proto.unselect = function() {
      this.element.classList.remove('is-selected');
      this.element.setAttribute( 'aria-hidden', 'true' );
    };
    
    proto.remove = function() {
      this.element.remove();
    };
    
    return Cell;
    
    } ) );
    
    },{"get-size":19}],10:[function(require,module,exports){
    // Flickity main
    /* eslint-disable max-params */
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            window,
            require('ev-emitter'),
            require('get-size'),
            require('fizzy-ui-utils'),
            require('./cell'),
            require('./slide'),
            require('./animate'),
        );
      } else {
        // browser global
        let _Flickity = window.Flickity;
    
        window.Flickity = factory(
            window,
            window.EvEmitter,
            window.getSize,
            window.fizzyUIUtils,
            _Flickity.Cell,
            _Flickity.Slide,
            _Flickity.animatePrototype,
        );
      }
    
    }( typeof window != 'undefined' ? window : this,
        function factory( window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype ) {
    /* eslint-enable max-params */
    
    // vars
    const { getComputedStyle, console } = window;
    let { jQuery } = window;
    
    // -------------------------- Flickity -------------------------- //
    
    // globally unique identifiers
    let GUID = 0;
    // internal store of all Flickity intances
    let instances = {};
    
    function Flickity( element, options ) {
      let queryElement = utils.getQueryElement( element );
      if ( !queryElement ) {
        if ( console ) console.error(`Bad element for Flickity: ${queryElement || element}`);
        return;
      }
      this.element = queryElement;
      // do not initialize twice on same element
      if ( this.element.flickityGUID ) {
        let instance = instances[ this.element.flickityGUID ];
        if ( instance ) instance.option( options );
        return instance;
      }
    
      // add jQuery
      if ( jQuery ) {
        this.$element = jQuery( this.element );
      }
      // options
      this.options = { ...this.constructor.defaults };
      this.option( options );
    
      // kick things off
      this._create();
    }
    
    Flickity.defaults = {
      accessibility: true,
      // adaptiveHeight: false,
      cellAlign: 'center',
      // cellSelector: undefined,
      // contain: false,
      freeScrollFriction: 0.075, // friction when free-scrolling
      friction: 0.28, // friction when selecting
      namespaceJQueryEvents: true,
      // initialIndex: 0,
      percentPosition: true,
      resize: true,
      selectedAttraction: 0.025,
      setGallerySize: true,
      // watchCSS: false,
      // wrapAround: false
    };
    
    // hash of methods triggered on _create()
    Flickity.create = {};
    
    let proto = Flickity.prototype;
    // inherit EventEmitter
    Object.assign( proto, EvEmitter.prototype );
    
    proto._create = function() {
      let { resize, watchCSS, rightToLeft } = this.options;
      // add id for Flickity.data
      let id = this.guid = ++GUID;
      this.element.flickityGUID = id; // expando
      instances[ id ] = this; // associate via id
      // initial properties
      this.selectedIndex = 0;
      // how many frames slider has been in same position
      this.restingFrames = 0;
      // initial physics properties
      this.x = 0;
      this.velocity = 0;
      this.beginMargin = rightToLeft ? 'marginRight' : 'marginLeft';
      this.endMargin = rightToLeft ? 'marginLeft' : 'marginRight';
      // create viewport & slider
      this.viewport = document.createElement('div');
      this.viewport.className = 'flickity-viewport';
      this._createSlider();
      // used for keyboard navigation
      this.focusableElems = [ this.element ];
    
      if ( resize || watchCSS ) {
        window.addEventListener( 'resize', this );
      }
    
      // add listeners from on option
      for ( let eventName in this.options.on ) {
        let listener = this.options.on[ eventName ];
        this.on( eventName, listener );
      }
    
      for ( let method in Flickity.create ) {
        Flickity.create[ method ].call( this );
      }
    
      if ( watchCSS ) {
        this.watchCSS();
      } else {
        this.activate();
      }
    };
    
    /**
     * set options
     * @param {Object} opts - options to extend
     */
    proto.option = function( opts ) {
      Object.assign( this.options, opts );
    };
    
    proto.activate = function() {
      if ( this.isActive ) return;
    
      this.isActive = true;
      this.element.classList.add('flickity-enabled');
      if ( this.options.rightToLeft ) {
        this.element.classList.add('flickity-rtl');
      }
    
      this.getSize();
      // move initial cell elements so they can be loaded as cells
      let cellElems = this._filterFindCellElements( this.element.children );
      this.slider.append( ...cellElems );
      this.viewport.append( this.slider );
      this.element.append( this.viewport );
      // get cells from children
      this.reloadCells();
    
      if ( this.options.accessibility ) {
        // allow element to focusable
        this.element.tabIndex = 0;
        // listen for key presses
        this.element.addEventListener( 'keydown', this );
      }
    
      this.emitEvent('activate');
      this.selectInitialIndex();
      // flag for initial activation, for using initialIndex
      this.isInitActivated = true;
      // ready event. #493
      this.dispatchEvent('ready');
    };
    
    // slider positions the cells
    proto._createSlider = function() {
      // slider element does all the positioning
      let slider = document.createElement('div');
      slider.className = 'flickity-slider';
      this.slider = slider;
    };
    
    proto._filterFindCellElements = function( elems ) {
      return utils.filterFindElements( elems, this.options.cellSelector );
    };
    
    // goes through all children
    proto.reloadCells = function() {
      // collection of item elements
      this.cells = this._makeCells( this.slider.children );
      this.positionCells();
      this._updateWrapShiftCells();
      this.setGallerySize();
    };
    
    /**
     * turn elements into Flickity.Cells
     * @param {[Array, NodeList, HTMLElement]} elems - elements to make into cells
     * @returns {Array} items - collection of new Flickity Cells
     */
    proto._makeCells = function( elems ) {
      let cellElems = this._filterFindCellElements( elems );
    
      // create new Cells for collection
      return cellElems.map( ( cellElem ) => new Cell( cellElem ) );
    };
    
    proto.getLastCell = function() {
      return this.cells[ this.cells.length - 1 ];
    };
    
    proto.getLastSlide = function() {
      return this.slides[ this.slides.length - 1 ];
    };
    
    // positions all cells
    proto.positionCells = function() {
      // size all cells
      this._sizeCells( this.cells );
      // position all cells
      this._positionCells( 0 );
    };
    
    /**
     * position certain cells
     * @param {Integer} index - which cell to start with
     */
    proto._positionCells = function( index ) {
      index = index || 0;
      // also measure maxCellHeight
      // start 0 if positioning all cells
      this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
      let cellX = 0;
      // get cellX
      if ( index > 0 ) {
        let startCell = this.cells[ index - 1 ];
        cellX = startCell.x + startCell.size.outerWidth;
      }
    
      this.cells.slice( index ).forEach( ( cell ) => {
        cell.x = cellX;
        this._renderCellPosition( cell, cellX );
        cellX += cell.size.outerWidth;
        this.maxCellHeight = Math.max( cell.size.outerHeight, this.maxCellHeight );
      } );
      // keep track of cellX for wrap-around
      this.slideableWidth = cellX;
      // slides
      this.updateSlides();
      // contain slides target
      this._containSlides();
      // update slidesWidth
      this.slidesWidth = this.cells.length ?
        this.getLastSlide().target - this.slides[0].target : 0;
    };
    
    proto._renderCellPosition = function( cell, x ) {
      // render position of cell with in slider
      let sideOffset = this.options.rightToLeft ? -1 : 1;
      let renderX = x * sideOffset;
      if ( this.options.percentPosition ) renderX *= this.size.innerWidth / cell.size.width;
      let positionValue = this.getPositionValue( renderX );
      cell.element.style.transform = `translateX( ${positionValue} )`;
    };
    
    /**
     * cell.getSize() on multiple cells
     * @param {Array} cells - cells to size
     */
    proto._sizeCells = function( cells ) {
      cells.forEach( ( cell ) => cell.getSize() );
    };
    
    // --------------------------  -------------------------- //
    
    proto.updateSlides = function() {
      this.slides = [];
      if ( !this.cells.length ) return;
    
      let { beginMargin, endMargin } = this;
      let slide = new Slide( beginMargin, endMargin, this.cellAlign );
      this.slides.push( slide );
    
      let canCellFit = this._getCanCellFit();
    
      this.cells.forEach( ( cell, i ) => {
        // just add cell if first cell in slide
        if ( !slide.cells.length ) {
          slide.addCell( cell );
          return;
        }
    
        let slideWidth = ( slide.outerWidth - slide.firstMargin ) +
          ( cell.size.outerWidth - cell.size[ endMargin ] );
    
        if ( canCellFit( i, slideWidth ) ) {
          slide.addCell( cell );
        } else {
          // doesn't fit, new slide
          slide.updateTarget();
    
          slide = new Slide( beginMargin, endMargin, this.cellAlign );
          this.slides.push( slide );
          slide.addCell( cell );
        }
      } );
      // last slide
      slide.updateTarget();
      // update .selectedSlide
      this.updateSelectedSlide();
    };
    
    proto._getCanCellFit = function() {
      let { groupCells } = this.options;
      if ( !groupCells ) return () => false;
    
      if ( typeof groupCells == 'number' ) {
        // group by number. 3 -> [0,1,2], [3,4,5], ...
        let number = parseInt( groupCells, 10 );
        return ( i ) => ( i % number ) !== 0;
      }
      // default, group by width of slide
      let percent = 1;
      // parse '75%
      let percentMatch = typeof groupCells == 'string' && groupCells.match( /^(\d+)%$/ );
      if ( percentMatch ) percent = parseInt( percentMatch[1], 10 ) / 100;
      let groupWidth = ( this.size.innerWidth + 1 ) * percent;
      return ( i, slideWidth ) => slideWidth <= groupWidth;
    };
    
    // alias _init for jQuery plugin .flickity()
    proto._init =
    proto.reposition = function() {
      this.positionCells();
      this.positionSliderAtSelected();
    };
    
    proto.getSize = function() {
      this.size = getSize( this.element );
      this.setCellAlign();
      this.cursorPosition = this.size.innerWidth * this.cellAlign;
    };
    
    let cellAlignShorthands = {
      left: 0,
      center: 0.5,
      right: 1,
    };
    
    proto.setCellAlign = function() {
      let { cellAlign, rightToLeft } = this.options;
      let shorthand = cellAlignShorthands[ cellAlign ];
      this.cellAlign = shorthand !== undefined ? shorthand : cellAlign;
      if ( rightToLeft ) this.cellAlign = 1 - this.cellAlign;
    };
    
    proto.setGallerySize = function() {
      if ( !this.options.setGallerySize ) return;
    
      let height = this.options.adaptiveHeight && this.selectedSlide ?
        this.selectedSlide.height : this.maxCellHeight;
      this.viewport.style.height = `${height}px`;
    };
    
    proto._updateWrapShiftCells = function() {
      // update isWrapping
      this.isWrapping = this.getIsWrapping();
      // only for wrap-around
      if ( !this.isWrapping ) return;
    
      // unshift previous cells
      this._unshiftCells( this.beforeShiftCells );
      this._unshiftCells( this.afterShiftCells );
      // get before cells
      // initial gap
      let beforeGapX = this.cursorPosition;
      let lastIndex = this.cells.length - 1;
      this.beforeShiftCells = this._getGapCells( beforeGapX, lastIndex, -1 );
      // get after cells
      // ending gap between last cell and end of gallery viewport
      let afterGapX = this.size.innerWidth - this.cursorPosition;
      // start cloning at first cell, working forwards
      this.afterShiftCells = this._getGapCells( afterGapX, 0, 1 );
    };
    
    proto.getIsWrapping = function() {
      let { wrapAround } = this.options;
      if ( !wrapAround || this.slides.length < 2 ) return false;
    
      if ( wrapAround !== 'fill' ) return true;
      // check that slides can fit
    
      let gapWidth = this.slideableWidth - this.size.innerWidth;
      if ( gapWidth > this.size.innerWidth ) return true; // gap * 2x big, all good
      // check that content width - shifting cell is bigger than viewport width
      for ( let cell of this.cells ) {
        if ( cell.size.outerWidth > gapWidth ) return false;
      }
      return true;
    };
    
    proto._getGapCells = function( gapX, cellIndex, increment ) {
      // keep adding cells until the cover the initial gap
      let cells = [];
      while ( gapX > 0 ) {
        let cell = this.cells[ cellIndex ];
        if ( !cell ) break;
    
        cells.push( cell );
        cellIndex += increment;
        gapX -= cell.size.outerWidth;
      }
      return cells;
    };
    
    // ----- contain & wrap ----- //
    
    // contain cell targets so no excess sliding
    proto._containSlides = function() {
      let isContaining = this.options.contain && !this.isWrapping &&
          this.cells.length;
      if ( !isContaining ) return;
    
      let contentWidth = this.slideableWidth - this.getLastCell().size[ this.endMargin ];
      // content is less than gallery size
      let isContentSmaller = contentWidth < this.size.innerWidth;
      if ( isContentSmaller ) {
        // all cells fit inside gallery
        this.slides.forEach( ( slide ) => {
          slide.target = contentWidth * this.cellAlign;
        } );
      } else {
        // contain to bounds
        let beginBound = this.cursorPosition + this.cells[0].size[ this.beginMargin ];
        let endBound = contentWidth - this.size.innerWidth * ( 1 - this.cellAlign );
        this.slides.forEach( ( slide ) => {
          slide.target = Math.max( slide.target, beginBound );
          slide.target = Math.min( slide.target, endBound );
        } );
      }
    };
    
    // ----- events ----- //
    
    /**
     * emits events via eventEmitter and jQuery events
     * @param {String} type - name of event
     * @param {Event} event - original event
     * @param {Array} args - extra arguments
     */
    proto.dispatchEvent = function( type, event, args ) {
      let emitArgs = event ? [ event ].concat( args ) : args;
      this.emitEvent( type, emitArgs );
    
      if ( jQuery && this.$element ) {
        // default trigger with type if no event
        type += this.options.namespaceJQueryEvents ? '.flickity' : '';
        let $event = type;
        if ( event ) {
          // create jQuery event
          let jQEvent = new jQuery.Event( event );
          jQEvent.type = type;
          $event = jQEvent;
        }
        this.$element.trigger( $event, args );
      }
    };
    
    const unidraggerEvents = [
      'dragStart',
      'dragMove',
      'dragEnd',
      'pointerDown',
      'pointerMove',
      'pointerEnd',
      'staticClick',
    ];
    
    let _emitEvent = proto.emitEvent;
    proto.emitEvent = function( eventName, args ) {
      if ( eventName === 'staticClick' ) {
        // add cellElem and cellIndex args to staticClick
        let clickedCell = this.getParentCell( args[0].target );
        let cellElem = clickedCell && clickedCell.element;
        let cellIndex = clickedCell && this.cells.indexOf( clickedCell );
        args = args.concat( cellElem, cellIndex );
      }
      // do regular thing
      _emitEvent.call( this, eventName, args );
      // duck-punch in jQuery events for Unidragger events
      let isUnidraggerEvent = unidraggerEvents.includes( eventName );
      if ( !isUnidraggerEvent || !jQuery || !this.$element ) return;
    
      eventName += this.options.namespaceJQueryEvents ? '.flickity' : '';
      let event = args.shift( 0 );
      let jQEvent = new jQuery.Event( event );
      jQEvent.type = eventName;
      this.$element.trigger( jQEvent, args );
    };
    
    // -------------------------- select -------------------------- //
    
    /**
     * @param {Integer} index - index of the slide
     * @param {Boolean} isWrap - will wrap-around to last/first if at the end
     * @param {Boolean} isInstant - will immediately set position at selected cell
     */
    proto.select = function( index, isWrap, isInstant ) {
      if ( !this.isActive ) return;
    
      index = parseInt( index, 10 );
      this._wrapSelect( index );
    
      if ( this.isWrapping || isWrap ) {
        index = utils.modulo( index, this.slides.length );
      }
      // bail if invalid index
      if ( !this.slides[ index ] ) return;
    
      let prevIndex = this.selectedIndex;
      this.selectedIndex = index;
      this.updateSelectedSlide();
      if ( isInstant ) {
        this.positionSliderAtSelected();
      } else {
        this.startAnimation();
      }
      if ( this.options.adaptiveHeight ) {
        this.setGallerySize();
      }
      // events
      this.dispatchEvent( 'select', null, [ index ] );
      // change event if new index
      if ( index !== prevIndex ) {
        this.dispatchEvent( 'change', null, [ index ] );
      }
    };
    
    // wraps position for wrapAround, to move to closest slide. #113
    proto._wrapSelect = function( index ) {
      if ( !this.isWrapping ) return;
    
      const { selectedIndex, slideableWidth, slides: { length } } = this;
      // shift index for wrap, do not wrap dragSelect
      if ( !this.isDragSelect ) {
        let wrapIndex = utils.modulo( index, length );
        // go to shortest
        let delta = Math.abs( wrapIndex - selectedIndex );
        let backWrapDelta = Math.abs( ( wrapIndex + length ) - selectedIndex );
        let forewardWrapDelta = Math.abs( ( wrapIndex - length ) - selectedIndex );
        if ( backWrapDelta < delta ) {
          index += length;
        } else if ( forewardWrapDelta < delta ) {
          index -= length;
        }
      }
    
      // wrap position so slider is within normal area
      if ( index < 0 ) {
        this.x -= slideableWidth;
      } else if ( index >= length ) {
        this.x += slideableWidth;
      }
    };
    
    proto.previous = function( isWrap, isInstant ) {
      this.select( this.selectedIndex - 1, isWrap, isInstant );
    };
    
    proto.next = function( isWrap, isInstant ) {
      this.select( this.selectedIndex + 1, isWrap, isInstant );
    };
    
    proto.updateSelectedSlide = function() {
      let slide = this.slides[ this.selectedIndex ];
      // selectedIndex could be outside of slides, if triggered before resize()
      if ( !slide ) return;
    
      // unselect previous selected slide
      this.unselectSelectedSlide();
      // update new selected slide
      this.selectedSlide = slide;
      slide.select();
      this.selectedCells = slide.cells;
      this.selectedElements = slide.getCellElements();
      // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility
      this.selectedCell = slide.cells[0];
      this.selectedElement = this.selectedElements[0];
    };
    
    proto.unselectSelectedSlide = function() {
      if ( this.selectedSlide ) this.selectedSlide.unselect();
    };
    
    proto.selectInitialIndex = function() {
      let initialIndex = this.options.initialIndex;
      // already activated, select previous selectedIndex
      if ( this.isInitActivated ) {
        this.select( this.selectedIndex, false, true );
        return;
      }
      // select with selector string
      if ( initialIndex && typeof initialIndex == 'string' ) {
        let cell = this.queryCell( initialIndex );
        if ( cell ) {
          this.selectCell( initialIndex, false, true );
          return;
        }
      }
    
      let index = 0;
      // select with number
      if ( initialIndex && this.slides[ initialIndex ] ) {
        index = initialIndex;
      }
      // select instantly
      this.select( index, false, true );
    };
    
    /**
     * select slide from number or cell element
     * @param {[Element, Number]} value - zero-based index or element to select
     * @param {Boolean} isWrap - enables wrapping around for extra index
     * @param {Boolean} isInstant - disables slide animation
     */
    proto.selectCell = function( value, isWrap, isInstant ) {
      // get cell
      let cell = this.queryCell( value );
      if ( !cell ) return;
    
      let index = this.getCellSlideIndex( cell );
      this.select( index, isWrap, isInstant );
    };
    
    proto.getCellSlideIndex = function( cell ) {
      // get index of slide that has cell
      let cellSlide = this.slides.find( ( slide ) => slide.cells.includes( cell ) );
      return this.slides.indexOf( cellSlide );
    };
    
    // -------------------------- get cells -------------------------- //
    
    /**
     * get Flickity.Cell, given an Element
     * @param {Element} elem - matching cell element
     * @returns {Flickity.Cell} cell - matching cell
     */
    proto.getCell = function( elem ) {
      // loop through cells to get the one that matches
      for ( let cell of this.cells ) {
        if ( cell.element === elem ) return cell;
      }
    };
    
    /**
     * get collection of Flickity.Cells, given Elements
     * @param {[Element, Array, NodeList]} elems - multiple elements
     * @returns {Array} cells - Flickity.Cells
     */
    proto.getCells = function( elems ) {
      elems = utils.makeArray( elems );
      return elems.map( ( elem ) => this.getCell( elem ) ).filter( Boolean );
    };
    
    /**
     * get cell elements
     * @returns {Array} cellElems
     */
    proto.getCellElements = function() {
      return this.cells.map( ( cell ) => cell.element );
    };
    
    /**
     * get parent cell from an element
     * @param {Element} elem - child element
     * @returns {Flickit.Cell} cell - parent cell
     */
    proto.getParentCell = function( elem ) {
      // first check if elem is cell
      let cell = this.getCell( elem );
      if ( cell ) return cell;
    
      // try to get parent cell elem
      let closest = elem.closest('.flickity-slider > *');
      return this.getCell( closest );
    };
    
    /**
     * get cells adjacent to a slide
     * @param {Integer} adjCount - number of adjacent slides
     * @param {Integer} index - index of slide to start
     * @returns {Array} cells - array of Flickity.Cells
     */
    proto.getAdjacentCellElements = function( adjCount, index ) {
      if ( !adjCount ) return this.selectedSlide.getCellElements();
    
      index = index === undefined ? this.selectedIndex : index;
    
      let len = this.slides.length;
      if ( 1 + ( adjCount * 2 ) >= len ) {
        return this.getCellElements(); // get all
      }
    
      let cellElems = [];
      for ( let i = index - adjCount; i <= index + adjCount; i++ ) {
        let slideIndex = this.isWrapping ? utils.modulo( i, len ) : i;
        let slide = this.slides[ slideIndex ];
        if ( slide ) {
          cellElems = cellElems.concat( slide.getCellElements() );
        }
      }
      return cellElems;
    };
    
    /**
     * select slide from number or cell element
     * @param {[Element, String, Number]} selector - element, selector string, or index
     * @returns {Flickity.Cell} - matching cell
     */
    proto.queryCell = function( selector ) {
      if ( typeof selector == 'number' ) {
        // use number as index
        return this.cells[ selector ];
      }
      // do not select invalid selectors from hash: #123, #/. #791
      let isSelectorString = typeof selector == 'string' && !selector.match( /^[#.]?[\d/]/ );
      if ( isSelectorString ) {
        // use string as selector, get element
        selector = this.element.querySelector( selector );
      }
      // get cell from element
      return this.getCell( selector );
    };
    
    // -------------------------- events -------------------------- //
    
    proto.uiChange = function() {
      this.emitEvent('uiChange');
    };
    
    // ----- resize ----- //
    
    proto.onresize = function() {
      this.watchCSS();
      this.resize();
    };
    
    utils.debounceMethod( Flickity, 'onresize', 150 );
    
    proto.resize = function() {
      // #1177 disable resize behavior when animating or dragging for iOS 15
      if ( !this.isActive || this.isAnimating || this.isDragging ) return;
      this.getSize();
      // wrap values
      if ( this.isWrapping ) {
        this.x = utils.modulo( this.x, this.slideableWidth );
      }
      this.positionCells();
      this._updateWrapShiftCells();
      this.setGallerySize();
      this.emitEvent('resize');
      // update selected index for group slides, instant
      // TODO: position can be lost between groups of various numbers
      let selectedElement = this.selectedElements && this.selectedElements[0];
      this.selectCell( selectedElement, false, true );
    };
    
    // watches the :after property, activates/deactivates
    proto.watchCSS = function() {
      if ( !this.options.watchCSS ) return;
    
      let afterContent = getComputedStyle( this.element, ':after' ).content;
      // activate if :after { content: 'flickity' }
      if ( afterContent.includes('flickity') ) {
        this.activate();
      } else {
        this.deactivate();
      }
    };
    
    // ----- keydown ----- //
    
    // go previous/next if left/right keys pressed
    proto.onkeydown = function( event ) {
      let { activeElement } = document;
      let handler = Flickity.keyboardHandlers[ event.key ];
      // only work if element is in focus
      if ( !this.options.accessibility || !activeElement || !handler ) return;
    
      let isFocused = this.focusableElems.some( ( elem ) => activeElement === elem );
      if ( isFocused ) handler.call( this );
    };
    
    Flickity.keyboardHandlers = {
      ArrowLeft: function() {
        this.uiChange();
        let leftMethod = this.options.rightToLeft ? 'next' : 'previous';
        this[ leftMethod ]();
      },
      ArrowRight: function() {
        this.uiChange();
        let rightMethod = this.options.rightToLeft ? 'previous' : 'next';
        this[ rightMethod ]();
      },
    };
    
    // ----- focus ----- //
    
    proto.focus = function() {
      this.element.focus({ preventScroll: true });
    };
    
    // -------------------------- destroy -------------------------- //
    
    // deactivate all Flickity functionality, but keep stuff available
    proto.deactivate = function() {
      if ( !this.isActive ) return;
    
      this.element.classList.remove('flickity-enabled');
      this.element.classList.remove('flickity-rtl');
      this.unselectSelectedSlide();
      // destroy cells
      this.cells.forEach( ( cell ) => cell.destroy() );
      this.viewport.remove();
      // move child elements back into element
      this.element.append( ...this.slider.children );
      if ( this.options.accessibility ) {
        this.element.removeAttribute('tabIndex');
        this.element.removeEventListener( 'keydown', this );
      }
      // set flags
      this.isActive = false;
      this.emitEvent('deactivate');
    };
    
    proto.destroy = function() {
      this.deactivate();
      window.removeEventListener( 'resize', this );
      this.allOff();
      this.emitEvent('destroy');
      if ( jQuery && this.$element ) {
        jQuery.removeData( this.element, 'flickity' );
      }
      delete this.element.flickityGUID;
      delete instances[ this.guid ];
    };
    
    // -------------------------- prototype -------------------------- //
    
    Object.assign( proto, animatePrototype );
    
    // -------------------------- extras -------------------------- //
    
    /**
     * get Flickity instance from element
     * @param {[Element, String]} elem - element or selector string
     * @returns {Flickity} - Flickity instance
     */
    Flickity.data = function( elem ) {
      elem = utils.getQueryElement( elem );
      if ( elem ) return instances[ elem.flickityGUID ];
    };
    
    utils.htmlInit( Flickity, 'flickity' );
    
    let { jQueryBridget } = window;
    if ( jQuery && jQueryBridget ) {
      jQueryBridget( 'flickity', Flickity, jQuery );
    }
    
    // set internal jQuery, for Webpack + jQuery v3, #478
    Flickity.setJQuery = function( jq ) {
      jQuery = jq;
    };
    
    Flickity.Cell = Cell;
    Flickity.Slide = Slide;
    
    return Flickity;
    
    } ) );
    
    },{"./animate":8,"./cell":9,"./slide":18,"ev-emitter":5,"fizzy-ui-utils":6,"get-size":19}],11:[function(require,module,exports){
    // drag
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            window,
            require('./core'),
            require('unidragger'),
            require('fizzy-ui-utils'),
        );
      } else {
        // browser global
        window.Flickity = factory(
            window,
            window.Flickity,
            window.Unidragger,
            window.fizzyUIUtils,
        );
      }
    
    }( typeof window != 'undefined' ? window : this,
        function factory( window, Flickity, Unidragger, utils ) {
    
    // ----- defaults ----- //
    
    Object.assign( Flickity.defaults, {
      draggable: '>1',
      dragThreshold: 3,
    } );
    
    // -------------------------- drag prototype -------------------------- //
    
    let proto = Flickity.prototype;
    Object.assign( proto, Unidragger.prototype ); // inherit Unidragger
    proto.touchActionValue = '';
    
    // --------------------------  -------------------------- //
    
    Flickity.create.drag = function() {
      this.on( 'activate', this.onActivateDrag );
      this.on( 'uiChange', this._uiChangeDrag );
      this.on( 'deactivate', this.onDeactivateDrag );
      this.on( 'cellChange', this.updateDraggable );
      this.on( 'pointerDown', this.handlePointerDown );
      this.on( 'pointerUp', this.handlePointerUp );
      this.on( 'pointerDown', this.handlePointerDone );
      this.on( 'dragStart', this.handleDragStart );
      this.on( 'dragMove', this.handleDragMove );
      this.on( 'dragEnd', this.handleDragEnd );
      this.on( 'staticClick', this.handleStaticClick );
      // TODO updateDraggable on resize? if groupCells & slides change
    };
    
    proto.onActivateDrag = function() {
      this.handles = [ this.viewport ];
      this.bindHandles();
      this.updateDraggable();
    };
    
    proto.onDeactivateDrag = function() {
      this.unbindHandles();
      this.element.classList.remove('is-draggable');
    };
    
    proto.updateDraggable = function() {
      // disable dragging if less than 2 slides. #278
      if ( this.options.draggable === '>1' ) {
        this.isDraggable = this.slides.length > 1;
      } else {
        this.isDraggable = this.options.draggable;
      }
      this.element.classList.toggle( 'is-draggable', this.isDraggable );
    };
    
    proto._uiChangeDrag = function() {
      delete this.isFreeScrolling;
    };
    
    // -------------------------- pointer events -------------------------- //
    
    proto.handlePointerDown = function( event ) {
      if ( !this.isDraggable ) {
        // proceed for staticClick
        this.bindActivePointerEvents( event );
        return;
      }
    
      let isTouchStart = event.type === 'touchstart';
      let isTouchPointer = event.pointerType === 'touch';
      let isFocusNode = event.target.matches('input, textarea, select');
      if ( !isTouchStart && !isTouchPointer && !isFocusNode ) event.preventDefault();
      if ( !isFocusNode ) this.focus();
      // blur
      if ( document.activeElement !== this.element ) document.activeElement.blur();
      // stop if it was moving
      this.dragX = this.x;
      this.viewport.classList.add('is-pointer-down');
      // track scrolling
      this.pointerDownScroll = getScrollPosition();
      window.addEventListener( 'scroll', this );
      this.bindActivePointerEvents( event );
    };
    
    // ----- move ----- //
    
    proto.hasDragStarted = function( moveVector ) {
      return Math.abs( moveVector.x ) > this.options.dragThreshold;
    };
    
    // ----- up ----- //
    
    proto.handlePointerUp = function() {
      delete this.isTouchScrolling;
      this.viewport.classList.remove('is-pointer-down');
    };
    
    proto.handlePointerDone = function() {
      window.removeEventListener( 'scroll', this );
      delete this.pointerDownScroll;
    };
    
    // -------------------------- dragging -------------------------- //
    
    proto.handleDragStart = function() {
      if ( !this.isDraggable ) return;
    
      this.dragStartPosition = this.x;
      this.startAnimation();
      window.removeEventListener( 'scroll', this );
    };
    
    proto.handleDragMove = function( event, pointer, moveVector ) {
      if ( !this.isDraggable ) return;
    
      event.preventDefault();
    
      this.previousDragX = this.dragX;
      // reverse if right-to-left
      let direction = this.options.rightToLeft ? -1 : 1;
      // wrap around move. #589
      if ( this.isWrapping ) moveVector.x %= this.slideableWidth;
      let dragX = this.dragStartPosition + moveVector.x * direction;
    
      if ( !this.isWrapping ) {
        // slow drag
        let originBound = Math.max( -this.slides[0].target, this.dragStartPosition );
        dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;
        let endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );
        dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;
      }
    
      this.dragX = dragX;
      this.dragMoveTime = new Date();
    };
    
    proto.handleDragEnd = function() {
      if ( !this.isDraggable ) return;
    
      let { freeScroll } = this.options;
      if ( freeScroll ) this.isFreeScrolling = true;
      // set selectedIndex based on where flick will end up
      let index = this.dragEndRestingSelect();
    
      if ( freeScroll && !this.isWrapping ) {
        // if free-scroll & not wrap around
        // do not free-scroll if going outside of bounding slides
        // so bounding slides can attract slider, and keep it in bounds
        let restingX = this.getRestingPosition();
        this.isFreeScrolling = -restingX > this.slides[0].target &&
          -restingX < this.getLastSlide().target;
      } else if ( !freeScroll && index === this.selectedIndex ) {
        // boost selection if selected index has not changed
        index += this.dragEndBoostSelect();
      }
      delete this.previousDragX;
      // apply selection
      // HACK, set flag so dragging stays in correct direction
      this.isDragSelect = this.isWrapping;
      this.select( index );
      delete this.isDragSelect;
    };
    
    proto.dragEndRestingSelect = function() {
      let restingX = this.getRestingPosition();
      // how far away from selected slide
      let distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );
      // get closet resting going up and going down
      let positiveResting = this._getClosestResting( restingX, distance, 1 );
      let negativeResting = this._getClosestResting( restingX, distance, -1 );
      // use closer resting for wrap-around
      return positiveResting.distance < negativeResting.distance ?
        positiveResting.index : negativeResting.index;
    };
    
    /**
     * given resting X and distance to selected cell
     * get the distance and index of the closest cell
     * @param {Number} restingX - estimated post-flick resting position
     * @param {Number} distance - distance to selected cell
     * @param {Integer} increment - +1 or -1, going up or down
     * @returns {Object} - { distance: {Number}, index: {Integer} }
     */
    proto._getClosestResting = function( restingX, distance, increment ) {
      let index = this.selectedIndex;
      let minDistance = Infinity;
      let condition = this.options.contain && !this.isWrapping ?
        // if containing, keep going if distance is equal to minDistance
        ( dist, minDist ) => dist <= minDist :
        ( dist, minDist ) => dist < minDist;
    
      while ( condition( distance, minDistance ) ) {
        // measure distance to next cell
        index += increment;
        minDistance = distance;
        distance = this.getSlideDistance( -restingX, index );
        if ( distance === null ) break;
    
        distance = Math.abs( distance );
      }
      return {
        distance: minDistance,
        // selected was previous index
        index: index - increment,
      };
    };
    
    /**
     * measure distance between x and a slide target
     * @param {Number} x - horizontal position
     * @param {Integer} index - slide index
     * @returns {Number} - slide distance
     */
    proto.getSlideDistance = function( x, index ) {
      let len = this.slides.length;
      // wrap around if at least 2 slides
      let isWrapAround = this.options.wrapAround && len > 1;
      let slideIndex = isWrapAround ? utils.modulo( index, len ) : index;
      let slide = this.slides[ slideIndex ];
      if ( !slide ) return null;
    
      // add distance for wrap-around slides
      let wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;
      return x - ( slide.target + wrap );
    };
    
    proto.dragEndBoostSelect = function() {
      // do not boost if no previousDragX or dragMoveTime
      if ( this.previousDragX === undefined || !this.dragMoveTime ||
        // or if drag was held for 100 ms
        new Date() - this.dragMoveTime > 100 ) {
        return 0;
      }
    
      let distance = this.getSlideDistance( -this.dragX, this.selectedIndex );
      let delta = this.previousDragX - this.dragX;
      if ( distance > 0 && delta > 0 ) {
        // boost to next if moving towards the right, and positive velocity
        return 1;
      } else if ( distance < 0 && delta < 0 ) {
        // boost to previous if moving towards the left, and negative velocity
        return -1;
      }
      return 0;
    };
    
    // ----- scroll ----- //
    
    proto.onscroll = function() {
      let scroll = getScrollPosition();
      let scrollMoveX = this.pointerDownScroll.x - scroll.x;
      let scrollMoveY = this.pointerDownScroll.y - scroll.y;
      // cancel click/tap if scroll is too much
      if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {
        this.pointerDone();
      }
    };
    
    // ----- utils ----- //
    
    function getScrollPosition() {
      return {
        x: window.pageXOffset,
        y: window.pageYOffset,
      };
    }
    
    // -----  ----- //
    
    return Flickity;
    
    } ) );
    
    },{"./core":10,"fizzy-ui-utils":6,"unidragger":37}],12:[function(require,module,exports){
    // imagesloaded
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            require('./core'),
            require('imagesloaded'),
        );
      } else {
        // browser global
        factory(
            window.Flickity,
            window.imagesLoaded,
        );
      }
    
    }( typeof window != 'undefined' ? window : this,
        function factory( Flickity, imagesLoaded ) {
    
    Flickity.create.imagesLoaded = function() {
      this.on( 'activate', this.imagesLoaded );
    };
    
    Flickity.prototype.imagesLoaded = function() {
      if ( !this.options.imagesLoaded ) return;
    
      let onImagesLoadedProgress = ( instance, image ) => {
        let cell = this.getParentCell( image.img );
        this.cellSizeChange( cell && cell.element );
        if ( !this.options.freeScroll ) this.positionSliderAtSelected();
      };
      imagesLoaded( this.slider ).on( 'progress', onImagesLoadedProgress );
    };
    
    return Flickity;
    
    } ) );
    
    },{"./core":10,"imagesloaded":20}],13:[function(require,module,exports){
    /*!
     * Flickity v3.0.0
     * Touch, responsive, flickable carousels
     *
     * Licensed GPLv3 for open source use
     * or Flickity Commercial License for commercial use
     *
     * https://flickity.metafizzy.co
     * Copyright 2015-2022 Metafizzy
     */
    
    if ( typeof module == 'object' && module.exports ) {
      const Flickity = require('./core');
      require('./drag');
      require('./prev-next-button');
      require('./page-dots');
      require('./player');
      require('./add-remove-cell');
      require('./lazyload');
      require('./imagesloaded');
    
      module.exports = Flickity;
    }
    
    },{"./add-remove-cell":7,"./core":10,"./drag":11,"./imagesloaded":12,"./lazyload":14,"./page-dots":15,"./player":16,"./prev-next-button":17}],14:[function(require,module,exports){
    // lazyload
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            require('./core'),
            require('fizzy-ui-utils'),
        );
      } else {
        // browser global
        factory(
            window.Flickity,
            window.fizzyUIUtils,
        );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( Flickity, utils ) {
    
    const lazyAttr = 'data-flickity-lazyload';
    const lazySrcAttr = `${lazyAttr}-src`;
    const lazySrcsetAttr = `${lazyAttr}-srcset`;
    const imgSelector = `img[${lazyAttr}], img[${lazySrcAttr}], ` +
      `img[${lazySrcsetAttr}], source[${lazySrcsetAttr}]`;
    
    Flickity.create.lazyLoad = function() {
      this.on( 'select', this.lazyLoad );
    
      this.handleLazyLoadComplete = this.onLazyLoadComplete.bind( this );
    };
    
    let proto = Flickity.prototype;
    
    proto.lazyLoad = function() {
      let { lazyLoad } = this.options;
      if ( !lazyLoad ) return;
    
      // get adjacent cells, use lazyLoad option for adjacent count
      let adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
      // lazy load images
      this.getAdjacentCellElements( adjCount )
        .map( getCellLazyImages )
        .flat()
        .forEach( ( img ) => new LazyLoader( img, this.handleLazyLoadComplete ) );
    };
    
    function getCellLazyImages( cellElem ) {
      // check if cell element is lazy image
      if ( cellElem.matches('img') ) {
        let cellAttr = cellElem.getAttribute( lazyAttr );
        let cellSrcAttr = cellElem.getAttribute( lazySrcAttr );
        let cellSrcsetAttr = cellElem.getAttribute( lazySrcsetAttr );
        if ( cellAttr || cellSrcAttr || cellSrcsetAttr ) {
          return cellElem;
        }
      }
      // select lazy images in cell
      return [ ...cellElem.querySelectorAll( imgSelector ) ];
    }
    
    proto.onLazyLoadComplete = function( img, event ) {
      let cell = this.getParentCell( img );
      let cellElem = cell && cell.element;
      this.cellSizeChange( cellElem );
    
      this.dispatchEvent( 'lazyLoad', event, cellElem );
    };
    
    // -------------------------- LazyLoader -------------------------- //
    
    /**
     * class to handle loading images
     * @param {Image} img - Image element
     * @param {Function} onComplete - callback function
     */
    function LazyLoader( img, onComplete ) {
      this.img = img;
      this.onComplete = onComplete;
      this.load();
    }
    
    LazyLoader.prototype.handleEvent = utils.handleEvent;
    
    LazyLoader.prototype.load = function() {
      this.img.addEventListener( 'load', this );
      this.img.addEventListener( 'error', this );
      // get src & srcset
      let src = this.img.getAttribute( lazyAttr ) ||
        this.img.getAttribute( lazySrcAttr );
      let srcset = this.img.getAttribute( lazySrcsetAttr );
      // set src & serset
      this.img.src = src;
      if ( srcset ) this.img.setAttribute( 'srcset', srcset );
      // remove attr
      this.img.removeAttribute( lazyAttr );
      this.img.removeAttribute( lazySrcAttr );
      this.img.removeAttribute( lazySrcsetAttr );
    };
    
    LazyLoader.prototype.onload = function( event ) {
      this.complete( event, 'flickity-lazyloaded' );
    };
    
    LazyLoader.prototype.onerror = function( event ) {
      this.complete( event, 'flickity-lazyerror' );
    };
    
    LazyLoader.prototype.complete = function( event, className ) {
      // unbind events
      this.img.removeEventListener( 'load', this );
      this.img.removeEventListener( 'error', this );
      let mediaElem = this.img.parentNode.matches('picture') ? this.img.parentNode : this.img;
      mediaElem.classList.add( className );
    
      this.onComplete( this.img, event );
    };
    
    // -----  ----- //
    
    Flickity.LazyLoader = LazyLoader;
    
    return Flickity;
    
    } ) );
    
    },{"./core":10,"fizzy-ui-utils":6}],15:[function(require,module,exports){
    // page dots
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            require('./core'),
            require('fizzy-ui-utils'),
        );
      } else {
        // browser global
        factory(
            window.Flickity,
            window.fizzyUIUtils,
        );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( Flickity, utils ) {
    
    // -------------------------- PageDots -------------------------- //
    
    function PageDots() {
      // create holder element
      this.holder = document.createElement('div');
      this.holder.className = 'flickity-page-dots';
      // create dots, array of elements
      this.dots = [];
    }
    
    PageDots.prototype.setDots = function( slidesLength ) {
      // get difference between number of slides and number of dots
      let delta = slidesLength - this.dots.length;
      if ( delta > 0 ) {
        this.addDots( delta );
      } else if ( delta < 0 ) {
        this.removeDots( -delta );
      }
    };
    
    PageDots.prototype.addDots = function( count ) {
      let newDots = new Array( count ).fill()
        .map( ( item, i ) => {
          let dot = document.createElement('button');
          dot.setAttribute( 'type', 'button' );
          let num = i + 1 + this.dots.length;
          dot.className = 'flickity-page-dot';
          dot.textContent = `View slide ${num}`;
          return dot;
        } );
    
      this.holder.append( ...newDots );
      this.dots = this.dots.concat( newDots );
    };
    
    PageDots.prototype.removeDots = function( count ) {
      // remove from this.dots collection
      let removeDots = this.dots.splice( this.dots.length - count, count );
      // remove from DOM
      removeDots.forEach( ( dot ) => dot.remove() );
    };
    
    PageDots.prototype.updateSelected = function( index ) {
      // remove selected class on previous
      if ( this.selectedDot ) {
        this.selectedDot.classList.remove('is-selected');
        this.selectedDot.removeAttribute('aria-current');
      }
      // don't proceed if no dots
      if ( !this.dots.length ) return;
    
      this.selectedDot = this.dots[ index ];
      this.selectedDot.classList.add('is-selected');
      this.selectedDot.setAttribute( 'aria-current', 'step' );
    };
    
    Flickity.PageDots = PageDots;
    
    // -------------------------- Flickity -------------------------- //
    
    Object.assign( Flickity.defaults, {
      pageDots: true,
    } );
    
    Flickity.create.pageDots = function() {
      if ( !this.options.pageDots ) return;
    
      this.pageDots = new PageDots();
      this.handlePageDotsClick = this.onPageDotsClick.bind( this );
      // events
      this.on( 'activate', this.activatePageDots );
      this.on( 'select', this.updateSelectedPageDots );
      this.on( 'cellChange', this.updatePageDots );
      this.on( 'resize', this.updatePageDots );
      this.on( 'deactivate', this.deactivatePageDots );
    };
    
    let proto = Flickity.prototype;
    
    proto.activatePageDots = function() {
      this.pageDots.setDots( this.slides.length );
      this.focusableElems.push( ...this.pageDots.dots );
      this.pageDots.holder.addEventListener( 'click', this.handlePageDotsClick );
      this.element.append( this.pageDots.holder );
    };
    
    proto.onPageDotsClick = function( event ) {
      let index = this.pageDots.dots.indexOf( event.target );
      if ( index === -1 ) return; // only dot clicks
    
      this.uiChange();
      this.select( index );
    };
    
    proto.updateSelectedPageDots = function() {
      this.pageDots.updateSelected( this.selectedIndex );
    };
    
    proto.updatePageDots = function() {
      this.pageDots.dots.forEach( ( dot ) => {
        utils.removeFrom( this.focusableElems, dot );
      } );
      this.pageDots.setDots( this.slides.length );
      this.focusableElems.push( ...this.pageDots.dots );
    };
    
    proto.deactivatePageDots = function() {
      this.pageDots.holder.remove();
      this.pageDots.holder.removeEventListener( 'click', this.handlePageDotsClick );
    };
    
    // -----  ----- //
    
    Flickity.PageDots = PageDots;
    
    return Flickity;
    
    } ) );
    
    },{"./core":10,"fizzy-ui-utils":6}],16:[function(require,module,exports){
    // player & autoPlay
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory( require('./core') );
      } else {
        // browser global
        factory( window.Flickity );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( Flickity ) {
    
    // -------------------------- Player -------------------------- //
    
    function Player( autoPlay, onTick ) {
      this.autoPlay = autoPlay;
      this.onTick = onTick;
      this.state = 'stopped';
      // visibility change event handler
      this.onVisibilityChange = this.visibilityChange.bind( this );
      this.onVisibilityPlay = this.visibilityPlay.bind( this );
    }
    
    // start play
    Player.prototype.play = function() {
      if ( this.state === 'playing' ) return;
    
      // do not play if page is hidden, start playing when page is visible
      let isPageHidden = document.hidden;
      if ( isPageHidden ) {
        document.addEventListener( 'visibilitychange', this.onVisibilityPlay );
        return;
      }
    
      this.state = 'playing';
      // listen to visibility change
      document.addEventListener( 'visibilitychange', this.onVisibilityChange );
      // start ticking
      this.tick();
    };
    
    Player.prototype.tick = function() {
      // do not tick if not playing
      if ( this.state !== 'playing' ) return;
    
      // default to 3 seconds
      let time = typeof this.autoPlay == 'number' ? this.autoPlay : 3000;
      // HACK: reset ticks if stopped and started within interval
      this.clear();
      this.timeout = setTimeout( () => {
        this.onTick();
        this.tick();
      }, time );
    };
    
    Player.prototype.stop = function() {
      this.state = 'stopped';
      this.clear();
      // remove visibility change event
      document.removeEventListener( 'visibilitychange', this.onVisibilityChange );
    };
    
    Player.prototype.clear = function() {
      clearTimeout( this.timeout );
    };
    
    Player.prototype.pause = function() {
      if ( this.state === 'playing' ) {
        this.state = 'paused';
        this.clear();
      }
    };
    
    Player.prototype.unpause = function() {
      // re-start play if paused
      if ( this.state === 'paused' ) this.play();
    };
    
    // pause if page visibility is hidden, unpause if visible
    Player.prototype.visibilityChange = function() {
      let isPageHidden = document.hidden;
      this[ isPageHidden ? 'pause' : 'unpause' ]();
    };
    
    Player.prototype.visibilityPlay = function() {
      this.play();
      document.removeEventListener( 'visibilitychange', this.onVisibilityPlay );
    };
    
    // -------------------------- Flickity -------------------------- //
    
    Object.assign( Flickity.defaults, {
      pauseAutoPlayOnHover: true,
    } );
    
    Flickity.create.player = function() {
      this.player = new Player( this.options.autoPlay, () => {
        this.next( true );
      } );
    
      this.on( 'activate', this.activatePlayer );
      this.on( 'uiChange', this.stopPlayer );
      this.on( 'pointerDown', this.stopPlayer );
      this.on( 'deactivate', this.deactivatePlayer );
    };
    
    let proto = Flickity.prototype;
    
    proto.activatePlayer = function() {
      if ( !this.options.autoPlay ) return;
    
      this.player.play();
      this.element.addEventListener( 'mouseenter', this );
    };
    
    // Player API, don't hate the ... thanks I know where the door is
    
    proto.playPlayer = function() {
      this.player.play();
    };
    
    proto.stopPlayer = function() {
      this.player.stop();
    };
    
    proto.pausePlayer = function() {
      this.player.pause();
    };
    
    proto.unpausePlayer = function() {
      this.player.unpause();
    };
    
    proto.deactivatePlayer = function() {
      this.player.stop();
      this.element.removeEventListener( 'mouseenter', this );
    };
    
    // ----- mouseenter/leave ----- //
    
    // pause auto-play on hover
    proto.onmouseenter = function() {
      if ( !this.options.pauseAutoPlayOnHover ) return;
    
      this.player.pause();
      this.element.addEventListener( 'mouseleave', this );
    };
    
    // resume auto-play on hover off
    proto.onmouseleave = function() {
      this.player.unpause();
      this.element.removeEventListener( 'mouseleave', this );
    };
    
    // -----  ----- //
    
    Flickity.Player = Player;
    
    return Flickity;
    
    } ) );
    
    },{"./core":10}],17:[function(require,module,exports){
    // prev/next buttons
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory( require('./core') );
      } else {
        // browser global
        factory( window.Flickity );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( Flickity ) {
    
    const svgURI = 'http://www.w3.org/2000/svg';
    
    // -------------------------- PrevNextButton -------------------------- //
    
    function PrevNextButton( increment, direction, arrowShape ) {
      this.increment = increment;
      this.direction = direction;
      this.isPrevious = increment === 'previous';
      this.isLeft = direction === 'left';
      this._create( arrowShape );
    }
    
    PrevNextButton.prototype._create = function( arrowShape ) {
      // properties
      let element = this.element = document.createElement('button');
      element.className = `flickity-button flickity-prev-next-button ${this.increment}`;
      let label = this.isPrevious ? 'Previous' : 'Next';
      // prevent button from submitting form https://stackoverflow.com/a/10836076/182183
      element.setAttribute( 'type', 'button' );
      element.setAttribute( 'aria-label', label );
      // init as disabled
      this.disable();
      // create arrow
      let svg = this.createSVG( label, arrowShape );
      element.append( svg );
    };
    
    PrevNextButton.prototype.createSVG = function( label, arrowShape ) {
      let svg = document.createElementNS( svgURI, 'svg' );
      svg.setAttribute( 'class', 'flickity-button-icon' );
      svg.setAttribute( 'viewBox', '0 0 100 100' );
      // add title #1189
      let title = document.createElementNS( svgURI, 'title' );
      title.append( label );
      // add path
      let path = document.createElementNS( svgURI, 'path' );
      let pathMovements = getArrowMovements( arrowShape );
      path.setAttribute( 'd', pathMovements );
      path.setAttribute( 'class', 'arrow' );
      // rotate arrow
      if ( !this.isLeft ) {
        path.setAttribute( 'transform', 'translate(100, 100) rotate(180)' );
      }
      svg.append( title, path );
      return svg;
    };
    
    // get SVG path movmement
    function getArrowMovements( shape ) {
      // use shape as movement if string
      if ( typeof shape == 'string' ) return shape;
    
      let { x0, x1, x2, x3, y1, y2 } = shape;
    
      // create movement string
      return `M ${x0}, 50
        L ${x1}, ${y1 + 50}
        L ${x2}, ${y2 + 50}
        L ${x3}, 50
        L ${x2}, ${50 - y2}
        L ${x1}, ${50 - y1}
        Z`;
    }
    
    // -----  ----- //
    
    PrevNextButton.prototype.enable = function() {
      this.element.removeAttribute('disabled');
    };
    
    PrevNextButton.prototype.disable = function() {
      this.element.setAttribute( 'disabled', true );
    };
    
    // -------------------------- Flickity prototype -------------------------- //
    
    Object.assign( Flickity.defaults, {
      prevNextButtons: true,
      arrowShape: {
        x0: 10,
        x1: 60, y1: 50,
        x2: 70, y2: 40,
        x3: 30,
      },
    } );
    
    Flickity.create.prevNextButtons = function() {
      if ( !this.options.prevNextButtons ) return;
    
      let { rightToLeft, arrowShape } = this.options;
      let prevDirection = rightToLeft ? 'right' : 'left';
      let nextDirection = rightToLeft ? 'left' : 'right';
      this.prevButton = new PrevNextButton( 'previous', prevDirection, arrowShape );
      this.nextButton = new PrevNextButton( 'next', nextDirection, arrowShape );
      this.focusableElems.push( this.prevButton.element );
      this.focusableElems.push( this.nextButton.element );
    
      this.handlePrevButtonClick = () => {
        this.uiChange();
        this.previous();
      };
    
      this.handleNextButtonClick = () => {
        this.uiChange();
        this.next();
      };
    
      this.on( 'activate', this.activatePrevNextButtons );
      this.on( 'select', this.updatePrevNextButtons );
    };
    
    let proto = Flickity.prototype;
    
    proto.updatePrevNextButtons = function() {
      let lastIndex = this.slides.length ? this.slides.length - 1 : 0;
      this.updatePrevNextButton( this.prevButton, 0 );
      this.updatePrevNextButton( this.nextButton, lastIndex );
    };
    
    proto.updatePrevNextButton = function( button, disabledIndex ) {
      // enable is wrapAround and at least 2 slides
      if ( this.isWrapping && this.slides.length > 1 ) {
        button.enable();
        return;
      }
    
      let isEnabled = this.selectedIndex !== disabledIndex;
      button[ isEnabled ? 'enable' : 'disable' ]();
      // if disabling button that is focused,
      // shift focus to element to maintain keyboard accessibility
      let isDisabledFocused = !isEnabled && document.activeElement === button.element;
      if ( isDisabledFocused ) this.focus();
    };
    
    proto.activatePrevNextButtons = function() {
      this.prevButton.element.addEventListener( 'click', this.handlePrevButtonClick );
      this.nextButton.element.addEventListener( 'click', this.handleNextButtonClick );
      this.element.append( this.prevButton.element, this.nextButton.element );
      this.on( 'deactivate', this.deactivatePrevNextButtons );
    };
    
    proto.deactivatePrevNextButtons = function() {
      this.prevButton.element.remove();
      this.nextButton.element.remove();
      this.prevButton.element.removeEventListener( 'click', this.handlePrevButtonClick );
      this.nextButton.element.removeEventListener( 'click', this.handleNextButtonClick );
      this.off( 'deactivate', this.deactivatePrevNextButtons );
    };
    
    // --------------------------  -------------------------- //
    
    Flickity.PrevNextButton = PrevNextButton;
    
    return Flickity;
    
    } ) );
    
    },{"./core":10}],18:[function(require,module,exports){
    // slide
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.Flickity = window.Flickity || {};
        window.Flickity.Slide = factory();
      }
    
    }( typeof window != 'undefined' ? window : this, function factory() {
    
    function Slide( beginMargin, endMargin, cellAlign ) {
      this.beginMargin = beginMargin;
      this.endMargin = endMargin;
      this.cellAlign = cellAlign;
      this.cells = [];
      this.outerWidth = 0;
      this.height = 0;
    }
    
    let proto = Slide.prototype;
    
    proto.addCell = function( cell ) {
      this.cells.push( cell );
      this.outerWidth += cell.size.outerWidth;
      this.height = Math.max( cell.size.outerHeight, this.height );
      // first cell stuff
      if ( this.cells.length === 1 ) {
        this.x = cell.x; // x comes from first cell
        this.firstMargin = cell.size[ this.beginMargin ];
      }
    };
    
    proto.updateTarget = function() {
      let lastCell = this.getLastCell();
      let lastMargin = lastCell ? lastCell.size[ this.endMargin ] : 0;
      let slideWidth = this.outerWidth - ( this.firstMargin + lastMargin );
      this.target = this.x + this.firstMargin + slideWidth * this.cellAlign;
    };
    
    proto.getLastCell = function() {
      return this.cells[ this.cells.length - 1 ];
    };
    
    proto.select = function() {
      this.cells.forEach( ( cell ) => cell.select() );
    };
    
    proto.unselect = function() {
      this.cells.forEach( ( cell ) => cell.unselect() );
    };
    
    proto.getCellElements = function() {
      return this.cells.map( ( cell ) => cell.element );
    };
    
    return Slide;
    
    } ) );
    
    },{}],19:[function(require,module,exports){
    /*!
     * Infinite Scroll v2.0.4
     * measure size of elements
     * MIT license
     */
    
    ( function( window, factory ) {
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.getSize = factory();
      }
    
    } )( window, function factory() {
    
    // -------------------------- helpers -------------------------- //
    
    // get a number from a string, not a percentage
    function getStyleSize( value ) {
      let num = parseFloat( value );
      // not a percent like '100%', and a number
      let isValid = value.indexOf('%') == -1 && !isNaN( num );
      return isValid && num;
    }
    
    // -------------------------- measurements -------------------------- //
    
    let measurements = [
      'paddingLeft',
      'paddingRight',
      'paddingTop',
      'paddingBottom',
      'marginLeft',
      'marginRight',
      'marginTop',
      'marginBottom',
      'borderLeftWidth',
      'borderRightWidth',
      'borderTopWidth',
      'borderBottomWidth',
    ];
    
    let measurementsLength = measurements.length;
    
    function getZeroSize() {
      let size = {
        width: 0,
        height: 0,
        innerWidth: 0,
        innerHeight: 0,
        outerWidth: 0,
        outerHeight: 0,
      };
      measurements.forEach( ( measurement ) => {
        size[ measurement ] = 0;
      } );
      return size;
    }
    
    // -------------------------- getSize -------------------------- //
    
    function getSize( elem ) {
      // use querySeletor if elem is string
      if ( typeof elem == 'string' ) elem = document.querySelector( elem );
    
      // do not proceed on non-objects
      let isElement = elem && typeof elem == 'object' && elem.nodeType;
      if ( !isElement ) return;
    
      let style = getComputedStyle( elem );
    
      // if hidden, everything is 0
      if ( style.display == 'none' ) return getZeroSize();
    
      let size = {};
      size.width = elem.offsetWidth;
      size.height = elem.offsetHeight;
    
      let isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';
    
      // get all measurements
      measurements.forEach( ( measurement ) => {
        let value = style[ measurement ];
        let num = parseFloat( value );
        // any 'auto', 'medium' value will be 0
        size[ measurement ] = !isNaN( num ) ? num : 0;
      } );
    
      let paddingWidth = size.paddingLeft + size.paddingRight;
      let paddingHeight = size.paddingTop + size.paddingBottom;
      let marginWidth = size.marginLeft + size.marginRight;
      let marginHeight = size.marginTop + size.marginBottom;
      let borderWidth = size.borderLeftWidth + size.borderRightWidth;
      let borderHeight = size.borderTopWidth + size.borderBottomWidth;
    
      // overwrite width and height if we can get it from style
      let styleWidth = getStyleSize( style.width );
      if ( styleWidth !== false ) {
        size.width = styleWidth +
          // add padding and border unless it's already including it
          ( isBorderBox ? 0 : paddingWidth + borderWidth );
      }
    
      let styleHeight = getStyleSize( style.height );
      if ( styleHeight !== false ) {
        size.height = styleHeight +
          // add padding and border unless it's already including it
          ( isBorderBox ? 0 : paddingHeight + borderHeight );
      }
    
      size.innerWidth = size.width - ( paddingWidth + borderWidth );
      size.innerHeight = size.height - ( paddingHeight + borderHeight );
    
      size.outerWidth = size.width + marginWidth;
      size.outerHeight = size.height + marginHeight;
    
      return size;
    }
    
    return getSize;
    
    } );
    
    },{}],20:[function(require,module,exports){
    /*!
     * imagesLoaded v5.0.0
     * JavaScript is all like "You images are done yet or what?"
     * MIT License
     */
    
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory( window, require('ev-emitter') );
      } else {
        // browser global
        window.imagesLoaded = factory( window, window.EvEmitter );
      }
    
    } )( typeof window !== 'undefined' ? window : this,
        function factory( window, EvEmitter ) {
    
    let $ = window.jQuery;
    let console = window.console;
    
    // -------------------------- helpers -------------------------- //
    
    // turn element or nodeList into an array
    function makeArray( obj ) {
      // use object if already an array
      if ( Array.isArray( obj ) ) return obj;
    
      let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
      // convert nodeList to array
      if ( isArrayLike ) return [ ...obj ];
    
      // array of single index
      return [ obj ];
    }
    
    // -------------------------- imagesLoaded -------------------------- //
    
    /**
     * @param {[Array, Element, NodeList, String]} elem
     * @param {[Object, Function]} options - if function, use as callback
     * @param {Function} onAlways - callback function
     * @returns {ImagesLoaded}
     */
    function ImagesLoaded( elem, options, onAlways ) {
      // coerce ImagesLoaded() without new, to be new ImagesLoaded()
      if ( !( this instanceof ImagesLoaded ) ) {
        return new ImagesLoaded( elem, options, onAlways );
      }
      // use elem as selector string
      let queryElem = elem;
      if ( typeof elem == 'string' ) {
        queryElem = document.querySelectorAll( elem );
      }
      // bail if bad element
      if ( !queryElem ) {
        console.error(`Bad element for imagesLoaded ${queryElem || elem}`);
        return;
      }
    
      this.elements = makeArray( queryElem );
      this.options = {};
      // shift arguments if no options set
      if ( typeof options == 'function' ) {
        onAlways = options;
      } else {
        Object.assign( this.options, options );
      }
    
      if ( onAlways ) this.on( 'always', onAlways );
    
      this.getImages();
      // add jQuery Deferred object
      if ( $ ) this.jqDeferred = new $.Deferred();
    
      // HACK check async to allow time to bind listeners
      setTimeout( this.check.bind( this ) );
    }
    
    ImagesLoaded.prototype = Object.create( EvEmitter.prototype );
    
    ImagesLoaded.prototype.getImages = function() {
      this.images = [];
    
      // filter & find items if we have an item selector
      this.elements.forEach( this.addElementImages, this );
    };
    
    const elementNodeTypes = [ 1, 9, 11 ];
    
    /**
     * @param {Node} elem
     */
    ImagesLoaded.prototype.addElementImages = function( elem ) {
      // filter siblings
      if ( elem.nodeName === 'IMG' ) {
        this.addImage( elem );
      }
      // get background image on element
      if ( this.options.background === true ) {
        this.addElementBackgroundImages( elem );
      }
    
      // find children
      // no non-element nodes, #143
      let { nodeType } = elem;
      if ( !nodeType || !elementNodeTypes.includes( nodeType ) ) return;
    
      let childImgs = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( let img of childImgs ) {
        this.addImage( img );
      }
    
      // get child background images
      if ( typeof this.options.background == 'string' ) {
        let children = elem.querySelectorAll( this.options.background );
        for ( let child of children ) {
          this.addElementBackgroundImages( child );
        }
      }
    };
    
    const reURL = /url\((['"])?(.*?)\1\)/gi;
    
    ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
      let style = getComputedStyle( elem );
      // Firefox returns null if in a hidden iframe https://bugzil.la/548397
      if ( !style ) return;
    
      // get url inside url("...")
      let matches = reURL.exec( style.backgroundImage );
      while ( matches !== null ) {
        let url = matches && matches[2];
        if ( url ) {
          this.addBackground( url, elem );
        }
        matches = reURL.exec( style.backgroundImage );
      }
    };
    
    /**
     * @param {Image} img
     */
    ImagesLoaded.prototype.addImage = function( img ) {
      let loadingImage = new LoadingImage( img );
      this.images.push( loadingImage );
    };
    
    ImagesLoaded.prototype.addBackground = function( url, elem ) {
      let background = new Background( url, elem );
      this.images.push( background );
    };
    
    ImagesLoaded.prototype.check = function() {
      this.progressedCount = 0;
      this.hasAnyBroken = false;
      // complete if no images
      if ( !this.images.length ) {
        this.complete();
        return;
      }
    
      /* eslint-disable-next-line func-style */
      let onProgress = ( image, elem, message ) => {
        // HACK - Chrome triggers event before object properties have changed. #83
        setTimeout( () => {
          this.progress( image, elem, message );
        } );
      };
    
      this.images.forEach( function( loadingImage ) {
        loadingImage.once( 'progress', onProgress );
        loadingImage.check();
      } );
    };
    
    ImagesLoaded.prototype.progress = function( image, elem, message ) {
      this.progressedCount++;
      this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
      // progress event
      this.emitEvent( 'progress', [ this, image, elem ] );
      if ( this.jqDeferred && this.jqDeferred.notify ) {
        this.jqDeferred.notify( this, image );
      }
      // check if completed
      if ( this.progressedCount === this.images.length ) {
        this.complete();
      }
    
      if ( this.options.debug && console ) {
        console.log( `progress: ${message}`, image, elem );
      }
    };
    
    ImagesLoaded.prototype.complete = function() {
      let eventName = this.hasAnyBroken ? 'fail' : 'done';
      this.isComplete = true;
      this.emitEvent( eventName, [ this ] );
      this.emitEvent( 'always', [ this ] );
      if ( this.jqDeferred ) {
        let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
        this.jqDeferred[ jqMethod ]( this );
      }
    };
    
    // --------------------------  -------------------------- //
    
    function LoadingImage( img ) {
      this.img = img;
    }
    
    LoadingImage.prototype = Object.create( EvEmitter.prototype );
    
    LoadingImage.prototype.check = function() {
      // If complete is true and browser supports natural sizes,
      // try to check for image status manually.
      let isComplete = this.getIsImageComplete();
      if ( isComplete ) {
        // report based on naturalWidth
        this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
        return;
      }
    
      // If none of the checks above matched, simulate loading on detached element.
      this.proxyImage = new Image();
      // add crossOrigin attribute. #204
      if ( this.img.crossOrigin ) {
        this.proxyImage.crossOrigin = this.img.crossOrigin;
      }
      this.proxyImage.addEventListener( 'load', this );
      this.proxyImage.addEventListener( 'error', this );
      // bind to image as well for Firefox. #191
      this.img.addEventListener( 'load', this );
      this.img.addEventListener( 'error', this );
      this.proxyImage.src = this.img.currentSrc || this.img.src;
    };
    
    LoadingImage.prototype.getIsImageComplete = function() {
      // check for non-zero, non-undefined naturalWidth
      // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
      return this.img.complete && this.img.naturalWidth;
    };
    
    LoadingImage.prototype.confirm = function( isLoaded, message ) {
      this.isLoaded = isLoaded;
      let { parentNode } = this.img;
      // emit progress with parent <picture> or self <img>
      let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;
      this.emitEvent( 'progress', [ this, elem, message ] );
    };
    
    // ----- events ----- //
    
    // trigger specified handler for event type
    LoadingImage.prototype.handleEvent = function( event ) {
      let method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };
    
    LoadingImage.prototype.onload = function() {
      this.confirm( true, 'onload' );
      this.unbindEvents();
    };
    
    LoadingImage.prototype.onerror = function() {
      this.confirm( false, 'onerror' );
      this.unbindEvents();
    };
    
    LoadingImage.prototype.unbindEvents = function() {
      this.proxyImage.removeEventListener( 'load', this );
      this.proxyImage.removeEventListener( 'error', this );
      this.img.removeEventListener( 'load', this );
      this.img.removeEventListener( 'error', this );
    };
    
    // -------------------------- Background -------------------------- //
    
    function Background( url, element ) {
      this.url = url;
      this.element = element;
      this.img = new Image();
    }
    
    // inherit LoadingImage prototype
    Background.prototype = Object.create( LoadingImage.prototype );
    
    Background.prototype.check = function() {
      this.img.addEventListener( 'load', this );
      this.img.addEventListener( 'error', this );
      this.img.src = this.url;
      // check if image is already complete
      let isComplete = this.getIsImageComplete();
      if ( isComplete ) {
        this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
        this.unbindEvents();
      }
    };
    
    Background.prototype.unbindEvents = function() {
      this.img.removeEventListener( 'load', this );
      this.img.removeEventListener( 'error', this );
    };
    
    Background.prototype.confirm = function( isLoaded, message ) {
      this.isLoaded = isLoaded;
      this.emitEvent( 'progress', [ this, this.element, message ] );
    };
    
    // -------------------------- jQuery -------------------------- //
    
    ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
      jQuery = jQuery || window.jQuery;
      if ( !jQuery ) return;
    
      // set local variable
      $ = jQuery;
      // $().imagesLoaded()
      $.fn.imagesLoaded = function( options, onAlways ) {
        let instance = new ImagesLoaded( this, options, onAlways );
        return instance.jqDeferred.promise( $( this ) );
      };
    };
    // try making plugin
    ImagesLoaded.makeJQueryPlugin();
    
    // --------------------------  -------------------------- //
    
    return ImagesLoaded;
    
    } );
    
    },{"ev-emitter":5}],21:[function(require,module,exports){
    /*!
     * Isotope v3.0.6
     *
     * Licensed GPLv3 for open source use
     * or Isotope Commercial License for commercial use
     *
     * https://isotope.metafizzy.co
     * Copyright 2010-2018 Metafizzy
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            'outlayer/outlayer',
            'get-size/get-size',
            'desandro-matches-selector/matches-selector',
            'fizzy-ui-utils/utils',
            './item',
            './layout-mode',
            // include default layout modes
            './layout-modes/masonry',
            './layout-modes/fit-rows',
            './layout-modes/vertical'
          ],
          function( Outlayer, getSize, matchesSelector, utils, Item, LayoutMode ) {
            return factory( window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode );
          });
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          require('outlayer'),
          require('get-size'),
          require('desandro-matches-selector'),
          require('fizzy-ui-utils'),
          require('./item'),
          require('./layout-mode'),
          // include default layout modes
          require('./layout-modes/masonry'),
          require('./layout-modes/fit-rows'),
          require('./layout-modes/vertical')
        );
      } else {
        // browser global
        window.Isotope = factory(
          window,
          window.Outlayer,
          window.getSize,
          window.matchesSelector,
          window.fizzyUIUtils,
          window.Isotope.Item,
          window.Isotope.LayoutMode
        );
      }
    
    }( window, function factory( window, Outlayer, getSize, matchesSelector, utils,
      Item, LayoutMode ) {
    
    'use strict';
    
    // -------------------------- vars -------------------------- //
    
    var jQuery = window.jQuery;
    
    // -------------------------- helpers -------------------------- //
    
    var trim = String.prototype.trim ?
      function( str ) {
        return str.trim();
      } :
      function( str ) {
        return str.replace( /^\s+|\s+$/g, '' );
      };
    
    // -------------------------- isotopeDefinition -------------------------- //
    
      // create an Outlayer layout class
      var Isotope = Outlayer.create( 'isotope', {
        layoutMode: 'masonry',
        isJQueryFiltering: true,
        sortAscending: true
      });
    
      Isotope.Item = Item;
      Isotope.LayoutMode = LayoutMode;
    
      var proto = Isotope.prototype;
    
      proto._create = function() {
        this.itemGUID = 0;
        // functions that sort items
        this._sorters = {};
        this._getSorters();
        // call super
        Outlayer.prototype._create.call( this );
    
        // create layout modes
        this.modes = {};
        // start filteredItems with all items
        this.filteredItems = this.items;
        // keep of track of sortBys
        this.sortHistory = [ 'original-order' ];
        // create from registered layout modes
        for ( var name in LayoutMode.modes ) {
          this._initLayoutMode( name );
        }
      };
    
      proto.reloadItems = function() {
        // reset item ID counter
        this.itemGUID = 0;
        // call super
        Outlayer.prototype.reloadItems.call( this );
      };
    
      proto._itemize = function() {
        var items = Outlayer.prototype._itemize.apply( this, arguments );
        // assign ID for original-order
        for ( var i=0; i < items.length; i++ ) {
          var item = items[i];
          item.id = this.itemGUID++;
        }
        this._updateItemsSortData( items );
        return items;
      };
    
    
      // -------------------------- layout -------------------------- //
    
      proto._initLayoutMode = function( name ) {
        var Mode = LayoutMode.modes[ name ];
        // set mode options
        // HACK extend initial options, back-fill in default options
        var initialOpts = this.options[ name ] || {};
        this.options[ name ] = Mode.options ?
          utils.extend( Mode.options, initialOpts ) : initialOpts;
        // init layout mode instance
        this.modes[ name ] = new Mode( this );
      };
    
    
      proto.layout = function() {
        // if first time doing layout, do all magic
        if ( !this._isLayoutInited && this._getOption('initLayout') ) {
          this.arrange();
          return;
        }
        this._layout();
      };
    
      // private method to be used in layout() & magic()
      proto._layout = function() {
        // don't animate first layout
        var isInstant = this._getIsInstant();
        // layout flow
        this._resetLayout();
        this._manageStamps();
        this.layoutItems( this.filteredItems, isInstant );
    
        // flag for initalized
        this._isLayoutInited = true;
      };
    
      // filter + sort + layout
      proto.arrange = function( opts ) {
        // set any options pass
        this.option( opts );
        this._getIsInstant();
        // filter, sort, and layout
    
        // filter
        var filtered = this._filter( this.items );
        this.filteredItems = filtered.matches;
    
        this._bindArrangeComplete();
    
        if ( this._isInstant ) {
          this._noTransition( this._hideReveal, [ filtered ] );
        } else {
          this._hideReveal( filtered );
        }
    
        this._sort();
        this._layout();
      };
      // alias to _init for main plugin method
      proto._init = proto.arrange;
    
      proto._hideReveal = function( filtered ) {
        this.reveal( filtered.needReveal );
        this.hide( filtered.needHide );
      };
    
      // HACK
      // Don't animate/transition first layout
      // Or don't animate/transition other layouts
      proto._getIsInstant = function() {
        var isLayoutInstant = this._getOption('layoutInstant');
        var isInstant = isLayoutInstant !== undefined ? isLayoutInstant :
          !this._isLayoutInited;
        this._isInstant = isInstant;
        return isInstant;
      };
    
      // listen for layoutComplete, hideComplete and revealComplete
      // to trigger arrangeComplete
      proto._bindArrangeComplete = function() {
        // listen for 3 events to trigger arrangeComplete
        var isLayoutComplete, isHideComplete, isRevealComplete;
        var _this = this;
        function arrangeParallelCallback() {
          if ( isLayoutComplete && isHideComplete && isRevealComplete ) {
            _this.dispatchEvent( 'arrangeComplete', null, [ _this.filteredItems ] );
          }
        }
        this.once( 'layoutComplete', function() {
          isLayoutComplete = true;
          arrangeParallelCallback();
        });
        this.once( 'hideComplete', function() {
          isHideComplete = true;
          arrangeParallelCallback();
        });
        this.once( 'revealComplete', function() {
          isRevealComplete = true;
          arrangeParallelCallback();
        });
      };
    
      // -------------------------- filter -------------------------- //
    
      proto._filter = function( items ) {
        var filter = this.options.filter;
        filter = filter || '*';
        var matches = [];
        var hiddenMatched = [];
        var visibleUnmatched = [];
    
        var test = this._getFilterTest( filter );
    
        // test each item
        for ( var i=0; i < items.length; i++ ) {
          var item = items[i];
          if ( item.isIgnored ) {
            continue;
          }
          // add item to either matched or unmatched group
          var isMatched = test( item );
          // item.isFilterMatched = isMatched;
          // add to matches if its a match
          if ( isMatched ) {
            matches.push( item );
          }
          // add to additional group if item needs to be hidden or revealed
          if ( isMatched && item.isHidden ) {
            hiddenMatched.push( item );
          } else if ( !isMatched && !item.isHidden ) {
            visibleUnmatched.push( item );
          }
        }
    
        // return collections of items to be manipulated
        return {
          matches: matches,
          needReveal: hiddenMatched,
          needHide: visibleUnmatched
        };
      };
    
      // get a jQuery, function, or a matchesSelector test given the filter
      proto._getFilterTest = function( filter ) {
        if ( jQuery && this.options.isJQueryFiltering ) {
          // use jQuery
          return function( item ) {
            return jQuery( item.element ).is( filter );
          };
        }
        if ( typeof filter == 'function' ) {
          // use filter as function
          return function( item ) {
            return filter( item.element );
          };
        }
        // default, use filter as selector string
        return function( item ) {
          return matchesSelector( item.element, filter );
        };
      };
    
      // -------------------------- sorting -------------------------- //
    
      /**
       * @params {Array} elems
       * @public
       */
      proto.updateSortData = function( elems ) {
        // get items
        var items;
        if ( elems ) {
          elems = utils.makeArray( elems );
          items = this.getItems( elems );
        } else {
          // update all items if no elems provided
          items = this.items;
        }
    
        this._getSorters();
        this._updateItemsSortData( items );
      };
    
      proto._getSorters = function() {
        var getSortData = this.options.getSortData;
        for ( var key in getSortData ) {
          var sorter = getSortData[ key ];
          this._sorters[ key ] = mungeSorter( sorter );
        }
      };
    
      /**
       * @params {Array} items - of Isotope.Items
       * @private
       */
      proto._updateItemsSortData = function( items ) {
        // do not update if no items
        var len = items && items.length;
    
        for ( var i=0; len && i < len; i++ ) {
          var item = items[i];
          item.updateSortData();
        }
      };
    
      // ----- munge sorter ----- //
    
      // encapsulate this, as we just need mungeSorter
      // other functions in here are just for munging
      var mungeSorter = ( function() {
        // add a magic layer to sorters for convienent shorthands
        // `.foo-bar` will use the text of .foo-bar querySelector
        // `[foo-bar]` will use attribute
        // you can also add parser
        // `.foo-bar parseInt` will parse that as a number
        function mungeSorter( sorter ) {
          // if not a string, return function or whatever it is
          if ( typeof sorter != 'string' ) {
            return sorter;
          }
          // parse the sorter string
          var args = trim( sorter ).split(' ');
          var query = args[0];
          // check if query looks like [an-attribute]
          var attrMatch = query.match( /^\[(.+)\]$/ );
          var attr = attrMatch && attrMatch[1];
          var getValue = getValueGetter( attr, query );
          // use second argument as a parser
          var parser = Isotope.sortDataParsers[ args[1] ];
          // parse the value, if there was a parser
          sorter = parser ? function( elem ) {
            return elem && parser( getValue( elem ) );
          } :
          // otherwise just return value
          function( elem ) {
            return elem && getValue( elem );
          };
    
          return sorter;
        }
    
        // get an attribute getter, or get text of the querySelector
        function getValueGetter( attr, query ) {
          // if query looks like [foo-bar], get attribute
          if ( attr ) {
            return function getAttribute( elem ) {
              return elem.getAttribute( attr );
            };
          }
    
          // otherwise, assume its a querySelector, and get its text
          return function getChildText( elem ) {
            var child = elem.querySelector( query );
            return child && child.textContent;
          };
        }
    
        return mungeSorter;
      })();
    
      // parsers used in getSortData shortcut strings
      Isotope.sortDataParsers = {
        'parseInt': function( val ) {
          return parseInt( val, 10 );
        },
        'parseFloat': function( val ) {
          return parseFloat( val );
        }
      };
    
      // ----- sort method ----- //
    
      // sort filteredItem order
      proto._sort = function() {
        if ( !this.options.sortBy ) {
          return;
        }
        // keep track of sortBy History
        var sortBys = utils.makeArray( this.options.sortBy );
        if ( !this._getIsSameSortBy( sortBys ) ) {
          // concat all sortBy and sortHistory, add to front, oldest goes in last
          this.sortHistory = sortBys.concat( this.sortHistory );
        }
        // sort magic
        var itemSorter = getItemSorter( this.sortHistory, this.options.sortAscending );
        this.filteredItems.sort( itemSorter );
      };
    
      // check if sortBys is same as start of sortHistory
      proto._getIsSameSortBy = function( sortBys ) {
        for ( var i=0; i < sortBys.length; i++ ) {
          if ( sortBys[i] != this.sortHistory[i] ) {
            return false;
          }
        }
        return true;
      };
    
      // returns a function used for sorting
      function getItemSorter( sortBys, sortAsc ) {
        return function sorter( itemA, itemB ) {
          // cycle through all sortKeys
          for ( var i = 0; i < sortBys.length; i++ ) {
            var sortBy = sortBys[i];
            var a = itemA.sortData[ sortBy ];
            var b = itemB.sortData[ sortBy ];
            if ( a > b || a < b ) {
              // if sortAsc is an object, use the value given the sortBy key
              var isAscending = sortAsc[ sortBy ] !== undefined ? sortAsc[ sortBy ] : sortAsc;
              var direction = isAscending ? 1 : -1;
              return ( a > b ? 1 : -1 ) * direction;
            }
          }
          return 0;
        };
      }
    
      // -------------------------- methods -------------------------- //
    
      // get layout mode
      proto._mode = function() {
        var layoutMode = this.options.layoutMode;
        var mode = this.modes[ layoutMode ];
        if ( !mode ) {
          // TODO console.error
          throw new Error( 'No layout mode: ' + layoutMode );
        }
        // HACK sync mode's options
        // any options set after init for layout mode need to be synced
        mode.options = this.options[ layoutMode ];
        return mode;
      };
    
      proto._resetLayout = function() {
        // trigger original reset layout
        Outlayer.prototype._resetLayout.call( this );
        this._mode()._resetLayout();
      };
    
      proto._getItemLayoutPosition = function( item  ) {
        return this._mode()._getItemLayoutPosition( item );
      };
    
      proto._manageStamp = function( stamp ) {
        this._mode()._manageStamp( stamp );
      };
    
      proto._getContainerSize = function() {
        return this._mode()._getContainerSize();
      };
    
      proto.needsResizeLayout = function() {
        return this._mode().needsResizeLayout();
      };
    
      // -------------------------- adding & removing -------------------------- //
    
      // HEADS UP overwrites default Outlayer appended
      proto.appended = function( elems ) {
        var items = this.addItems( elems );
        if ( !items.length ) {
          return;
        }
        // filter, layout, reveal new items
        var filteredItems = this._filterRevealAdded( items );
        // add to filteredItems
        this.filteredItems = this.filteredItems.concat( filteredItems );
      };
    
      // HEADS UP overwrites default Outlayer prepended
      proto.prepended = function( elems ) {
        var items = this._itemize( elems );
        if ( !items.length ) {
          return;
        }
        // start new layout
        this._resetLayout();
        this._manageStamps();
        // filter, layout, reveal new items
        var filteredItems = this._filterRevealAdded( items );
        // layout previous items
        this.layoutItems( this.filteredItems );
        // add to items and filteredItems
        this.filteredItems = filteredItems.concat( this.filteredItems );
        this.items = items.concat( this.items );
      };
    
      proto._filterRevealAdded = function( items ) {
        var filtered = this._filter( items );
        this.hide( filtered.needHide );
        // reveal all new items
        this.reveal( filtered.matches );
        // layout new items, no transition
        this.layoutItems( filtered.matches, true );
        return filtered.matches;
      };
    
      /**
       * Filter, sort, and layout newly-appended item elements
       * @param {Array or NodeList or Element} elems
       */
      proto.insert = function( elems ) {
        var items = this.addItems( elems );
        if ( !items.length ) {
          return;
        }
        // append item elements
        var i, item;
        var len = items.length;
        for ( i=0; i < len; i++ ) {
          item = items[i];
          this.element.appendChild( item.element );
        }
        // filter new stuff
        var filteredInsertItems = this._filter( items ).matches;
        // set flag
        for ( i=0; i < len; i++ ) {
          items[i].isLayoutInstant = true;
        }
        this.arrange();
        // reset flag
        for ( i=0; i < len; i++ ) {
          delete items[i].isLayoutInstant;
        }
        this.reveal( filteredInsertItems );
      };
    
      var _remove = proto.remove;
      proto.remove = function( elems ) {
        elems = utils.makeArray( elems );
        var removeItems = this.getItems( elems );
        // do regular thing
        _remove.call( this, elems );
        // bail if no items to remove
        var len = removeItems && removeItems.length;
        // remove elems from filteredItems
        for ( var i=0; len && i < len; i++ ) {
          var item = removeItems[i];
          // remove item from collection
          utils.removeFrom( this.filteredItems, item );
        }
      };
    
      proto.shuffle = function() {
        // update random sortData
        for ( var i=0; i < this.items.length; i++ ) {
          var item = this.items[i];
          item.sortData.random = Math.random();
        }
        this.options.sortBy = 'random';
        this._sort();
        this._layout();
      };
    
      /**
       * trigger fn without transition
       * kind of hacky to have this in the first place
       * @param {Function} fn
       * @param {Array} args
       * @returns ret
       * @private
       */
      proto._noTransition = function( fn, args ) {
        // save transitionDuration before disabling
        var transitionDuration = this.options.transitionDuration;
        // disable transition
        this.options.transitionDuration = 0;
        // do it
        var returnValue = fn.apply( this, args );
        // re-enable transition for reveal
        this.options.transitionDuration = transitionDuration;
        return returnValue;
      };
    
      // ----- helper methods ----- //
    
      /**
       * getter method for getting filtered item elements
       * @returns {Array} elems - collection of item elements
       */
      proto.getFilteredItemElements = function() {
        return this.filteredItems.map( function( item ) {
          return item.element;
        });
      };
    
      // -----  ----- //
    
      return Isotope;
    
    }));
    
    },{"./item":22,"./layout-mode":23,"./layout-modes/fit-rows":24,"./layout-modes/masonry":25,"./layout-modes/vertical":26,"desandro-matches-selector":4,"fizzy-ui-utils":27,"get-size":28,"outlayer":35}],22:[function(require,module,exports){
    /**
     * Isotope Item
    **/
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            'outlayer/outlayer'
          ],
          factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          require('outlayer')
        );
      } else {
        // browser global
        window.Isotope = window.Isotope || {};
        window.Isotope.Item = factory(
          window.Outlayer
        );
      }
    
    }( window, function factory( Outlayer ) {
    'use strict';
    
    // -------------------------- Item -------------------------- //
    
    // sub-class Outlayer Item
    function Item() {
      Outlayer.Item.apply( this, arguments );
    }
    
    var proto = Item.prototype = Object.create( Outlayer.Item.prototype );
    
    var _create = proto._create;
    proto._create = function() {
      // assign id, used for original-order sorting
      this.id = this.layout.itemGUID++;
      _create.call( this );
      this.sortData = {};
    };
    
    proto.updateSortData = function() {
      if ( this.isIgnored ) {
        return;
      }
      // default sorters
      this.sortData.id = this.id;
      // for backward compatibility
      this.sortData['original-order'] = this.id;
      this.sortData.random = Math.random();
      // go thru getSortData obj and apply the sorters
      var getSortData = this.layout.options.getSortData;
      var sorters = this.layout._sorters;
      for ( var key in getSortData ) {
        var sorter = sorters[ key ];
        this.sortData[ key ] = sorter( this.element, this );
      }
    };
    
    var _destroy = proto.destroy;
    proto.destroy = function() {
      // call super
      _destroy.apply( this, arguments );
      // reset display, #741
      this.css({
        display: ''
      });
    };
    
    return Item;
    
    }));
    
    },{"outlayer":35}],23:[function(require,module,exports){
    /**
     * Isotope LayoutMode
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            'get-size/get-size',
            'outlayer/outlayer'
          ],
          factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          require('get-size'),
          require('outlayer')
        );
      } else {
        // browser global
        window.Isotope = window.Isotope || {};
        window.Isotope.LayoutMode = factory(
          window.getSize,
          window.Outlayer
        );
      }
    
    }( window, function factory( getSize, Outlayer ) {
      'use strict';
    
      // layout mode class
      function LayoutMode( isotope ) {
        this.isotope = isotope;
        // link properties
        if ( isotope ) {
          this.options = isotope.options[ this.namespace ];
          this.element = isotope.element;
          this.items = isotope.filteredItems;
          this.size = isotope.size;
        }
      }
    
      var proto = LayoutMode.prototype;
    
      /**
       * some methods should just defer to default Outlayer method
       * and reference the Isotope instance as `this`
      **/
      var facadeMethods = [
        '_resetLayout',
        '_getItemLayoutPosition',
        '_manageStamp',
        '_getContainerSize',
        '_getElementOffset',
        'needsResizeLayout',
        '_getOption'
      ];
    
      facadeMethods.forEach( function( methodName ) {
        proto[ methodName ] = function() {
          return Outlayer.prototype[ methodName ].apply( this.isotope, arguments );
        };
      });
    
      // -----  ----- //
    
      // for horizontal layout modes, check vertical size
      proto.needsVerticalResizeLayout = function() {
        // don't trigger if size did not change
        var size = getSize( this.isotope.element );
        // check that this.size and size are there
        // IE8 triggers resize on body size change, so they might not be
        var hasSizes = this.isotope.size && size;
        return hasSizes && size.innerHeight != this.isotope.size.innerHeight;
      };
    
      // ----- measurements ----- //
    
      proto._getMeasurement = function() {
        this.isotope._getMeasurement.apply( this, arguments );
      };
    
      proto.getColumnWidth = function() {
        this.getSegmentSize( 'column', 'Width' );
      };
    
      proto.getRowHeight = function() {
        this.getSegmentSize( 'row', 'Height' );
      };
    
      /**
       * get columnWidth or rowHeight
       * segment: 'column' or 'row'
       * size 'Width' or 'Height'
      **/
      proto.getSegmentSize = function( segment, size ) {
        var segmentName = segment + size;
        var outerSize = 'outer' + size;
        // columnWidth / outerWidth // rowHeight / outerHeight
        this._getMeasurement( segmentName, outerSize );
        // got rowHeight or columnWidth, we can chill
        if ( this[ segmentName ] ) {
          return;
        }
        // fall back to item of first element
        var firstItemSize = this.getFirstItemSize();
        this[ segmentName ] = firstItemSize && firstItemSize[ outerSize ] ||
          // or size of container
          this.isotope.size[ 'inner' + size ];
      };
    
      proto.getFirstItemSize = function() {
        var firstItem = this.isotope.filteredItems[0];
        return firstItem && firstItem.element && getSize( firstItem.element );
      };
    
      // ----- methods that should reference isotope ----- //
    
      proto.layout = function() {
        this.isotope.layout.apply( this.isotope, arguments );
      };
    
      proto.getSize = function() {
        this.isotope.getSize();
        this.size = this.isotope.size;
      };
    
      // -------------------------- create -------------------------- //
    
      LayoutMode.modes = {};
    
      LayoutMode.create = function( namespace, options ) {
    
        function Mode() {
          LayoutMode.apply( this, arguments );
        }
    
        Mode.prototype = Object.create( proto );
        Mode.prototype.constructor = Mode;
    
        // default options
        if ( options ) {
          Mode.options = options;
        }
    
        Mode.prototype.namespace = namespace;
        // register in Isotope
        LayoutMode.modes[ namespace ] = Mode;
    
        return Mode;
      };
    
      return LayoutMode;
    
    }));
    
    },{"get-size":28,"outlayer":35}],24:[function(require,module,exports){
    /**
     * fitRows layout mode
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            '../layout-mode'
          ],
          factory );
      } else if ( typeof exports == 'object' ) {
        // CommonJS
        module.exports = factory(
          require('../layout-mode')
        );
      } else {
        // browser global
        factory(
          window.Isotope.LayoutMode
        );
      }
    
    }( window, function factory( LayoutMode ) {
    'use strict';
    
    var FitRows = LayoutMode.create('fitRows');
    
    var proto = FitRows.prototype;
    
    proto._resetLayout = function() {
      this.x = 0;
      this.y = 0;
      this.maxY = 0;
      this._getMeasurement( 'gutter', 'outerWidth' );
    };
    
    proto._getItemLayoutPosition = function( item ) {
      item.getSize();
    
      var itemWidth = item.size.outerWidth + this.gutter;
      // if this element cannot fit in the current row
      var containerWidth = this.isotope.size.innerWidth + this.gutter;
      if ( this.x !== 0 && itemWidth + this.x > containerWidth ) {
        this.x = 0;
        this.y = this.maxY;
      }
    
      var position = {
        x: this.x,
        y: this.y
      };
    
      this.maxY = Math.max( this.maxY, this.y + item.size.outerHeight );
      this.x += itemWidth;
    
      return position;
    };
    
    proto._getContainerSize = function() {
      return { height: this.maxY };
    };
    
    return FitRows;
    
    }));
    
    },{"../layout-mode":23}],25:[function(require,module,exports){
    /*!
     * Masonry layout mode
     * sub-classes Masonry
     * https://masonry.desandro.com
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            '../layout-mode',
            'masonry-layout/masonry'
          ],
          factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          require('../layout-mode'),
          require('masonry-layout')
        );
      } else {
        // browser global
        factory(
          window.Isotope.LayoutMode,
          window.Masonry
        );
      }
    
    }( window, function factory( LayoutMode, Masonry ) {
    'use strict';
    
    // -------------------------- masonryDefinition -------------------------- //
    
      // create an Outlayer layout class
      var MasonryMode = LayoutMode.create('masonry');
    
      var proto = MasonryMode.prototype;
    
      var keepModeMethods = {
        _getElementOffset: true,
        layout: true,
        _getMeasurement: true
      };
    
      // inherit Masonry prototype
      for ( var method in Masonry.prototype ) {
        // do not inherit mode methods
        if ( !keepModeMethods[ method ] ) {
          proto[ method ] = Masonry.prototype[ method ];
        }
      }
    
      var measureColumns = proto.measureColumns;
      proto.measureColumns = function() {
        // set items, used if measuring first item
        this.items = this.isotope.filteredItems;
        measureColumns.call( this );
      };
    
      // point to mode options for fitWidth
      var _getOption = proto._getOption;
      proto._getOption = function( option ) {
        if ( option == 'fitWidth' ) {
          return this.options.isFitWidth !== undefined ?
            this.options.isFitWidth : this.options.fitWidth;
        }
        return _getOption.apply( this.isotope, arguments );
      };
    
      return MasonryMode;
    
    }));
    
    },{"../layout-mode":23,"masonry-layout":29}],26:[function(require,module,exports){
    /**
     * vertical layout mode
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            '../layout-mode'
          ],
          factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          require('../layout-mode')
        );
      } else {
        // browser global
        factory(
          window.Isotope.LayoutMode
        );
      }
    
    }( window, function factory( LayoutMode ) {
    'use strict';
    
    var Vertical = LayoutMode.create( 'vertical', {
      horizontalAlignment: 0
    });
    
    var proto = Vertical.prototype;
    
    proto._resetLayout = function() {
      this.y = 0;
    };
    
    proto._getItemLayoutPosition = function( item ) {
      item.getSize();
      var x = ( this.isotope.size.innerWidth - item.size.outerWidth ) *
        this.options.horizontalAlignment;
      var y = this.y;
      this.y += item.size.outerHeight;
      return { x: x, y: y };
    };
    
    proto._getContainerSize = function() {
      return { height: this.y };
    };
    
    return Vertical;
    
    }));
    
    },{"../layout-mode":23}],27:[function(require,module,exports){
    /**
     * Fizzy UI utils v2.0.7
     * MIT license
     */
    
    /*jshint browser: true, undef: true, unused: true, strict: true */
    
    ( function( window, factory ) {
      // universal module definition
      /*jshint strict: false */ /*globals define, module, require */
    
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
          'desandro-matches-selector/matches-selector'
        ], function( matchesSelector ) {
          return factory( window, matchesSelector );
        });
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          require('desandro-matches-selector')
        );
      } else {
        // browser global
        window.fizzyUIUtils = factory(
          window,
          window.matchesSelector
        );
      }
    
    }( window, function factory( window, matchesSelector ) {
    
    'use strict';
    
    var utils = {};
    
    // ----- extend ----- //
    
    // extends objects
    utils.extend = function( a, b ) {
      for ( var prop in b ) {
        a[ prop ] = b[ prop ];
      }
      return a;
    };
    
    // ----- modulo ----- //
    
    utils.modulo = function( num, div ) {
      return ( ( num % div ) + div ) % div;
    };
    
    // ----- makeArray ----- //
    
    var arraySlice = Array.prototype.slice;
    
    // turn element or nodeList into an array
    utils.makeArray = function( obj ) {
      if ( Array.isArray( obj ) ) {
        // use object if already an array
        return obj;
      }
      // return empty array if undefined or null. #6
      if ( obj === null || obj === undefined ) {
        return [];
      }
    
      var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
      if ( isArrayLike ) {
        // convert nodeList to array
        return arraySlice.call( obj );
      }
    
      // array of single index
      return [ obj ];
    };
    
    // ----- removeFrom ----- //
    
    utils.removeFrom = function( ary, obj ) {
      var index = ary.indexOf( obj );
      if ( index != -1 ) {
        ary.splice( index, 1 );
      }
    };
    
    // ----- getParent ----- //
    
    utils.getParent = function( elem, selector ) {
      while ( elem.parentNode && elem != document.body ) {
        elem = elem.parentNode;
        if ( matchesSelector( elem, selector ) ) {
          return elem;
        }
      }
    };
    
    // ----- getQueryElement ----- //
    
    // use element as selector string
    utils.getQueryElement = function( elem ) {
      if ( typeof elem == 'string' ) {
        return document.querySelector( elem );
      }
      return elem;
    };
    
    // ----- handleEvent ----- //
    
    // enable .ontype to trigger from .addEventListener( elem, 'type' )
    utils.handleEvent = function( event ) {
      var method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };
    
    // ----- filterFindElements ----- //
    
    utils.filterFindElements = function( elems, selector ) {
      // make array of elems
      elems = utils.makeArray( elems );
      var ffElems = [];
    
      elems.forEach( function( elem ) {
        // check that elem is an actual element
        if ( !( elem instanceof HTMLElement ) ) {
          return;
        }
        // add elem if no selector
        if ( !selector ) {
          ffElems.push( elem );
          return;
        }
        // filter & find items if we have a selector
        // filter
        if ( matchesSelector( elem, selector ) ) {
          ffElems.push( elem );
        }
        // find children
        var childElems = elem.querySelectorAll( selector );
        // concat childElems to filterFound array
        for ( var i=0; i < childElems.length; i++ ) {
          ffElems.push( childElems[i] );
        }
      });
    
      return ffElems;
    };
    
    // ----- debounceMethod ----- //
    
    utils.debounceMethod = function( _class, methodName, threshold ) {
      threshold = threshold || 100;
      // original method
      var method = _class.prototype[ methodName ];
      var timeoutName = methodName + 'Timeout';
    
      _class.prototype[ methodName ] = function() {
        var timeout = this[ timeoutName ];
        clearTimeout( timeout );
    
        var args = arguments;
        var _this = this;
        this[ timeoutName ] = setTimeout( function() {
          method.apply( _this, args );
          delete _this[ timeoutName ];
        }, threshold );
      };
    };
    
    // ----- docReady ----- //
    
    utils.docReady = function( callback ) {
      var readyState = document.readyState;
      if ( readyState == 'complete' || readyState == 'interactive' ) {
        // do async to allow for other scripts to run. metafizzy/flickity#441
        setTimeout( callback );
      } else {
        document.addEventListener( 'DOMContentLoaded', callback );
      }
    };
    
    // ----- htmlInit ----- //
    
    // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
    utils.toDashed = function( str ) {
      return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
        return $1 + '-' + $2;
      }).toLowerCase();
    };
    
    var console = window.console;
    /**
     * allow user to initialize classes via [data-namespace] or .js-namespace class
     * htmlInit( Widget, 'widgetName' )
     * options are parsed from data-namespace-options
     */
    utils.htmlInit = function( WidgetClass, namespace ) {
      utils.docReady( function() {
        var dashedNamespace = utils.toDashed( namespace );
        var dataAttr = 'data-' + dashedNamespace;
        var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
        var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
        var elems = utils.makeArray( dataAttrElems )
          .concat( utils.makeArray( jsDashElems ) );
        var dataOptionsAttr = dataAttr + '-options';
        var jQuery = window.jQuery;
    
        elems.forEach( function( elem ) {
          var attr = elem.getAttribute( dataAttr ) ||
            elem.getAttribute( dataOptionsAttr );
          var options;
          try {
            options = attr && JSON.parse( attr );
          } catch ( error ) {
            // log error, do not initialize
            if ( console ) {
              console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
              ': ' + error );
            }
            return;
          }
          // initialize
          var instance = new WidgetClass( elem, options );
          // make available via $().data('namespace')
          if ( jQuery ) {
            jQuery.data( elem, namespace, instance );
          }
        });
    
      });
    };
    
    // -----  ----- //
    
    return utils;
    
    }));
    
    },{"desandro-matches-selector":4}],28:[function(require,module,exports){
    /*!
     * getSize v2.0.3
     * measure size of elements
     * MIT license
     */
    
    /* jshint browser: true, strict: true, undef: true, unused: true */
    /* globals console: false */
    
    ( function( window, factory ) {
      /* jshint strict: false */ /* globals define, module */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.getSize = factory();
      }
    
    })( window, function factory() {
    'use strict';
    
    // -------------------------- helpers -------------------------- //
    
    // get a number from a string, not a percentage
    function getStyleSize( value ) {
      var num = parseFloat( value );
      // not a percent like '100%', and a number
      var isValid = value.indexOf('%') == -1 && !isNaN( num );
      return isValid && num;
    }
    
    function noop() {}
    
    var logError = typeof console == 'undefined' ? noop :
      function( message ) {
        console.error( message );
      };
    
    // -------------------------- measurements -------------------------- //
    
    var measurements = [
      'paddingLeft',
      'paddingRight',
      'paddingTop',
      'paddingBottom',
      'marginLeft',
      'marginRight',
      'marginTop',
      'marginBottom',
      'borderLeftWidth',
      'borderRightWidth',
      'borderTopWidth',
      'borderBottomWidth'
    ];
    
    var measurementsLength = measurements.length;
    
    function getZeroSize() {
      var size = {
        width: 0,
        height: 0,
        innerWidth: 0,
        innerHeight: 0,
        outerWidth: 0,
        outerHeight: 0
      };
      for ( var i=0; i < measurementsLength; i++ ) {
        var measurement = measurements[i];
        size[ measurement ] = 0;
      }
      return size;
    }
    
    // -------------------------- getStyle -------------------------- //
    
    /**
     * getStyle, get style of element, check for Firefox bug
     * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
     */
    function getStyle( elem ) {
      var style = getComputedStyle( elem );
      if ( !style ) {
        logError( 'Style returned ' + style +
          '. Are you running this code in a hidden iframe on Firefox? ' +
          'See https://bit.ly/getsizebug1' );
      }
      return style;
    }
    
    // -------------------------- setup -------------------------- //
    
    var isSetup = false;
    
    var isBoxSizeOuter;
    
    /**
     * setup
     * check isBoxSizerOuter
     * do on first getSize() rather than on page load for Firefox bug
     */
    function setup() {
      // setup once
      if ( isSetup ) {
        return;
      }
      isSetup = true;
    
      // -------------------------- box sizing -------------------------- //
    
      /**
       * Chrome & Safari measure the outer-width on style.width on border-box elems
       * IE11 & Firefox<29 measures the inner-width
       */
      var div = document.createElement('div');
      div.style.width = '200px';
      div.style.padding = '1px 2px 3px 4px';
      div.style.borderStyle = 'solid';
      div.style.borderWidth = '1px 2px 3px 4px';
      div.style.boxSizing = 'border-box';
    
      var body = document.body || document.documentElement;
      body.appendChild( div );
      var style = getStyle( div );
      // round value for browser zoom. desandro/masonry#928
      isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;
      getSize.isBoxSizeOuter = isBoxSizeOuter;
    
      body.removeChild( div );
    }
    
    // -------------------------- getSize -------------------------- //
    
    function getSize( elem ) {
      setup();
    
      // use querySeletor if elem is string
      if ( typeof elem == 'string' ) {
        elem = document.querySelector( elem );
      }
    
      // do not proceed on non-objects
      if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
        return;
      }
    
      var style = getStyle( elem );
    
      // if hidden, everything is 0
      if ( style.display == 'none' ) {
        return getZeroSize();
      }
    
      var size = {};
      size.width = elem.offsetWidth;
      size.height = elem.offsetHeight;
    
      var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';
    
      // get all measurements
      for ( var i=0; i < measurementsLength; i++ ) {
        var measurement = measurements[i];
        var value = style[ measurement ];
        var num = parseFloat( value );
        // any 'auto', 'medium' value will be 0
        size[ measurement ] = !isNaN( num ) ? num : 0;
      }
    
      var paddingWidth = size.paddingLeft + size.paddingRight;
      var paddingHeight = size.paddingTop + size.paddingBottom;
      var marginWidth = size.marginLeft + size.marginRight;
      var marginHeight = size.marginTop + size.marginBottom;
      var borderWidth = size.borderLeftWidth + size.borderRightWidth;
      var borderHeight = size.borderTopWidth + size.borderBottomWidth;
    
      var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
    
      // overwrite width and height if we can get it from style
      var styleWidth = getStyleSize( style.width );
      if ( styleWidth !== false ) {
        size.width = styleWidth +
          // add padding and border unless it's already including it
          ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
      }
    
      var styleHeight = getStyleSize( style.height );
      if ( styleHeight !== false ) {
        size.height = styleHeight +
          // add padding and border unless it's already including it
          ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
      }
    
      size.innerWidth = size.width - ( paddingWidth + borderWidth );
      size.innerHeight = size.height - ( paddingHeight + borderHeight );
    
      size.outerWidth = size.width + marginWidth;
      size.outerHeight = size.height + marginHeight;
    
      return size;
    }
    
    return getSize;
    
    });
    
    },{}],29:[function(require,module,exports){
    /*!
     * Masonry v4.2.2
     * Cascading grid layout library
     * https://masonry.desandro.com
     * MIT License
     * by David DeSandro
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD
        define( [
            'outlayer/outlayer',
            'get-size/get-size'
          ],
          factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
          require('outlayer'),
          require('get-size')
        );
      } else {
        // browser global
        window.Masonry = factory(
          window.Outlayer,
          window.getSize
        );
      }
    
    }( window, function factory( Outlayer, getSize ) {
    
    'use strict';
    
    // -------------------------- masonryDefinition -------------------------- //
    
      // create an Outlayer layout class
      var Masonry = Outlayer.create('masonry');
      // isFitWidth -> fitWidth
      Masonry.compatOptions.fitWidth = 'isFitWidth';
    
      var proto = Masonry.prototype;
    
      proto._resetLayout = function() {
        this.getSize();
        this._getMeasurement( 'columnWidth', 'outerWidth' );
        this._getMeasurement( 'gutter', 'outerWidth' );
        this.measureColumns();
    
        // reset column Y
        this.colYs = [];
        for ( var i=0; i < this.cols; i++ ) {
          this.colYs.push( 0 );
        }
    
        this.maxY = 0;
        this.horizontalColIndex = 0;
      };
    
      proto.measureColumns = function() {
        this.getContainerWidth();
        // if columnWidth is 0, default to outerWidth of first item
        if ( !this.columnWidth ) {
          var firstItem = this.items[0];
          var firstItemElem = firstItem && firstItem.element;
          // columnWidth fall back to item of first element
          this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||
            // if first elem has no width, default to size of container
            this.containerWidth;
        }
    
        var columnWidth = this.columnWidth += this.gutter;
    
        // calculate columns
        var containerWidth = this.containerWidth + this.gutter;
        var cols = containerWidth / columnWidth;
        // fix rounding errors, typically with gutters
        var excess = columnWidth - containerWidth % columnWidth;
        // if overshoot is less than a pixel, round up, otherwise floor it
        var mathMethod = excess && excess < 1 ? 'round' : 'floor';
        cols = Math[ mathMethod ]( cols );
        this.cols = Math.max( cols, 1 );
      };
    
      proto.getContainerWidth = function() {
        // container is parent if fit width
        var isFitWidth = this._getOption('fitWidth');
        var container = isFitWidth ? this.element.parentNode : this.element;
        // check that this.size and size are there
        // IE8 triggers resize on body size change, so they might not be
        var size = getSize( container );
        this.containerWidth = size && size.innerWidth;
      };
    
      proto._getItemLayoutPosition = function( item ) {
        item.getSize();
        // how many columns does this brick span
        var remainder = item.size.outerWidth % this.columnWidth;
        var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
        // round if off by 1 pixel, otherwise use ceil
        var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
        colSpan = Math.min( colSpan, this.cols );
        // use horizontal or top column position
        var colPosMethod = this.options.horizontalOrder ?
          '_getHorizontalColPosition' : '_getTopColPosition';
        var colPosition = this[ colPosMethod ]( colSpan, item );
        // position the brick
        var position = {
          x: this.columnWidth * colPosition.col,
          y: colPosition.y
        };
        // apply setHeight to necessary columns
        var setHeight = colPosition.y + item.size.outerHeight;
        var setMax = colSpan + colPosition.col;
        for ( var i = colPosition.col; i < setMax; i++ ) {
          this.colYs[i] = setHeight;
        }
    
        return position;
      };
    
      proto._getTopColPosition = function( colSpan ) {
        var colGroup = this._getTopColGroup( colSpan );
        // get the minimum Y value from the columns
        var minimumY = Math.min.apply( Math, colGroup );
    
        return {
          col: colGroup.indexOf( minimumY ),
          y: minimumY,
        };
      };
    
      /**
       * @param {Number} colSpan - number of columns the element spans
       * @returns {Array} colGroup
       */
      proto._getTopColGroup = function( colSpan ) {
        if ( colSpan < 2 ) {
          // if brick spans only one column, use all the column Ys
          return this.colYs;
        }
    
        var colGroup = [];
        // how many different places could this brick fit horizontally
        var groupCount = this.cols + 1 - colSpan;
        // for each group potential horizontal position
        for ( var i = 0; i < groupCount; i++ ) {
          colGroup[i] = this._getColGroupY( i, colSpan );
        }
        return colGroup;
      };
    
      proto._getColGroupY = function( col, colSpan ) {
        if ( colSpan < 2 ) {
          return this.colYs[ col ];
        }
        // make an array of colY values for that one group
        var groupColYs = this.colYs.slice( col, col + colSpan );
        // and get the max value of the array
        return Math.max.apply( Math, groupColYs );
      };
    
      // get column position based on horizontal index. #873
      proto._getHorizontalColPosition = function( colSpan, item ) {
        var col = this.horizontalColIndex % this.cols;
        var isOver = colSpan > 1 && col + colSpan > this.cols;
        // shift to next row if item can't fit on current row
        col = isOver ? 0 : col;
        // don't let zero-size items take up space
        var hasSize = item.size.outerWidth && item.size.outerHeight;
        this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;
    
        return {
          col: col,
          y: this._getColGroupY( col, colSpan ),
        };
      };
    
      proto._manageStamp = function( stamp ) {
        var stampSize = getSize( stamp );
        var offset = this._getElementOffset( stamp );
        // get the columns that this stamp affects
        var isOriginLeft = this._getOption('originLeft');
        var firstX = isOriginLeft ? offset.left : offset.right;
        var lastX = firstX + stampSize.outerWidth;
        var firstCol = Math.floor( firstX / this.columnWidth );
        firstCol = Math.max( 0, firstCol );
        var lastCol = Math.floor( lastX / this.columnWidth );
        // lastCol should not go over if multiple of columnWidth #425
        lastCol -= lastX % this.columnWidth ? 0 : 1;
        lastCol = Math.min( this.cols - 1, lastCol );
        // set colYs to bottom of the stamp
    
        var isOriginTop = this._getOption('originTop');
        var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +
          stampSize.outerHeight;
        for ( var i = firstCol; i <= lastCol; i++ ) {
          this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );
        }
      };
    
      proto._getContainerSize = function() {
        this.maxY = Math.max.apply( Math, this.colYs );
        var size = {
          height: this.maxY
        };
    
        if ( this._getOption('fitWidth') ) {
          size.width = this._getContainerFitWidth();
        }
    
        return size;
      };
    
      proto._getContainerFitWidth = function() {
        var unusedCols = 0;
        // count unused columns
        var i = this.cols;
        while ( --i ) {
          if ( this.colYs[i] !== 0 ) {
            break;
          }
          unusedCols++;
        }
        // fit container to columns that have been used
        return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
      };
    
      proto.needsResizeLayout = function() {
        var previousWidth = this.containerWidth;
        this.getContainerWidth();
        return previousWidth != this.containerWidth;
      };
    
      return Masonry;
    
    }));
    
    },{"get-size":30,"outlayer":35}],30:[function(require,module,exports){
    arguments[4][28][0].apply(exports,arguments)
    },{"dup":28}],31:[function(require,module,exports){
    /**
     * Outlayer Item
     */
    
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /* globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD - RequireJS
        define( [
            'ev-emitter/ev-emitter',
            'get-size/get-size'
          ],
          factory
        );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS - Browserify, Webpack
        module.exports = factory(
          require('ev-emitter'),
          require('get-size')
        );
      } else {
        // browser global
        window.Outlayer = {};
        window.Outlayer.Item = factory(
          window.EvEmitter,
          window.getSize
        );
      }
    
    }( window, function factory( EvEmitter, getSize ) {
    'use strict';
    
    // ----- helpers ----- //
    
    function isEmptyObj( obj ) {
      for ( var prop in obj ) {
        return false;
      }
      prop = null;
      return true;
    }
    
    // -------------------------- CSS3 support -------------------------- //
    
    
    var docElemStyle = document.documentElement.style;
    
    var transitionProperty = typeof docElemStyle.transition == 'string' ?
      'transition' : 'WebkitTransition';
    var transformProperty = typeof docElemStyle.transform == 'string' ?
      'transform' : 'WebkitTransform';
    
    var transitionEndEvent = {
      WebkitTransition: 'webkitTransitionEnd',
      transition: 'transitionend'
    }[ transitionProperty ];
    
    // cache all vendor properties that could have vendor prefix
    var vendorProperties = {
      transform: transformProperty,
      transition: transitionProperty,
      transitionDuration: transitionProperty + 'Duration',
      transitionProperty: transitionProperty + 'Property',
      transitionDelay: transitionProperty + 'Delay'
    };
    
    // -------------------------- Item -------------------------- //
    
    function Item( element, layout ) {
      if ( !element ) {
        return;
      }
    
      this.element = element;
      // parent layout class, i.e. Masonry, Isotope, or Packery
      this.layout = layout;
      this.position = {
        x: 0,
        y: 0
      };
    
      this._create();
    }
    
    // inherit EvEmitter
    var proto = Item.prototype = Object.create( EvEmitter.prototype );
    proto.constructor = Item;
    
    proto._create = function() {
      // transition objects
      this._transn = {
        ingProperties: {},
        clean: {},
        onEnd: {}
      };
    
      this.css({
        position: 'absolute'
      });
    };
    
    // trigger specified handler for event type
    proto.handleEvent = function( event ) {
      var method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };
    
    proto.getSize = function() {
      this.size = getSize( this.element );
    };
    
    /**
     * apply CSS styles to element
     * @param {Object} style
     */
    proto.css = function( style ) {
      var elemStyle = this.element.style;
    
      for ( var prop in style ) {
        // use vendor property if available
        var supportedProp = vendorProperties[ prop ] || prop;
        elemStyle[ supportedProp ] = style[ prop ];
      }
    };
    
     // measure position, and sets it
    proto.getPosition = function() {
      var style = getComputedStyle( this.element );
      var isOriginLeft = this.layout._getOption('originLeft');
      var isOriginTop = this.layout._getOption('originTop');
      var xValue = style[ isOriginLeft ? 'left' : 'right' ];
      var yValue = style[ isOriginTop ? 'top' : 'bottom' ];
      var x = parseFloat( xValue );
      var y = parseFloat( yValue );
      // convert percent to pixels
      var layoutSize = this.layout.size;
      if ( xValue.indexOf('%') != -1 ) {
        x = ( x / 100 ) * layoutSize.width;
      }
      if ( yValue.indexOf('%') != -1 ) {
        y = ( y / 100 ) * layoutSize.height;
      }
      // clean up 'auto' or other non-integer values
      x = isNaN( x ) ? 0 : x;
      y = isNaN( y ) ? 0 : y;
      // remove padding from measurement
      x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
      y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
    
      this.position.x = x;
      this.position.y = y;
    };
    
    // set settled position, apply padding
    proto.layoutPosition = function() {
      var layoutSize = this.layout.size;
      var style = {};
      var isOriginLeft = this.layout._getOption('originLeft');
      var isOriginTop = this.layout._getOption('originTop');
    
      // x
      var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
      var xProperty = isOriginLeft ? 'left' : 'right';
      var xResetProperty = isOriginLeft ? 'right' : 'left';
    
      var x = this.position.x + layoutSize[ xPadding ];
      // set in percentage or pixels
      style[ xProperty ] = this.getXValue( x );
      // reset other property
      style[ xResetProperty ] = '';
    
      // y
      var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
      var yProperty = isOriginTop ? 'top' : 'bottom';
      var yResetProperty = isOriginTop ? 'bottom' : 'top';
    
      var y = this.position.y + layoutSize[ yPadding ];
      // set in percentage or pixels
      style[ yProperty ] = this.getYValue( y );
      // reset other property
      style[ yResetProperty ] = '';
    
      this.css( style );
      this.emitEvent( 'layout', [ this ] );
    };
    
    proto.getXValue = function( x ) {
      var isHorizontal = this.layout._getOption('horizontal');
      return this.layout.options.percentPosition && !isHorizontal ?
        ( ( x / this.layout.size.width ) * 100 ) + '%' : x + 'px';
    };
    
    proto.getYValue = function( y ) {
      var isHorizontal = this.layout._getOption('horizontal');
      return this.layout.options.percentPosition && isHorizontal ?
        ( ( y / this.layout.size.height ) * 100 ) + '%' : y + 'px';
    };
    
    proto._transitionTo = function( x, y ) {
      this.getPosition();
      // get current x & y from top/left
      var curX = this.position.x;
      var curY = this.position.y;
    
      var didNotMove = x == this.position.x && y == this.position.y;
    
      // save end position
      this.setPosition( x, y );
    
      // if did not move and not transitioning, just go to layout
      if ( didNotMove && !this.isTransitioning ) {
        this.layoutPosition();
        return;
      }
    
      var transX = x - curX;
      var transY = y - curY;
      var transitionStyle = {};
      transitionStyle.transform = this.getTranslate( transX, transY );
    
      this.transition({
        to: transitionStyle,
        onTransitionEnd: {
          transform: this.layoutPosition
        },
        isCleaning: true
      });
    };
    
    proto.getTranslate = function( x, y ) {
      // flip cooridinates if origin on right or bottom
      var isOriginLeft = this.layout._getOption('originLeft');
      var isOriginTop = this.layout._getOption('originTop');
      x = isOriginLeft ? x : -x;
      y = isOriginTop ? y : -y;
      return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
    };
    
    // non transition + transform support
    proto.goTo = function( x, y ) {
      this.setPosition( x, y );
      this.layoutPosition();
    };
    
    proto.moveTo = proto._transitionTo;
    
    proto.setPosition = function( x, y ) {
      this.position.x = parseFloat( x );
      this.position.y = parseFloat( y );
    };
    
    // ----- transition ----- //
    
    /**
     * @param {Object} style - CSS
     * @param {Function} onTransitionEnd
     */
    
    // non transition, just trigger callback
    proto._nonTransition = function( args ) {
      this.css( args.to );
      if ( args.isCleaning ) {
        this._removeStyles( args.to );
      }
      for ( var prop in args.onTransitionEnd ) {
        args.onTransitionEnd[ prop ].call( this );
      }
    };
    
    /**
     * proper transition
     * @param {Object} args - arguments
     *   @param {Object} to - style to transition to
     *   @param {Object} from - style to start transition from
     *   @param {Boolean} isCleaning - removes transition styles after transition
     *   @param {Function} onTransitionEnd - callback
     */
    proto.transition = function( args ) {
      // redirect to nonTransition if no transition duration
      if ( !parseFloat( this.layout.options.transitionDuration ) ) {
        this._nonTransition( args );
        return;
      }
    
      var _transition = this._transn;
      // keep track of onTransitionEnd callback by css property
      for ( var prop in args.onTransitionEnd ) {
        _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
      }
      // keep track of properties that are transitioning
      for ( prop in args.to ) {
        _transition.ingProperties[ prop ] = true;
        // keep track of properties to clean up when transition is done
        if ( args.isCleaning ) {
          _transition.clean[ prop ] = true;
        }
      }
    
      // set from styles
      if ( args.from ) {
        this.css( args.from );
        // force redraw. http://blog.alexmaccaw.com/css-transitions
        var h = this.element.offsetHeight;
        // hack for JSHint to hush about unused var
        h = null;
      }
      // enable transition
      this.enableTransition( args.to );
      // set styles that are transitioning
      this.css( args.to );
    
      this.isTransitioning = true;
    
    };
    
    // dash before all cap letters, including first for
    // WebkitTransform => -webkit-transform
    function toDashedAll( str ) {
      return str.replace( /([A-Z])/g, function( $1 ) {
        return '-' + $1.toLowerCase();
      });
    }
    
    var transitionProps = 'opacity,' + toDashedAll( transformProperty );
    
    proto.enableTransition = function(/* style */) {
      // HACK changing transitionProperty during a transition
      // will cause transition to jump
      if ( this.isTransitioning ) {
        return;
      }
    
      // make `transition: foo, bar, baz` from style object
      // HACK un-comment this when enableTransition can work
      // while a transition is happening
      // var transitionValues = [];
      // for ( var prop in style ) {
      //   // dash-ify camelCased properties like WebkitTransition
      //   prop = vendorProperties[ prop ] || prop;
      //   transitionValues.push( toDashedAll( prop ) );
      // }
      // munge number to millisecond, to match stagger
      var duration = this.layout.options.transitionDuration;
      duration = typeof duration == 'number' ? duration + 'ms' : duration;
      // enable transition styles
      this.css({
        transitionProperty: transitionProps,
        transitionDuration: duration,
        transitionDelay: this.staggerDelay || 0
      });
      // listen for transition end event
      this.element.addEventListener( transitionEndEvent, this, false );
    };
    
    // ----- events ----- //
    
    proto.onwebkitTransitionEnd = function( event ) {
      this.ontransitionend( event );
    };
    
    proto.onotransitionend = function( event ) {
      this.ontransitionend( event );
    };
    
    // properties that I munge to make my life easier
    var dashedVendorProperties = {
      '-webkit-transform': 'transform'
    };
    
    proto.ontransitionend = function( event ) {
      // disregard bubbled events from children
      if ( event.target !== this.element ) {
        return;
      }
      var _transition = this._transn;
      // get property name of transitioned property, convert to prefix-free
      var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;
    
      // remove property that has completed transitioning
      delete _transition.ingProperties[ propertyName ];
      // check if any properties are still transitioning
      if ( isEmptyObj( _transition.ingProperties ) ) {
        // all properties have completed transitioning
        this.disableTransition();
      }
      // clean style
      if ( propertyName in _transition.clean ) {
        // clean up style
        this.element.style[ event.propertyName ] = '';
        delete _transition.clean[ propertyName ];
      }
      // trigger onTransitionEnd callback
      if ( propertyName in _transition.onEnd ) {
        var onTransitionEnd = _transition.onEnd[ propertyName ];
        onTransitionEnd.call( this );
        delete _transition.onEnd[ propertyName ];
      }
    
      this.emitEvent( 'transitionEnd', [ this ] );
    };
    
    proto.disableTransition = function() {
      this.removeTransitionStyles();
      this.element.removeEventListener( transitionEndEvent, this, false );
      this.isTransitioning = false;
    };
    
    /**
     * removes style property from element
     * @param {Object} style
    **/
    proto._removeStyles = function( style ) {
      // clean up transition styles
      var cleanStyle = {};
      for ( var prop in style ) {
        cleanStyle[ prop ] = '';
      }
      this.css( cleanStyle );
    };
    
    var cleanTransitionStyle = {
      transitionProperty: '',
      transitionDuration: '',
      transitionDelay: ''
    };
    
    proto.removeTransitionStyles = function() {
      // remove transition
      this.css( cleanTransitionStyle );
    };
    
    // ----- stagger ----- //
    
    proto.stagger = function( delay ) {
      delay = isNaN( delay ) ? 0 : delay;
      this.staggerDelay = delay + 'ms';
    };
    
    // ----- show/hide/remove ----- //
    
    // remove element from DOM
    proto.removeElem = function() {
      this.element.parentNode.removeChild( this.element );
      // remove display: none
      this.css({ display: '' });
      this.emitEvent( 'remove', [ this ] );
    };
    
    proto.remove = function() {
      // just remove element if no transition support or no transition
      if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
        this.removeElem();
        return;
      }
    
      // start transition
      this.once( 'transitionEnd', function() {
        this.removeElem();
      });
      this.hide();
    };
    
    proto.reveal = function() {
      delete this.isHidden;
      // remove display: none
      this.css({ display: '' });
    
      var options = this.layout.options;
    
      var onTransitionEnd = {};
      var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
      onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;
    
      this.transition({
        from: options.hiddenStyle,
        to: options.visibleStyle,
        isCleaning: true,
        onTransitionEnd: onTransitionEnd
      });
    };
    
    proto.onRevealTransitionEnd = function() {
      // check if still visible
      // during transition, item may have been hidden
      if ( !this.isHidden ) {
        this.emitEvent('reveal');
      }
    };
    
    /**
     * get style property use for hide/reveal transition end
     * @param {String} styleProperty - hiddenStyle/visibleStyle
     * @returns {String}
     */
    proto.getHideRevealTransitionEndProperty = function( styleProperty ) {
      var optionStyle = this.layout.options[ styleProperty ];
      // use opacity
      if ( optionStyle.opacity ) {
        return 'opacity';
      }
      // get first property
      for ( var prop in optionStyle ) {
        return prop;
      }
    };
    
    proto.hide = function() {
      // set flag
      this.isHidden = true;
      // remove display: none
      this.css({ display: '' });
    
      var options = this.layout.options;
    
      var onTransitionEnd = {};
      var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
      onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;
    
      this.transition({
        from: options.visibleStyle,
        to: options.hiddenStyle,
        // keep hidden stuff hidden
        isCleaning: true,
        onTransitionEnd: onTransitionEnd
      });
    };
    
    proto.onHideTransitionEnd = function() {
      // check if still hidden
      // during transition, item may have been un-hidden
      if ( this.isHidden ) {
        this.css({ display: 'none' });
        this.emitEvent('hide');
      }
    };
    
    proto.destroy = function() {
      this.css({
        position: '',
        left: '',
        right: '',
        top: '',
        bottom: '',
        transition: '',
        transform: ''
      });
    };
    
    return Item;
    
    }));
    
    },{"ev-emitter":32,"get-size":34}],32:[function(require,module,exports){
    /**
     * EvEmitter v1.1.0
     * Lil' event emitter
     * MIT License
     */
    
    /* jshint unused: true, undef: true, strict: true */
    
    ( function( global, factory ) {
      // universal module definition
      /* jshint strict: false */ /* globals define, module, window */
      if ( typeof define == 'function' && define.amd ) {
        // AMD - RequireJS
        define( factory );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS - Browserify, Webpack
        module.exports = factory();
      } else {
        // Browser globals
        global.EvEmitter = factory();
      }
    
    }( typeof window != 'undefined' ? window : this, function() {
    
    "use strict";
    
    function EvEmitter() {}
    
    var proto = EvEmitter.prototype;
    
    proto.on = function( eventName, listener ) {
      if ( !eventName || !listener ) {
        return;
      }
      // set events hash
      var events = this._events = this._events || {};
      // set listeners array
      var listeners = events[ eventName ] = events[ eventName ] || [];
      // only add once
      if ( listeners.indexOf( listener ) == -1 ) {
        listeners.push( listener );
      }
    
      return this;
    };
    
    proto.once = function( eventName, listener ) {
      if ( !eventName || !listener ) {
        return;
      }
      // add event
      this.on( eventName, listener );
      // set once flag
      // set onceEvents hash
      var onceEvents = this._onceEvents = this._onceEvents || {};
      // set onceListeners object
      var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
      // set flag
      onceListeners[ listener ] = true;
    
      return this;
    };
    
    proto.off = function( eventName, listener ) {
      var listeners = this._events && this._events[ eventName ];
      if ( !listeners || !listeners.length ) {
        return;
      }
      var index = listeners.indexOf( listener );
      if ( index != -1 ) {
        listeners.splice( index, 1 );
      }
    
      return this;
    };
    
    proto.emitEvent = function( eventName, args ) {
      var listeners = this._events && this._events[ eventName ];
      if ( !listeners || !listeners.length ) {
        return;
      }
      // copy over to avoid interference if .off() in listener
      listeners = listeners.slice(0);
      args = args || [];
      // once stuff
      var onceListeners = this._onceEvents && this._onceEvents[ eventName ];
    
      for ( var i=0; i < listeners.length; i++ ) {
        var listener = listeners[i]
        var isOnce = onceListeners && onceListeners[ listener ];
        if ( isOnce ) {
          // remove listener
          // remove before trigger to prevent recursion
          this.off( eventName, listener );
          // unset once flag
          delete onceListeners[ listener ];
        }
        // trigger listener
        listener.apply( this, args );
      }
    
      return this;
    };
    
    proto.allOff = function() {
      delete this._events;
      delete this._onceEvents;
    };
    
    return EvEmitter;
    
    }));
    
    },{}],33:[function(require,module,exports){
    arguments[4][27][0].apply(exports,arguments)
    },{"desandro-matches-selector":4,"dup":27}],34:[function(require,module,exports){
    arguments[4][28][0].apply(exports,arguments)
    },{"dup":28}],35:[function(require,module,exports){
    /*!
     * Outlayer v2.1.1
     * the brains and guts of a layout library
     * MIT license
     */
    
    ( function( window, factory ) {
      'use strict';
      // universal module definition
      /* jshint strict: false */ /* globals define, module, require */
      if ( typeof define == 'function' && define.amd ) {
        // AMD - RequireJS
        define( [
            'ev-emitter/ev-emitter',
            'get-size/get-size',
            'fizzy-ui-utils/utils',
            './item'
          ],
          function( EvEmitter, getSize, utils, Item ) {
            return factory( window, EvEmitter, getSize, utils, Item);
          }
        );
      } else if ( typeof module == 'object' && module.exports ) {
        // CommonJS - Browserify, Webpack
        module.exports = factory(
          window,
          require('ev-emitter'),
          require('get-size'),
          require('fizzy-ui-utils'),
          require('./item')
        );
      } else {
        // browser global
        window.Outlayer = factory(
          window,
          window.EvEmitter,
          window.getSize,
          window.fizzyUIUtils,
          window.Outlayer.Item
        );
      }
    
    }( window, function factory( window, EvEmitter, getSize, utils, Item ) {
    'use strict';
    
    // ----- vars ----- //
    
    var console = window.console;
    var jQuery = window.jQuery;
    var noop = function() {};
    
    // -------------------------- Outlayer -------------------------- //
    
    // globally unique identifiers
    var GUID = 0;
    // internal store of all Outlayer intances
    var instances = {};
    
    
    /**
     * @param {Element, String} element
     * @param {Object} options
     * @constructor
     */
    function Outlayer( element, options ) {
      var queryElement = utils.getQueryElement( element );
      if ( !queryElement ) {
        if ( console ) {
          console.error( 'Bad element for ' + this.constructor.namespace +
            ': ' + ( queryElement || element ) );
        }
        return;
      }
      this.element = queryElement;
      // add jQuery
      if ( jQuery ) {
        this.$element = jQuery( this.element );
      }
    
      // options
      this.options = utils.extend( {}, this.constructor.defaults );
      this.option( options );
    
      // add id for Outlayer.getFromElement
      var id = ++GUID;
      this.element.outlayerGUID = id; // expando
      instances[ id ] = this; // associate via id
    
      // kick it off
      this._create();
    
      var isInitLayout = this._getOption('initLayout');
      if ( isInitLayout ) {
        this.layout();
      }
    }
    
    // settings are for internal use only
    Outlayer.namespace = 'outlayer';
    Outlayer.Item = Item;
    
    // default options
    Outlayer.defaults = {
      containerStyle: {
        position: 'relative'
      },
      initLayout: true,
      originLeft: true,
      originTop: true,
      resize: true,
      resizeContainer: true,
      // item options
      transitionDuration: '0.4s',
      hiddenStyle: {
        opacity: 0,
        transform: 'scale(0.001)'
      },
      visibleStyle: {
        opacity: 1,
        transform: 'scale(1)'
      }
    };
    
    var proto = Outlayer.prototype;
    // inherit EvEmitter
    utils.extend( proto, EvEmitter.prototype );
    
    /**
     * set options
     * @param {Object} opts
     */
    proto.option = function( opts ) {
      utils.extend( this.options, opts );
    };
    
    /**
     * get backwards compatible option value, check old name
     */
    proto._getOption = function( option ) {
      var oldOption = this.constructor.compatOptions[ option ];
      return oldOption && this.options[ oldOption ] !== undefined ?
        this.options[ oldOption ] : this.options[ option ];
    };
    
    Outlayer.compatOptions = {
      // currentName: oldName
      initLayout: 'isInitLayout',
      horizontal: 'isHorizontal',
      layoutInstant: 'isLayoutInstant',
      originLeft: 'isOriginLeft',
      originTop: 'isOriginTop',
      resize: 'isResizeBound',
      resizeContainer: 'isResizingContainer'
    };
    
    proto._create = function() {
      // get items from children
      this.reloadItems();
      // elements that affect layout, but are not laid out
      this.stamps = [];
      this.stamp( this.options.stamp );
      // set container style
      utils.extend( this.element.style, this.options.containerStyle );
    
      // bind resize method
      var canBindResize = this._getOption('resize');
      if ( canBindResize ) {
        this.bindResize();
      }
    };
    
    // goes through all children again and gets bricks in proper order
    proto.reloadItems = function() {
      // collection of item elements
      this.items = this._itemize( this.element.children );
    };
    
    
    /**
     * turn elements into Outlayer.Items to be used in layout
     * @param {Array or NodeList or HTMLElement} elems
     * @returns {Array} items - collection of new Outlayer Items
     */
    proto._itemize = function( elems ) {
    
      var itemElems = this._filterFindItemElements( elems );
      var Item = this.constructor.Item;
    
      // create new Outlayer Items for collection
      var items = [];
      for ( var i=0; i < itemElems.length; i++ ) {
        var elem = itemElems[i];
        var item = new Item( elem, this );
        items.push( item );
      }
    
      return items;
    };
    
    /**
     * get item elements to be used in layout
     * @param {Array or NodeList or HTMLElement} elems
     * @returns {Array} items - item elements
     */
    proto._filterFindItemElements = function( elems ) {
      return utils.filterFindElements( elems, this.options.itemSelector );
    };
    
    /**
     * getter method for getting item elements
     * @returns {Array} elems - collection of item elements
     */
    proto.getItemElements = function() {
      return this.items.map( function( item ) {
        return item.element;
      });
    };
    
    // ----- init & layout ----- //
    
    /**
     * lays out all items
     */
    proto.layout = function() {
      this._resetLayout();
      this._manageStamps();
    
      // don't animate first layout
      var layoutInstant = this._getOption('layoutInstant');
      var isInstant = layoutInstant !== undefined ?
        layoutInstant : !this._isLayoutInited;
      this.layoutItems( this.items, isInstant );
    
      // flag for initalized
      this._isLayoutInited = true;
    };
    
    // _init is alias for layout
    proto._init = proto.layout;
    
    /**
     * logic before any new layout
     */
    proto._resetLayout = function() {
      this.getSize();
    };
    
    
    proto.getSize = function() {
      this.size = getSize( this.element );
    };
    
    /**
     * get measurement from option, for columnWidth, rowHeight, gutter
     * if option is String -> get element from selector string, & get size of element
     * if option is Element -> get size of element
     * else use option as a number
     *
     * @param {String} measurement
     * @param {String} size - width or height
     * @private
     */
    proto._getMeasurement = function( measurement, size ) {
      var option = this.options[ measurement ];
      var elem;
      if ( !option ) {
        // default to 0
        this[ measurement ] = 0;
      } else {
        // use option as an element
        if ( typeof option == 'string' ) {
          elem = this.element.querySelector( option );
        } else if ( option instanceof HTMLElement ) {
          elem = option;
        }
        // use size of element, if element
        this[ measurement ] = elem ? getSize( elem )[ size ] : option;
      }
    };
    
    /**
     * layout a collection of item elements
     * @api public
     */
    proto.layoutItems = function( items, isInstant ) {
      items = this._getItemsForLayout( items );
    
      this._layoutItems( items, isInstant );
    
      this._postLayout();
    };
    
    /**
     * get the items to be laid out
     * you may want to skip over some items
     * @param {Array} items
     * @returns {Array} items
     */
    proto._getItemsForLayout = function( items ) {
      return items.filter( function( item ) {
        return !item.isIgnored;
      });
    };
    
    /**
     * layout items
     * @param {Array} items
     * @param {Boolean} isInstant
     */
    proto._layoutItems = function( items, isInstant ) {
      this._emitCompleteOnItems( 'layout', items );
    
      if ( !items || !items.length ) {
        // no items, emit event with empty array
        return;
      }
    
      var queue = [];
    
      items.forEach( function( item ) {
        // get x/y object from method
        var position = this._getItemLayoutPosition( item );
        // enqueue
        position.item = item;
        position.isInstant = isInstant || item.isLayoutInstant;
        queue.push( position );
      }, this );
    
      this._processLayoutQueue( queue );
    };
    
    /**
     * get item layout position
     * @param {Outlayer.Item} item
     * @returns {Object} x and y position
     */
    proto._getItemLayoutPosition = function( /* item */ ) {
      return {
        x: 0,
        y: 0
      };
    };
    
    /**
     * iterate over array and position each item
     * Reason being - separating this logic prevents 'layout invalidation'
     * thx @paul_irish
     * @param {Array} queue
     */
    proto._processLayoutQueue = function( queue ) {
      this.updateStagger();
      queue.forEach( function( obj, i ) {
        this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
      }, this );
    };
    
    // set stagger from option in milliseconds number
    proto.updateStagger = function() {
      var stagger = this.options.stagger;
      if ( stagger === null || stagger === undefined ) {
        this.stagger = 0;
        return;
      }
      this.stagger = getMilliseconds( stagger );
      return this.stagger;
    };
    
    /**
     * Sets position of item in DOM
     * @param {Outlayer.Item} item
     * @param {Number} x - horizontal position
     * @param {Number} y - vertical position
     * @param {Boolean} isInstant - disables transitions
     */
    proto._positionItem = function( item, x, y, isInstant, i ) {
      if ( isInstant ) {
        // if not transition, just set CSS
        item.goTo( x, y );
      } else {
        item.stagger( i * this.stagger );
        item.moveTo( x, y );
      }
    };
    
    /**
     * Any logic you want to do after each layout,
     * i.e. size the container
     */
    proto._postLayout = function() {
      this.resizeContainer();
    };
    
    proto.resizeContainer = function() {
      var isResizingContainer = this._getOption('resizeContainer');
      if ( !isResizingContainer ) {
        return;
      }
      var size = this._getContainerSize();
      if ( size ) {
        this._setContainerMeasure( size.width, true );
        this._setContainerMeasure( size.height, false );
      }
    };
    
    /**
     * Sets width or height of container if returned
     * @returns {Object} size
     *   @param {Number} width
     *   @param {Number} height
     */
    proto._getContainerSize = noop;
    
    /**
     * @param {Number} measure - size of width or height
     * @param {Boolean} isWidth
     */
    proto._setContainerMeasure = function( measure, isWidth ) {
      if ( measure === undefined ) {
        return;
      }
    
      var elemSize = this.size;
      // add padding and border width if border box
      if ( elemSize.isBorderBox ) {
        measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
          elemSize.borderLeftWidth + elemSize.borderRightWidth :
          elemSize.paddingBottom + elemSize.paddingTop +
          elemSize.borderTopWidth + elemSize.borderBottomWidth;
      }
    
      measure = Math.max( measure, 0 );
      this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';
    };
    
    /**
     * emit eventComplete on a collection of items events
     * @param {String} eventName
     * @param {Array} items - Outlayer.Items
     */
    proto._emitCompleteOnItems = function( eventName, items ) {
      var _this = this;
      function onComplete() {
        _this.dispatchEvent( eventName + 'Complete', null, [ items ] );
      }
    
      var count = items.length;
      if ( !items || !count ) {
        onComplete();
        return;
      }
    
      var doneCount = 0;
      function tick() {
        doneCount++;
        if ( doneCount == count ) {
          onComplete();
        }
      }
    
      // bind callback
      items.forEach( function( item ) {
        item.once( eventName, tick );
      });
    };
    
    /**
     * emits events via EvEmitter and jQuery events
     * @param {String} type - name of event
     * @param {Event} event - original event
     * @param {Array} args - extra arguments
     */
    proto.dispatchEvent = function( type, event, args ) {
      // add original event to arguments
      var emitArgs = event ? [ event ].concat( args ) : args;
      this.emitEvent( type, emitArgs );
    
      if ( jQuery ) {
        // set this.$element
        this.$element = this.$element || jQuery( this.element );
        if ( event ) {
          // create jQuery event
          var $event = jQuery.Event( event );
          $event.type = type;
          this.$element.trigger( $event, args );
        } else {
          // just trigger with type if no event available
          this.$element.trigger( type, args );
        }
      }
    };
    
    // -------------------------- ignore & stamps -------------------------- //
    
    
    /**
     * keep item in collection, but do not lay it out
     * ignored items do not get skipped in layout
     * @param {Element} elem
     */
    proto.ignore = function( elem ) {
      var item = this.getItem( elem );
      if ( item ) {
        item.isIgnored = true;
      }
    };
    
    /**
     * return item to layout collection
     * @param {Element} elem
     */
    proto.unignore = function( elem ) {
      var item = this.getItem( elem );
      if ( item ) {
        delete item.isIgnored;
      }
    };
    
    /**
     * adds elements to stamps
     * @param {NodeList, Array, Element, or String} elems
     */
    proto.stamp = function( elems ) {
      elems = this._find( elems );
      if ( !elems ) {
        return;
      }
    
      this.stamps = this.stamps.concat( elems );
      // ignore
      elems.forEach( this.ignore, this );
    };
    
    /**
     * removes elements to stamps
     * @param {NodeList, Array, or Element} elems
     */
    proto.unstamp = function( elems ) {
      elems = this._find( elems );
      if ( !elems ){
        return;
      }
    
      elems.forEach( function( elem ) {
        // filter out removed stamp elements
        utils.removeFrom( this.stamps, elem );
        this.unignore( elem );
      }, this );
    };
    
    /**
     * finds child elements
     * @param {NodeList, Array, Element, or String} elems
     * @returns {Array} elems
     */
    proto._find = function( elems ) {
      if ( !elems ) {
        return;
      }
      // if string, use argument as selector string
      if ( typeof elems == 'string' ) {
        elems = this.element.querySelectorAll( elems );
      }
      elems = utils.makeArray( elems );
      return elems;
    };
    
    proto._manageStamps = function() {
      if ( !this.stamps || !this.stamps.length ) {
        return;
      }
    
      this._getBoundingRect();
    
      this.stamps.forEach( this._manageStamp, this );
    };
    
    // update boundingLeft / Top
    proto._getBoundingRect = function() {
      // get bounding rect for container element
      var boundingRect = this.element.getBoundingClientRect();
      var size = this.size;
      this._boundingRect = {
        left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
        top: boundingRect.top + size.paddingTop + size.borderTopWidth,
        right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
        bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
      };
    };
    
    /**
     * @param {Element} stamp
    **/
    proto._manageStamp = noop;
    
    /**
     * get x/y position of element relative to container element
     * @param {Element} elem
     * @returns {Object} offset - has left, top, right, bottom
     */
    proto._getElementOffset = function( elem ) {
      var boundingRect = elem.getBoundingClientRect();
      var thisRect = this._boundingRect;
      var size = getSize( elem );
      var offset = {
        left: boundingRect.left - thisRect.left - size.marginLeft,
        top: boundingRect.top - thisRect.top - size.marginTop,
        right: thisRect.right - boundingRect.right - size.marginRight,
        bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
      };
      return offset;
    };
    
    // -------------------------- resize -------------------------- //
    
    // enable event handlers for listeners
    // i.e. resize -> onresize
    proto.handleEvent = utils.handleEvent;
    
    /**
     * Bind layout to window resizing
     */
    proto.bindResize = function() {
      window.addEventListener( 'resize', this );
      this.isResizeBound = true;
    };
    
    /**
     * Unbind layout to window resizing
     */
    proto.unbindResize = function() {
      window.removeEventListener( 'resize', this );
      this.isResizeBound = false;
    };
    
    proto.onresize = function() {
      this.resize();
    };
    
    utils.debounceMethod( Outlayer, 'onresize', 100 );
    
    proto.resize = function() {
      // don't trigger if size did not change
      // or if resize was unbound. See #9
      if ( !this.isResizeBound || !this.needsResizeLayout() ) {
        return;
      }
    
      this.layout();
    };
    
    /**
     * check if layout is needed post layout
     * @returns Boolean
     */
    proto.needsResizeLayout = function() {
      var size = getSize( this.element );
      // check that this.size and size are there
      // IE8 triggers resize on body size change, so they might not be
      var hasSizes = this.size && size;
      return hasSizes && size.innerWidth !== this.size.innerWidth;
    };
    
    // -------------------------- methods -------------------------- //
    
    /**
     * add items to Outlayer instance
     * @param {Array or NodeList or Element} elems
     * @returns {Array} items - Outlayer.Items
    **/
    proto.addItems = function( elems ) {
      var items = this._itemize( elems );
      // add items to collection
      if ( items.length ) {
        this.items = this.items.concat( items );
      }
      return items;
    };
    
    /**
     * Layout newly-appended item elements
     * @param {Array or NodeList or Element} elems
     */
    proto.appended = function( elems ) {
      var items = this.addItems( elems );
      if ( !items.length ) {
        return;
      }
      // layout and reveal just the new items
      this.layoutItems( items, true );
      this.reveal( items );
    };
    
    /**
     * Layout prepended elements
     * @param {Array or NodeList or Element} elems
     */
    proto.prepended = function( elems ) {
      var items = this._itemize( elems );
      if ( !items.length ) {
        return;
      }
      // add items to beginning of collection
      var previousItems = this.items.slice(0);
      this.items = items.concat( previousItems );
      // start new layout
      this._resetLayout();
      this._manageStamps();
      // layout new stuff without transition
      this.layoutItems( items, true );
      this.reveal( items );
      // layout previous items
      this.layoutItems( previousItems );
    };
    
    /**
     * reveal a collection of items
     * @param {Array of Outlayer.Items} items
     */
    proto.reveal = function( items ) {
      this._emitCompleteOnItems( 'reveal', items );
      if ( !items || !items.length ) {
        return;
      }
      var stagger = this.updateStagger();
      items.forEach( function( item, i ) {
        item.stagger( i * stagger );
        item.reveal();
      });
    };
    
    /**
     * hide a collection of items
     * @param {Array of Outlayer.Items} items
     */
    proto.hide = function( items ) {
      this._emitCompleteOnItems( 'hide', items );
      if ( !items || !items.length ) {
        return;
      }
      var stagger = this.updateStagger();
      items.forEach( function( item, i ) {
        item.stagger( i * stagger );
        item.hide();
      });
    };
    
    /**
     * reveal item elements
     * @param {Array}, {Element}, {NodeList} items
     */
    proto.revealItemElements = function( elems ) {
      var items = this.getItems( elems );
      this.reveal( items );
    };
    
    /**
     * hide item elements
     * @param {Array}, {Element}, {NodeList} items
     */
    proto.hideItemElements = function( elems ) {
      var items = this.getItems( elems );
      this.hide( items );
    };
    
    /**
     * get Outlayer.Item, given an Element
     * @param {Element} elem
     * @param {Function} callback
     * @returns {Outlayer.Item} item
     */
    proto.getItem = function( elem ) {
      // loop through items to get the one that matches
      for ( var i=0; i < this.items.length; i++ ) {
        var item = this.items[i];
        if ( item.element == elem ) {
          // return item
          return item;
        }
      }
    };
    
    /**
     * get collection of Outlayer.Items, given Elements
     * @param {Array} elems
     * @returns {Array} items - Outlayer.Items
     */
    proto.getItems = function( elems ) {
      elems = utils.makeArray( elems );
      var items = [];
      elems.forEach( function( elem ) {
        var item = this.getItem( elem );
        if ( item ) {
          items.push( item );
        }
      }, this );
    
      return items;
    };
    
    /**
     * remove element(s) from instance and DOM
     * @param {Array or NodeList or Element} elems
     */
    proto.remove = function( elems ) {
      var removeItems = this.getItems( elems );
    
      this._emitCompleteOnItems( 'remove', removeItems );
    
      // bail if no items to remove
      if ( !removeItems || !removeItems.length ) {
        return;
      }
    
      removeItems.forEach( function( item ) {
        item.remove();
        // remove item from collection
        utils.removeFrom( this.items, item );
      }, this );
    };
    
    // ----- destroy ----- //
    
    // remove and disable Outlayer instance
    proto.destroy = function() {
      // clean up dynamic styles
      var style = this.element.style;
      style.height = '';
      style.position = '';
      style.width = '';
      // destroy items
      this.items.forEach( function( item ) {
        item.destroy();
      });
    
      this.unbindResize();
    
      var id = this.element.outlayerGUID;
      delete instances[ id ]; // remove reference to instance by id
      delete this.element.outlayerGUID;
      // remove data for jQuery
      if ( jQuery ) {
        jQuery.removeData( this.element, this.constructor.namespace );
      }
    
    };
    
    // -------------------------- data -------------------------- //
    
    /**
     * get Outlayer instance from element
     * @param {Element} elem
     * @returns {Outlayer}
     */
    Outlayer.data = function( elem ) {
      elem = utils.getQueryElement( elem );
      var id = elem && elem.outlayerGUID;
      return id && instances[ id ];
    };
    
    
    // -------------------------- create Outlayer class -------------------------- //
    
    /**
     * create a layout class
     * @param {String} namespace
     */
    Outlayer.create = function( namespace, options ) {
      // sub-class Outlayer
      var Layout = subclass( Outlayer );
      // apply new options and compatOptions
      Layout.defaults = utils.extend( {}, Outlayer.defaults );
      utils.extend( Layout.defaults, options );
      Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );
    
      Layout.namespace = namespace;
    
      Layout.data = Outlayer.data;
    
      // sub-class Item
      Layout.Item = subclass( Item );
    
      // -------------------------- declarative -------------------------- //
    
      utils.htmlInit( Layout, namespace );
    
      // -------------------------- jQuery bridge -------------------------- //
    
      // make into jQuery plugin
      if ( jQuery && jQuery.bridget ) {
        jQuery.bridget( namespace, Layout );
      }
    
      return Layout;
    };
    
    function subclass( Parent ) {
      function SubClass() {
        Parent.apply( this, arguments );
      }
    
      SubClass.prototype = Object.create( Parent.prototype );
      SubClass.prototype.constructor = SubClass;
    
      return SubClass;
    }
    
    // ----- helpers ----- //
    
    // how many milliseconds are in each unit
    var msUnits = {
      ms: 1,
      s: 1000
    };
    
    // munge time-like parameter into millisecond number
    // '0.4s' -> 40
    function getMilliseconds( time ) {
      if ( typeof time == 'number' ) {
        return time;
      }
      var matches = time.match( /(^\d*\.?\d*)(\w*)/ );
      var num = matches && matches[1];
      var unit = matches && matches[2];
      if ( !num.length ) {
        return 0;
      }
      num = parseFloat( num );
      var mult = msUnits[ unit ] || 1;
      return num * mult;
    }
    
    // ----- fin ----- //
    
    // back in global
    Outlayer.Item = Item;
    
    return Outlayer;
    
    }));
    
    },{"./item":31,"ev-emitter":32,"fizzy-ui-utils":33,"get-size":34}],36:[function(require,module,exports){
    // shim for using process in browser
    var process = module.exports = {};
    
    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.
    
    var cachedSetTimeout;
    var cachedClearTimeout;
    
    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    
    
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    
    
    
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
    
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    
    process.listeners = function (name) { return [] }
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
    },{}],37:[function(require,module,exports){
    /*!
     * Unidragger v3.0.1
     * Draggable base class
     * MIT license
     */
    
    ( function( window, factory ) {
      // universal module definition
      if ( typeof module == 'object' && module.exports ) {
        // CommonJS
        module.exports = factory(
            window,
            require('ev-emitter'),
        );
      } else {
        // browser global
        window.Unidragger = factory(
            window,
            window.EvEmitter,
        );
      }
    
    }( typeof window != 'undefined' ? window : this, function factory( window, EvEmitter ) {
    
    function Unidragger() {}
    
    // inherit EvEmitter
    let proto = Unidragger.prototype = Object.create( EvEmitter.prototype );
    
    // ----- bind start ----- //
    
    // trigger handler methods for events
    proto.handleEvent = function( event ) {
      let method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };
    
    let startEvent, activeEvents;
    if ( 'ontouchstart' in window ) {
      // HACK prefer Touch Events as you can preventDefault on touchstart to
      // disable scroll in iOS & mobile Chrome metafizzy/flickity#1177
      startEvent = 'touchstart';
      activeEvents = [ 'touchmove', 'touchend', 'touchcancel' ];
    } else if ( window.PointerEvent ) {
      // Pointer Events
      startEvent = 'pointerdown';
      activeEvents = [ 'pointermove', 'pointerup', 'pointercancel' ];
    } else {
      // mouse events
      startEvent = 'mousedown';
      activeEvents = [ 'mousemove', 'mouseup' ];
    }
    
    // prototype so it can be overwriteable by Flickity
    proto.touchActionValue = 'none';
    
    proto.bindHandles = function() {
      this._bindHandles( 'addEventListener', this.touchActionValue );
    };
    
    proto.unbindHandles = function() {
      this._bindHandles( 'removeEventListener', '' );
    };
    
    /**
     * Add or remove start event
     * @param {String} bindMethod - addEventListener or removeEventListener
     * @param {String} touchAction - value for touch-action CSS property
     */
    proto._bindHandles = function( bindMethod, touchAction ) {
      this.handles.forEach( ( handle ) => {
        handle[ bindMethod ]( startEvent, this );
        handle[ bindMethod ]( 'click', this );
        // touch-action: none to override browser touch gestures. metafizzy/flickity#540
        if ( window.PointerEvent ) handle.style.touchAction = touchAction;
      } );
    };
    
    proto.bindActivePointerEvents = function() {
      activeEvents.forEach( ( eventName ) => {
        window.addEventListener( eventName, this );
      } );
    };
    
    proto.unbindActivePointerEvents = function() {
      activeEvents.forEach( ( eventName ) => {
        window.removeEventListener( eventName, this );
      } );
    };
    
    // ----- event handler helpers ----- //
    
    // trigger method with matching pointer
    proto.withPointer = function( methodName, event ) {
      if ( event.pointerId === this.pointerIdentifier ) {
        this[ methodName ]( event, event );
      }
    };
    
    // trigger method with matching touch
    proto.withTouch = function( methodName, event ) {
      let touch;
      for ( let changedTouch of event.changedTouches ) {
        if ( changedTouch.identifier === this.pointerIdentifier ) {
          touch = changedTouch;
        }
      }
      if ( touch ) this[ methodName ]( event, touch );
    };
    
    // ----- start event ----- //
    
    proto.onmousedown = function( event ) {
      this.pointerDown( event, event );
    };
    
    proto.ontouchstart = function( event ) {
      this.pointerDown( event, event.changedTouches[0] );
    };
    
    proto.onpointerdown = function( event ) {
      this.pointerDown( event, event );
    };
    
    // nodes that have text fields
    const cursorNodes = [ 'TEXTAREA', 'INPUT', 'SELECT', 'OPTION' ];
    // input types that do not have text fields
    const clickTypes = [ 'radio', 'checkbox', 'button', 'submit', 'image', 'file' ];
    
    /**
     * any time you set `event, pointer` it refers to:
     * @param {Event} event
     * @param {Event | Touch} pointer
     */
    proto.pointerDown = function( event, pointer ) {
      // dismiss multi-touch taps, right clicks, and clicks on text fields
      let isCursorNode = cursorNodes.includes( event.target.nodeName );
      let isClickType = clickTypes.includes( event.target.type );
      let isOkayElement = !isCursorNode || isClickType;
      let isOkay = !this.isPointerDown && !event.button && isOkayElement;
      if ( !isOkay ) return;
    
      this.isPointerDown = true;
      // save pointer identifier to match up touch events
      this.pointerIdentifier = pointer.pointerId !== undefined ?
        // pointerId for pointer events, touch.indentifier for touch events
        pointer.pointerId : pointer.identifier;
      // track position for move
      this.pointerDownPointer = {
        pageX: pointer.pageX,
        pageY: pointer.pageY,
      };
    
      this.bindActivePointerEvents();
      this.emitEvent( 'pointerDown', [ event, pointer ] );
    };
    
    // ----- move ----- //
    
    proto.onmousemove = function( event ) {
      this.pointerMove( event, event );
    };
    
    proto.onpointermove = function( event ) {
      this.withPointer( 'pointerMove', event );
    };
    
    proto.ontouchmove = function( event ) {
      this.withTouch( 'pointerMove', event );
    };
    
    proto.pointerMove = function( event, pointer ) {
      let moveVector = {
        x: pointer.pageX - this.pointerDownPointer.pageX,
        y: pointer.pageY - this.pointerDownPointer.pageY,
      };
      this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
      // start drag if pointer has moved far enough to start drag
      let isDragStarting = !this.isDragging && this.hasDragStarted( moveVector );
      if ( isDragStarting ) this.dragStart( event, pointer );
      if ( this.isDragging ) this.dragMove( event, pointer, moveVector );
    };
    
    // condition if pointer has moved far enough to start drag
    proto.hasDragStarted = function( moveVector ) {
      return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;
    };
    
    // ----- drag ----- //
    
    proto.dragStart = function( event, pointer ) {
      this.isDragging = true;
      this.isPreventingClicks = true; // set flag to prevent clicks
      this.emitEvent( 'dragStart', [ event, pointer ] );
    };
    
    proto.dragMove = function( event, pointer, moveVector ) {
      this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
    };
    
    // ----- end ----- //
    
    proto.onmouseup = function( event ) {
      this.pointerUp( event, event );
    };
    
    proto.onpointerup = function( event ) {
      this.withPointer( 'pointerUp', event );
    };
    
    proto.ontouchend = function( event ) {
      this.withTouch( 'pointerUp', event );
    };
    
    proto.pointerUp = function( event, pointer ) {
      this.pointerDone();
      this.emitEvent( 'pointerUp', [ event, pointer ] );
    
      if ( this.isDragging ) {
        this.dragEnd( event, pointer );
      } else {
        // pointer didn't move enough for drag to start
        this.staticClick( event, pointer );
      }
    };
    
    proto.dragEnd = function( event, pointer ) {
      this.isDragging = false; // reset flag
      // re-enable clicking async
      setTimeout( () => delete this.isPreventingClicks );
    
      this.emitEvent( 'dragEnd', [ event, pointer ] );
    };
    
    // triggered on pointer up & pointer cancel
    proto.pointerDone = function() {
      this.isPointerDown = false;
      delete this.pointerIdentifier;
      this.unbindActivePointerEvents();
      this.emitEvent('pointerDone');
    };
    
    // ----- cancel ----- //
    
    proto.onpointercancel = function( event ) {
      this.withPointer( 'pointerCancel', event );
    };
    
    proto.ontouchcancel = function( event ) {
      this.withTouch( 'pointerCancel', event );
    };
    
    proto.pointerCancel = function( event, pointer ) {
      this.pointerDone();
      this.emitEvent( 'pointerCancel', [ event, pointer ] );
    };
    
    // ----- click ----- //
    
    // handle all clicks and prevent clicks when dragging
    proto.onclick = function( event ) {
      if ( this.isPreventingClicks ) event.preventDefault();
    };
    
    // triggered after pointer down & up with no/tiny movement
    proto.staticClick = function( event, pointer ) {
      // ignore emulated mouse up clicks
      let isMouseup = event.type === 'mouseup';
      if ( isMouseup && this.isIgnoringMouseUp ) return;
    
      this.emitEvent( 'staticClick', [ event, pointer ] );
    
      // set flag for emulated clicks 300ms after touchend
      if ( isMouseup ) {
        this.isIgnoringMouseUp = true;
        // reset flag after 400ms
        setTimeout( () => {
          delete this.isIgnoringMouseUp;
        }, 400 );
      }
    };
    
    // -----  ----- //
    
    return Unidragger;
    
    } ) );
    
    },{"ev-emitter":5}],38:[function(require,module,exports){
    !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).VenoBox=t()}(this,(function(){"use strict";
    /**
        * VenoBox 2.0.4
        * Copyright 2013-2021 Nicola Franchini
        * @license: https://github.com/nicolafranchini/VenoBox/blob/master/LICENSE
        */let e,t,o,n,s,i,a,r,l,d,c,v,u,b,p,g,f,m,y,x,h,L,w,k,S,C,E,A,P,q,M,T,j,H,O,z,B;const I=document.createElement("div");let V=0,R=0,D=0,N=!1,Q=new Image;const W={bounce:["sk-bounce","sk-bounce-dot",2],chase:["sk-chase","sk-chase-dot",6],circle:["sk-circle","sk-circle-dot",12],"circle-fade":["sk-circle-fade","sk-circle-fade-dot",12],flow:["sk-flow","sk-flow-dot",3],fold:["sk-fold","sk-fold-cube",4],grid:["sk-grid","sk-grid-cube",9],plane:["sk-plane","",0],pulse:["sk-pulse","",5],swing:["sk-swing","sk-swing-dot",2],wander:["sk-wander","sk-wander-cube",3],wave:["sk-wave","sk-wave-rec",5]},X={selector:".venobox",autoplay:!1,bgcolor:"#fff",border:"0",customClass:!1,infinigall:!1,maxWidth:"100%",navigation:!0,navKeyboard:!0,navTouch:!0,navSpeed:300,numeration:!1,overlayClose:!0,overlayColor:"rgba(23,23,23,0.95)",popup:!1,ratio:"16x9",share:!1,shareStyle:"pill",spinner:"bounce",spinColor:"#d2d2d2",titleattr:"title",titlePosition:"top",titleStyle:"bar",toolsBackground:"#1C1C1C",toolsColor:"#d2d2d2",onPreOpen:function(){return!0},onPostOpen:function(){},onPreClose:function(){return!0},onNavComplete:function(){},onContentLoaded:function(){},onInit:function(){},jQuerySelectors:!1};function Y(e,t,o){if("[object Object]"===Object.prototype.toString.call(e)){let n;for(n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.call(o,e[n],n,e)}else{let n=0,s=e.length;for(n=0;n<s;n++)t.call(o,e[n],n,e)}}function Z(e){return e}function $({timing:e,draw:t,duration:o}){let n=performance.now();requestAnimationFrame((function s(i){let a=(i-n)/o;a>1&&(a=1);let r=e(a);t(r),a<1&&requestAnimationFrame(s)}))}function F(e){if(!e)return!1;y=!0,r=e,L=!1,w=!1,S=e.getAttribute("data-maxwidth")||e.settings.maxWidth,C=e.getAttribute("data-overlay")||e.settings.overlayColor,E=e.getAttribute("data-ratio")||e.settings.ratio,A=e.getAttribute("data-autoplay")||e.settings.autoplay,P=e.getAttribute("data-href")||e.getAttribute("href"),q=e.getAttribute("data-customclass")||e.settings.customClass,z=e.getAttribute(e.settings.titleattr)||"",H=e.getAttribute("data-border")||e.settings.border}function K(){return!(!r||!document.body.classList.contains("vbox-open"))&&((!r.settings.onPreClose||"function"!=typeof r.settings.onPreClose||(r.settings.onPreClose(r,p,T,j),!1!==r.settings.onPreClose))&&(document.body.removeEventListener("keydown",G),document.body.classList.remove("vbox-open"),r.focus(),void $({duration:200,timing:Z,draw:function(e){k.style.opacity=1-e,1===e&&k.remove()}})))}function U(){le(T)}function _(){le(j)}function G(e){27===e.keyCode&&K(),B||(37==e.keyCode&&!0===w&&le(j),39==e.keyCode&&!0===L&&le(T),B=setTimeout((()=>{B=null}),100))}function J(e){a.classList.contains("vbox-"+e)||function(){y=!1,a.style.opacity=0,a.innerHTML=x;let e=a.querySelector(":first-child");e.classList.add("vbox-child"),e.style.backgroundColor=r.settings.bgcolor,e.style.maxWidth=S,e.style.transform="scale(0.9)",e.style.transition="transform 200ms";let t=a.querySelector(".vbox-child img");t&&t.addEventListener("dragstart",(function(e){e.preventDefault()})),i.scrollTo(0,0),e.style.transform="scale(1)",k.style.setProperty("--vbox-padding",H),Y(k.classList,(function(e){"vbox-overlay"!==e&&k.classList.remove(e)})),q&&k.classList.add(q),$({duration:200,timing:Z,draw:function(e){a.style.opacity=e,1===e&&u.classList.add("vbox-hidden")}}),r.settings.onContentLoaded&&"function"==typeof r.settings.onContentLoaded&&r.settings.onContentLoaded(x)}()}function ee(e,t,o){let n;if(a.classList.add("vbox-loading"),-1!==e.search(/.+\.mp4|og[gv]|webm/))n=o?" autoplay":"",x='<div class="venoratio venoratio-'+t+'"><video src="'+e+'"'+n+" controls>Your browser does not support the video tag.</video></div>";else{let s,i=function(e){let t;return e.match(/(http:|https:|)\/\/(player.|www.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com))\/(video\/|embed\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/),RegExp.$3.indexOf("youtu")>-1?t="youtube":RegExp.$3.indexOf("vimeo")>-1&&(t="vimeo"),{type:t,id:RegExp.$6}}(e);n=o?"?rel=0&autoplay=1":"?rel=0";let a=n+function(e){let t="",o=decodeURIComponent(e).split("?");if(void 0!==o[1]){let e,n,s=o[1].split("&");for(n=0;n<s.length;n++)e=s[n].split("="),t=t+"&"+e[0]+"="+e[1]}return encodeURI(t)}(e);"vimeo"==i.type?s="https://player.vimeo.com/video/":"youtube"==i.type&&(s="https://www.youtube.com/embed/"),x='<div class="venoratio venoratio-'+t+'"><iframe webkitallowfullscreen mozallowfullscreen allowfullscreen allow="autoplay" frameborder="0" src="'+s+i.id+a+'"></iframe></div>'}a.classList.remove("vbox-loading"),J("animated")}function te(){var e;if(e=x,I.innerHTML=e,g=I.querySelectorAll("img"),g.length){let e=0;Y(g,(function(t){let o=t.src;Q=new Image,Q.onload=function(){e++,e==g.length&&(a.classList.remove("vbox-loading"),J("animated"))},Q.onerror=function(){e++,e==g.length&&(a.classList.remove("vbox-loading"),J("animated"))},Q.src=o}))}else a.classList.remove("vbox-loading"),J("animated")}function oe(e){if(!y){let t=.84*r.settings.navSpeed;a.style.transition="margin "+t+"ms ease-out, opacity "+t+"ms ease-out",M=v=e.pageY,V=R=e.pageX,N=!0}}function ne(e){if(N){N=!1;let e=r,t=!1;D=R-V,D<0&&L&&(e=T,t=!0),D>0&&w&&(e=j,t=!0),Math.abs(D)>=50&&t?le(e):(a.style.marginLeft=0,a.style.opacity=1)}}function se(e){if(N&&!y){R=e.pageX,v=e.pageY,d=R-V,c=v-M;let t=Math.abs(d);if(t>Math.abs(c)&&t<=180){let o=1.5*(1-t/180);e.preventDefault(),a.style.marginLeft=d+"px",a.style.opacity=o}}}function ie(e){if(!e)return!1;O=e.dataset.gall,h=e.settings.numeration,f=e.settings.infinigall,o.innerHTML="";let s=e.dataset.vbtype;e.settings.share&&"iframe"!==s&&"inline"!==s&&"ajax"!==s&&function(e){if(navigator.canShare){const t={url:e};o.insertAdjacentHTML("beforeend",'<div class="vbox-link-btn vbox-share-mobile"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M3.5 6a.5.5 0 0 0-.5.5v8a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.5h-2a.5.5 0 0 1 0-1h2A1.5 1.5 0 0 1 14 6.5v8a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 14.5v-8A1.5 1.5 0 0 1 3.5 5h2a.5.5 0 0 1 0 1h-2z"/><path fill-rule="evenodd" d="M7.646.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 1.707V10.5a.5.5 0 0 1-1 0V1.707L5.354 3.854a.5.5 0 1 1-.708-.708l3-3z"/></svg></div>'),o.querySelector(".vbox-share-mobile").addEventListener("click",(function(e){e.preventDefault(),navigator.share(t)}))}o.insertAdjacentHTML("beforeend",'<a target="_blank" href="'+e+'" download><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/></svg></a>'),o.insertAdjacentHTML("beforeend",'<div class="vbox-tooltip"><div class="vbox-link-btn vbox-share-copy"><span class="vbox-tooltip-text" id="myTooltip"></span><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M10.854 7.146a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 1 1 .708-.708L7.5 9.793l2.646-2.647a.5.5 0 0 1 .708 0z"/><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg></div ></div>'),o.querySelector(".vbox-share-copy").addEventListener("click",(function(t){t.preventDefault();let o=document.getElementById("myTooltip");navigator.clipboard.writeText(e).then((function(){o.innerHTML='<div class="vbox-tooltip-inner">Copied</div>'}),(function(){console.log("copy failed")}))}))}(e.href),m=document.querySelectorAll('.vbox-item[data-gall="'+O+'"]'),l=Array.prototype.indexOf.call(m,e),m.length<2&&(f=!1,h=!1),T=m[l+1],j=m[l-1],!T&&f&&(T=m[0]),!j&&f&&(j=m[m.length-1]),m.length>=1?(p=l+1,t.innerHTML=p+" / "+m.length):p=1,h?t.classList.remove("vbox-hidden"):t.classList.add("vbox-hidden"),""!==z?n.classList.remove("vbox-hidden"):n.classList.add("vbox-hidden"),n.innerHTML=z,w=!1,L=!1,(T||f)&&(L=!0),(l>0||f)&&(w=!0),(w||L)&&e.settings.navTouch?(a.classList.add("vbox-grab"),a.addEventListener("touchstart",oe,!1),a.addEventListener("touchend",ne,!1),a.addEventListener("touchmove",se,!1),a.addEventListener("mousedown",oe,!1),a.addEventListener("mouseup",ne,!1),a.addEventListener("mouseout",ne,!1),a.addEventListener("mousemove",se,!1)):(a.classList.remove("vbox-grab"),a.removeEventListener("touchstart",oe,!1),a.removeEventListener("touchend",ne,!1),a.removeEventListener("touchmove",se,!1),a.removeEventListener("mousedown",oe,!1),a.removeEventListener("mouseup",ne,!1),a.removeEventListener("mouseout",ne,!1),a.removeEventListener("mousemove",se,!1));let i=k.querySelector(".vbox-next"),r=k.querySelector(".vbox-prev");w?r.classList.remove("vbox-hidden"):r.classList.add("vbox-hidden"),L?i.classList.remove("vbox-hidden"):i.classList.add("vbox-hidden"),e.settings.navigation||(i.classList.add("vbox-hidden"),r.classList.add("vbox-hidden"))}function ae(t){if(!t)return!1;e.style.backgroundColor=C,b.innerHTML=function(e){if(!e)return"Loading...";let t='<div class="sk-center '+e[0]+'">',o=0;for(o=0;o<e[2];o++)t+='<div class="'+e[1]+'"></div>';return t+="</div>",t}(W[t.settings.spinner]),k.style.setProperty("--sk-color",t.settings.spinColor),u.classList.remove("vbox-hidden"),o.classList.remove("vbox-top","vbox-bottom"),n.classList.remove("vbox-top","vbox-bottom"),"top"==t.settings.titlePosition?(n.classList.add("vbox-top"),o.classList.add("vbox-bottom")):(n.classList.add("vbox-bottom"),o.classList.add("vbox-top"));let s="bar"===t.settings.titleStyle?"100%":"auto",i="pill"===t.settings.titleStyle?"5em":"0",a="bar"===t.settings.shareStyle?"100%":"auto",r="pill"===t.settings.shareStyle?"5em":"0",l="transparent"===t.settings.titleStyle?"transparent":t.settings.toolsBackground,d="transparent"===t.settings.shareStyle?"transparent":t.settings.toolsBackground;k.style.setProperty("--vbox-title-width",s),k.style.setProperty("--vbox-title-radius",i),k.style.setProperty("--vbox-share-width",a),k.style.setProperty("--vbox-share-radius",r),k.style.setProperty("--vbox-tools-color",t.settings.toolsColor),k.style.setProperty("--vbox-title-background",l),k.style.setProperty("--vbox-share-background",d)}function re(){if(!r)return!1;switch(r.dataset.vbtype){case"iframe":e=P,t=E,a.classList.add("vbox-loading"),x='<div class="venoratio venoratio-'+t+'"><iframe src="'+e+'"></iframe></div>',a.classList.remove("vbox-loading"),J("animated");break;case"inline":!function(e){let t=document.querySelector(e);t&&(a.classList.add("vbox-loading"),x='<div class="vbox-inline">'+t.innerHTML+"</div>",a.classList.remove("vbox-loading"),J("animated"))}(P);break;case"ajax":!function(e){a.classList.add("vbox-loading");let t=new XMLHttpRequest;t.open("GET",e,!0),t.onload=function(){x='<div class="vbox-inline">'+t.response+"</div>",te()},t.onerror=function(){x='<div class="vbox-inline"></div>',a.classList.remove("vbox-loading"),J("animated")},t.send()}(P);break;case"video":ee(P,E,A);break;default:!function(e){Q.onload=function(){x='<div class="vbox-child"><img src="'+e+'"></div>',a.classList.remove("vbox-loading"),J("animated")},Q.src=e}(P)}var e,t}function le(e){if(!e||y||!document.body.classList.contains("vbox-open"))return!1;F(e),ae(e);let t=.84*r.settings.navSpeed;a.style.transition="margin "+t+"ms ease-out, opacity "+t+"ms ease-out",e===j&&a.classList.add("swipe-right"),e===T&&a.classList.add("swipe-left"),u.classList.remove("vbox-hidden");let o=a.style.opacity;a.classList.add("vbox-animated","vbox-loading"),ie(e),$({duration:r.settings.navSpeed,timing:Z,draw:function(e){a.style.opacity=o-e/o,1===e&&(a.classList.remove("swipe-left","swipe-right","vbox-animated"),a.style.marginLeft=0,a.style.transition="",J("loading"),y=!1,r.settings.onNavComplete&&"function"==typeof r.settings.onNavComplete&&r.settings.onNavComplete(r,p,T,j))}}),re()}function de(l){return!(document.body.classList.contains("vbox-open")||!l)&&(l.settings.onPreOpen&&"function"==typeof l.settings.onPreOpen&&l.settings.onPreOpen(l),!!l.settings.onPreOpen&&(F(l),document.body.insertAdjacentHTML("beforeend",s),document.body.classList.add("vbox-open"),k=document.querySelector(".vbox-overlay"),e=k.querySelector(".vbox-backdrop"),i=k.querySelector(".vbox-container"),a=i.querySelector(".vbox-content"),t=k.querySelector(".vbox-num"),o=k.querySelector(".vbox-share"),n=k.querySelector(".vbox-title"),u=k.querySelector(".vbox-preloader"),b=u.querySelector(".vbox-preloader-inner"),k.style.opacity=0,ae(l),ie(l),a.classList.add("vbox-animated","vbox-loading"),$({duration:200,timing:Z,draw:function(e){k.style.opacity=e,1===e&&(a.classList.remove("vbox-animated"),y=!1,J("loading"),r.settings.onPostOpen&&"function"==typeof r.settings.onPostOpen&&r.settings.onPostOpen(r,p,T,j))}}),re(),l.settings.navKeyboard&&(document.body.addEventListener("keydown",G),document.body.addEventListener("keyup",(()=>{B&&(clearTimeout(B),B=null)}))),document.querySelector(".vbox-prev").addEventListener("click",(function(){le(j)})),document.querySelector(".vbox-next").addEventListener("click",(function(){le(T)})),void k.addEventListener("click",(function(e){let t=document.querySelector(".vbox-close");t&&(t.contains(e.target)||t===e.target||r.settings.overlayClose&&e.target.classList.contains("vbox-overlay")||e.target.classList.contains("vbox-content")||e.target.classList.contains("vbox-backdrop")||e.target.classList.contains("vbox-close")||e.target.classList.contains("vbox-preloader")||e.target.classList.contains("vbox-container"))&&K()}))))}const ce=function(e){const t={};let o=function(e,t){let o={};return Y(e,(function(t,n){o[n]=e[n]})),Y(t,(function(e,n){o[n]=t[n]})),o}(X,e||{});return t.close=K,t.next=U,t.prev=_,t.open=de,t.settings=o,function(e,t){t.onInit&&"function"==typeof t.onInit&&t.onInit(e);let o=t.jQuerySelectors||document.querySelectorAll(t.selector);if(s='<div class="vbox-overlay"><div class="vbox-backdrop"></div><div class="vbox-preloader"><div class="vbox-preloader-inner"></div></div><div class="vbox-container"><div class="vbox-content"></div></div><div class="vbox-title"></div><div class="vbox-left-corner"><div class="vbox-num">0/0</div></div><div class="vbox-close"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="currentColor" class="vbox-close-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M13.854 2.146a.5.5 0 0 1 0 .708l-11 11a.5.5 0 0 1-.708-.708l11-11a.5.5 0 0 1 .708 0Z"/><path fill-rule="evenodd" d="M2.146 2.146a.5.5 0 0 0 0 .708l11 11a.5.5 0 0 0 .708-.708l-11-11a.5.5 0 0 0-.708 0Z"/></svg></div><a class="vbox-next"><span>Next</span></a><a class="vbox-prev"><span>Prev</span></a><div class="vbox-share"></div></div>',Y(o,(function(e){if(e.classList.contains("vbox-item"))return!0;e.settings=t,e.classList.add("vbox-item"),e.addEventListener("click",(function(t){return t.preventDefault(),e.blur(),de(e),!1}))})),t.popup){let e=document.querySelector(t.popup);e.settings=t,de(e)}}(t,o),t};return"function"==typeof jQuery&&jQuery.fn.extend({venobox:function(e){const t=e||{};t.jQuerySelectors=this,new ce({pluginoptions:t})}}),ce}));
    
    
    },{}],39:[function(require,module,exports){
    "use strict";
    
    var _bootstrap = require("bootstrap");
    var _facileValidator = require("@upjs/facile-validator");
    // Bootstrap component
    
    // Fizzy UI utils
    var Utils = require('fizzy-ui-utils');
    
    // Flickity
    var Flickity = require('flickity');
    
    // Images loaded 
    var ImagesLoaded = require('imagesloaded');
    
    // Isotope 
    var Isotope = require('isotope-layout');
    
    // Validator
    
    // Venobox
    var VenoBox = require('venobox');
    window.addEventListener("DOMContentLoaded", function (e) {
      ImagesLoaded(document.querySelector('#page-top'), {
        background: true
      }, function () {
        // Hide preloader
        setTimeout(function () {
          document.querySelector('.preloader').classList.add('d-none');
        }, 2000);
    
        // Build gallery layout
        new Isotope(document.querySelector('.gallery-grid'), {
          itemSelector: '.item',
          layoutMode: 'masonry'
        });
    
        // Scroll spy init
        spySections.forEach(function (section) {
          observer.observe(section);
        });
      });
    });
    
    // Navbar collapse
    var nav = document.getElementById('navbar');
    var navCollapse = new _bootstrap.Collapse(nav, {
      toggle: false
    });
    
    // Page scroll
    var navHeight = 100;
    var pageScrollLink = document.querySelectorAll('.page-scroll');
    pageScrollLink.forEach(function (link) {
      link.addEventListener('click', function (e) {
        var target = document.getElementById(link.getAttribute('href').substring(1));
        window.scrollTo({
          top: target.offsetTop - (navHeight - 1),
          behavior: 'smooth'
        });
    
        // Automatically retract the navbar after clicking on one of the menu items
        navCollapse.hide();
        e.preventDefault();
      });
    });
    
    // Scroll spy
    var spySections = document.querySelectorAll('section');
    var spyItem = function spyItem(entries, observer) {
      entries.forEach(function (entry) {
        var id = entry.target.id;
        var spy = nav.querySelector("[href=\"#".concat(id, "\""));
        if (spy) {
          spy.classList.remove('active');
          if (!entry.isIntersecting) return;
          spy.classList.add('active');
        }
      });
    };
    var rootMarginBottom = navHeight - window.innerHeight + 'px';
    var observer = new IntersectionObserver(spyItem, {
      root: document,
      rootMargin: "-100px 0% ".concat(rootMarginBottom, " 0%")
    });
    
    // Carousel
    var carousel = document.getElementById('carousel-love-story');
    var carouselCell = document.querySelectorAll('.carousel-cell');
    var carouselPage = document.querySelector('.carousel-page');
    
    // Carousel init
    var flkty = new Flickity(carousel, {
      cellSelector: '.carousel-cell',
      cellAlign: 'left',
      contain: true,
      prevNextButtons: false,
      pageDots: false,
      //draggable: false,
      imagesLoaded: true,
      pauseAutoPlayOnHover: false
    });
    
    // Build carousel page
    for (var i = 0; i < carouselCell.length; i++) {
      var li = document.createElement('li');
      li.classList.add('list-inline-item', 'mx-2', 'page-dots');
      if (i == 0) {
        li.classList.add('is-selected');
      }
      carouselPage.append(li);
    }
    
    // Carousel cell select
    var pageItem = Utils.makeArray(carouselPage.children);
    pageItem.forEach(function (item, index) {
      item.addEventListener('click', function (e) {
        flkty.select(index);
      });
    });
    
    // Update page item on select
    flkty.on('select', function (index) {
      var previousSelectedItem = carouselPage.querySelector('.is-selected');
      var selectedItem = carouselPage.children[flkty.selectedIndex];
      previousSelectedItem.classList.remove('is-selected');
      selectedItem.classList.add('is-selected');
    });
    
    // Galleri lightbox
    new VenoBox({
      selector: '.gallery-grid a',
      infinigall: true,
      numeration: true,
      overlayColor: '#ffffff',
      spinner: 'pulse'
    });
    
    // Form validator
    var form = document.querySelector('form');
    var btnSubmit = document.querySelector('button[type="submit"]');
    var defaultMessage = btnSubmit.innerHTML;
    var sendingMessage = 'Loading...';
    var errorMessage = 'Error Sending';
    var successMessage = 'Email Sent';
    
    // Create an instance of Validator for the container element
    var v = new _facileValidator.Validator(form, {
      lang: _facileValidator.enLang,
      on: {
        'validation:success': function validationSuccess() {
          btnSubmit.innerHTML = sendingMessage;
          fetch(form.getAttribute('action'), {
            method: form.getAttribute('method'),
            body: new FormData(form)
          }).then(function (res) {
            return res.text();
          }).then(function (data) {
            if (data === 'true') {
              btnSubmit.innerHTML = successMessage;
              form.reset();
            } else {
              btnSubmit.innerHTML = errorMessage;
            }
            setTimeout(function () {
              btnSubmit.innerHTML = defaultMessage;
            }, 5000);
          });
        }
      }
    });
    form.addEventListener('submit', function (e) {
      // Call validate method to start validation
      v.validate();
      e.preventDefault();
    });
    
    },{"@upjs/facile-validator":2,"bootstrap":3,"fizzy-ui-utils":6,"flickity":13,"imagesloaded":20,"isotope-layout":21,"venobox":38}]},{},[39]);
    